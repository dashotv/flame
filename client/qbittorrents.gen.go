// Code generated by github.com/dashotv/golem. DO NOT EDIT.
package client

import (
	"context"
	"fmt"

	"github.com/dashotv/fae"
	"github.com/dashotv/flame/qbt"
)

type QbittorrentsService struct {
	client *Client
}

// NewQbittorrents makes a new client for accessing Qbittorrents services.
func NewQbittorrentsService(client *Client) *QbittorrentsService {
	return &QbittorrentsService{
		client: client,
	}
}

type QbittorrentsIndexResponse struct {
	*Response
	Result *qbt.Response `json:"result"`
	Total  int64         `json:"total"`
}

func (s *QbittorrentsService) Index(ctx context.Context) (*QbittorrentsIndexResponse, error) {
	result := &QbittorrentsIndexResponse{Response: &Response{}}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetResult(result).
		Get("/qbittorrents/")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type QbittorrentsAddRequest struct {
	URL string `json:"url"`
}

type QbittorrentsAddResponse struct {
	*Response
	Result string `json:"result"`
}

func (s *QbittorrentsService) Add(ctx context.Context, req *QbittorrentsAddRequest) (*QbittorrentsAddResponse, error) {
	result := &QbittorrentsAddResponse{Response: &Response{}}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetQueryParam("url", fmt.Sprintf("%v", req.URL)).
		Get("/qbittorrents/add")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type QbittorrentsRemoveRequest struct {
	Infohash string `json:"infohash"`
	Del      bool   `json:"del"`
}

func (s *QbittorrentsService) Remove(ctx context.Context, req *QbittorrentsRemoveRequest) (*Response, error) {
	result := &Response{}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetQueryParam("infohash", fmt.Sprintf("%v", req.Infohash)).
		SetQueryParam("del", fmt.Sprintf("%v", req.Del)).
		Get("/qbittorrents/remove")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type QbittorrentsPauseRequest struct {
	Infohash string `json:"infohash"`
}

func (s *QbittorrentsService) Pause(ctx context.Context, req *QbittorrentsPauseRequest) (*Response, error) {
	result := &Response{}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetQueryParam("infohash", fmt.Sprintf("%v", req.Infohash)).
		Get("/qbittorrents/pause")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type QbittorrentsResumeRequest struct {
	Infohash string `json:"infohash"`
}

func (s *QbittorrentsService) Resume(ctx context.Context, req *QbittorrentsResumeRequest) (*Response, error) {
	result := &Response{}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetQueryParam("infohash", fmt.Sprintf("%v", req.Infohash)).
		Get("/qbittorrents/resume")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type QbittorrentsLabelRequest struct {
	Infohash string `json:"infohash"`
	Label    string `json:"label"`
}

func (s *QbittorrentsService) Label(ctx context.Context, req *QbittorrentsLabelRequest) (*Response, error) {
	result := &Response{}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetQueryParam("infohash", fmt.Sprintf("%v", req.Infohash)).
		SetQueryParam("label", fmt.Sprintf("%v", req.Label)).
		Get("/qbittorrents/label")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type QbittorrentsWantRequest struct {
	Infohash string `json:"infohash"`
	Files    string `json:"files"`
}

func (s *QbittorrentsService) Want(ctx context.Context, req *QbittorrentsWantRequest) (*Response, error) {
	result := &Response{}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetQueryParam("infohash", fmt.Sprintf("%v", req.Infohash)).
		SetQueryParam("files", fmt.Sprintf("%v", req.Files)).
		Get("/qbittorrents/want")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}

type QbittorrentsWantedRequest struct {
	Infohash string `json:"infohash"`
}

func (s *QbittorrentsService) Wanted(ctx context.Context, req *QbittorrentsWantedRequest) (*Response, error) {
	result := &Response{}
	resp, err := s.client.Resty.R().
		SetContext(ctx).
		SetBody(req).
		SetResult(result).
		SetQueryParam("infohash", fmt.Sprintf("%v", req.Infohash)).
		Get("/qbittorrents/wanted")
	if err != nil {
		return nil, fae.Wrap(err, "failed to make request")
	}
	if !resp.IsSuccess() {
		return nil, fae.Errorf("%d: %v", resp.StatusCode(), resp.String())
	}
	if result.Error {
		return nil, fae.New(result.Message)
	}

	return result, nil
}
