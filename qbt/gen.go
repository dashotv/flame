// Package qbt provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package qbt

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
)

const (
	SidScopes = "sid.Scopes"
)

// Defines values for AddTorrentsCommonFirstLastPiecePrio.
const (
	AddTorrentsCommonFirstLastPiecePrioFalse AddTorrentsCommonFirstLastPiecePrio = "false"
	AddTorrentsCommonFirstLastPiecePrioTrue  AddTorrentsCommonFirstLastPiecePrio = "true"
)

// Defines values for AddTorrentsCommonPaused.
const (
	AddTorrentsCommonPausedFalse AddTorrentsCommonPaused = "false"
	AddTorrentsCommonPausedTrue  AddTorrentsCommonPaused = "true"
)

// Defines values for AddTorrentsCommonRootFolder.
const (
	AddTorrentsCommonRootFolderFalse AddTorrentsCommonRootFolder = "false"
	AddTorrentsCommonRootFolderTrue  AddTorrentsCommonRootFolder = "true"
	AddTorrentsCommonRootFolderUnset AddTorrentsCommonRootFolder = "unset"
)

// Defines values for AddTorrentsCommonSequentialDownload.
const (
	AddTorrentsCommonSequentialDownloadFalse AddTorrentsCommonSequentialDownload = "false"
	AddTorrentsCommonSequentialDownloadTrue  AddTorrentsCommonSequentialDownload = "true"
)

// Defines values for AddTorrentsCommonSkipChecking.
const (
	AddTorrentsCommonSkipCheckingFalse AddTorrentsCommonSkipChecking = "false"
	AddTorrentsCommonSkipCheckingTrue  AddTorrentsCommonSkipChecking = "true"
)

// Defines values for AddTorrentsFilesFirstLastPiecePrio.
const (
	AddTorrentsFilesFirstLastPiecePrioFalse AddTorrentsFilesFirstLastPiecePrio = "false"
	AddTorrentsFilesFirstLastPiecePrioTrue  AddTorrentsFilesFirstLastPiecePrio = "true"
)

// Defines values for AddTorrentsFilesPaused.
const (
	AddTorrentsFilesPausedFalse AddTorrentsFilesPaused = "false"
	AddTorrentsFilesPausedTrue  AddTorrentsFilesPaused = "true"
)

// Defines values for AddTorrentsFilesRootFolder.
const (
	AddTorrentsFilesRootFolderFalse AddTorrentsFilesRootFolder = "false"
	AddTorrentsFilesRootFolderTrue  AddTorrentsFilesRootFolder = "true"
	AddTorrentsFilesRootFolderUnset AddTorrentsFilesRootFolder = "unset"
)

// Defines values for AddTorrentsFilesSequentialDownload.
const (
	AddTorrentsFilesSequentialDownloadFalse AddTorrentsFilesSequentialDownload = "false"
	AddTorrentsFilesSequentialDownloadTrue  AddTorrentsFilesSequentialDownload = "true"
)

// Defines values for AddTorrentsFilesSkipChecking.
const (
	AddTorrentsFilesSkipCheckingFalse AddTorrentsFilesSkipChecking = "false"
	AddTorrentsFilesSkipCheckingTrue  AddTorrentsFilesSkipChecking = "true"
)

// Defines values for AddTorrentsURLsFirstLastPiecePrio.
const (
	AddTorrentsURLsFirstLastPiecePrioFalse AddTorrentsURLsFirstLastPiecePrio = "false"
	AddTorrentsURLsFirstLastPiecePrioTrue  AddTorrentsURLsFirstLastPiecePrio = "true"
)

// Defines values for AddTorrentsURLsPaused.
const (
	AddTorrentsURLsPausedFalse AddTorrentsURLsPaused = "false"
	AddTorrentsURLsPausedTrue  AddTorrentsURLsPaused = "true"
)

// Defines values for AddTorrentsURLsRootFolder.
const (
	AddTorrentsURLsRootFolderFalse AddTorrentsURLsRootFolder = "false"
	AddTorrentsURLsRootFolderTrue  AddTorrentsURLsRootFolder = "true"
	AddTorrentsURLsRootFolderUnset AddTorrentsURLsRootFolder = "unset"
)

// Defines values for AddTorrentsURLsSequentialDownload.
const (
	AddTorrentsURLsSequentialDownloadFalse AddTorrentsURLsSequentialDownload = "false"
	AddTorrentsURLsSequentialDownloadTrue  AddTorrentsURLsSequentialDownload = "true"
)

// Defines values for AddTorrentsURLsSkipChecking.
const (
	False AddTorrentsURLsSkipChecking = "false"
	True  AddTorrentsURLsSkipChecking = "true"
)

// Defines values for MainLogType.
const (
	MainLogTypeN1 MainLogType = 1
	MainLogTypeN2 MainLogType = 2
	MainLogTypeN4 MainLogType = 4
	MainLogTypeN8 MainLogType = 8
)

// Defines values for PreferencesBittorrentProtocol.
const (
	PreferencesBittorrentProtocolN0 PreferencesBittorrentProtocol = 0
	PreferencesBittorrentProtocolN1 PreferencesBittorrentProtocol = 1
	PreferencesBittorrentProtocolN2 PreferencesBittorrentProtocol = 2
)

// Defines values for PreferencesDyndnsService.
const (
	PreferencesDyndnsServiceN0 PreferencesDyndnsService = 0
	PreferencesDyndnsServiceN1 PreferencesDyndnsService = 1
)

// Defines values for PreferencesEncryption.
const (
	PreferencesEncryptionN0 PreferencesEncryption = 0
	PreferencesEncryptionN1 PreferencesEncryption = 1
	PreferencesEncryptionN2 PreferencesEncryption = 2
)

// Defines values for PreferencesMaxRatioAct.
const (
	PreferencesMaxRatioActN0 PreferencesMaxRatioAct = 0
	PreferencesMaxRatioActN1 PreferencesMaxRatioAct = 1
)

// Defines values for PreferencesProxyType.
const (
	PreferencesProxyTypeMinus1 PreferencesProxyType = -1
	PreferencesProxyTypeN0     PreferencesProxyType = 0
	PreferencesProxyTypeN1     PreferencesProxyType = 1
	PreferencesProxyTypeN2     PreferencesProxyType = 2
	PreferencesProxyTypeN3     PreferencesProxyType = 3
	PreferencesProxyTypeN4     PreferencesProxyType = 4
	PreferencesProxyTypeN5     PreferencesProxyType = 5
)

// Defines values for PreferencesSchedulerDays.
const (
	PreferencesSchedulerDaysN0 PreferencesSchedulerDays = 0
	PreferencesSchedulerDaysN1 PreferencesSchedulerDays = 1
	PreferencesSchedulerDaysN2 PreferencesSchedulerDays = 2
	PreferencesSchedulerDaysN3 PreferencesSchedulerDays = 3
	PreferencesSchedulerDaysN4 PreferencesSchedulerDays = 4
	PreferencesSchedulerDaysN5 PreferencesSchedulerDays = 5
	PreferencesSchedulerDaysN6 PreferencesSchedulerDays = 6
	PreferencesSchedulerDaysN7 PreferencesSchedulerDays = 7
	PreferencesSchedulerDaysN8 PreferencesSchedulerDays = 8
	PreferencesSchedulerDaysN9 PreferencesSchedulerDays = 9
)

// Defines values for PreferencesUploadChokingAlgorithm.
const (
	PreferencesUploadChokingAlgorithmN0 PreferencesUploadChokingAlgorithm = 0
	PreferencesUploadChokingAlgorithmN1 PreferencesUploadChokingAlgorithm = 1
	PreferencesUploadChokingAlgorithmN2 PreferencesUploadChokingAlgorithm = 2
)

// Defines values for PreferencesUploadSlotsBehavior.
const (
	PreferencesUploadSlotsBehaviorN0 PreferencesUploadSlotsBehavior = 0
	PreferencesUploadSlotsBehaviorN1 PreferencesUploadSlotsBehavior = 1
)

// Defines values for PreferencesUtpTcpMixedMode.
const (
	PreferencesUtpTcpMixedModeN0 PreferencesUtpTcpMixedMode = 0
	PreferencesUtpTcpMixedModeN1 PreferencesUtpTcpMixedMode = 1
)

// Defines values for PreferencesScanDirsValue0.
const (
	PreferencesScanDirsValue0N0 PreferencesScanDirsValue0 = 0
	PreferencesScanDirsValue0N1 PreferencesScanDirsValue0 = 1
)

// Defines values for SearchJobStatusStatus.
const (
	SearchJobStatusStatusRunning SearchJobStatusStatus = "Running"
	SearchJobStatusStatusStopped SearchJobStatusStatus = "Stopped"
)

// Defines values for SearchJobStatusAllOfStatus.
const (
	SearchJobStatusAllOfStatusRunning SearchJobStatusAllOfStatus = "Running"
	SearchJobStatusAllOfStatusStopped SearchJobStatusAllOfStatus = "Stopped"
)

// Defines values for SearchResultsStatus.
const (
	Running SearchResultsStatus = "Running"
	Stopped SearchResultsStatus = "Stopped"
)

// Defines values for SetPreferencesBittorrentProtocol.
const (
	SetPreferencesBittorrentProtocolN0 SetPreferencesBittorrentProtocol = 0
	SetPreferencesBittorrentProtocolN1 SetPreferencesBittorrentProtocol = 1
	SetPreferencesBittorrentProtocolN2 SetPreferencesBittorrentProtocol = 2
)

// Defines values for SetPreferencesDyndnsService.
const (
	SetPreferencesDyndnsServiceN0 SetPreferencesDyndnsService = 0
	SetPreferencesDyndnsServiceN1 SetPreferencesDyndnsService = 1
)

// Defines values for SetPreferencesEncryption.
const (
	SetPreferencesEncryptionN0 SetPreferencesEncryption = 0
	SetPreferencesEncryptionN1 SetPreferencesEncryption = 1
	SetPreferencesEncryptionN2 SetPreferencesEncryption = 2
)

// Defines values for SetPreferencesMaxRatioAct.
const (
	SetPreferencesMaxRatioActN0 SetPreferencesMaxRatioAct = 0
	SetPreferencesMaxRatioActN1 SetPreferencesMaxRatioAct = 1
)

// Defines values for SetPreferencesProxyType.
const (
	SetPreferencesProxyTypeMinus1 SetPreferencesProxyType = -1
	SetPreferencesProxyTypeN0     SetPreferencesProxyType = 0
	SetPreferencesProxyTypeN1     SetPreferencesProxyType = 1
	SetPreferencesProxyTypeN2     SetPreferencesProxyType = 2
	SetPreferencesProxyTypeN3     SetPreferencesProxyType = 3
	SetPreferencesProxyTypeN4     SetPreferencesProxyType = 4
	SetPreferencesProxyTypeN5     SetPreferencesProxyType = 5
)

// Defines values for SetPreferencesSchedulerDays.
const (
	SetPreferencesSchedulerDaysN0 SetPreferencesSchedulerDays = 0
	SetPreferencesSchedulerDaysN1 SetPreferencesSchedulerDays = 1
	SetPreferencesSchedulerDaysN2 SetPreferencesSchedulerDays = 2
	SetPreferencesSchedulerDaysN3 SetPreferencesSchedulerDays = 3
	SetPreferencesSchedulerDaysN4 SetPreferencesSchedulerDays = 4
	SetPreferencesSchedulerDaysN5 SetPreferencesSchedulerDays = 5
	SetPreferencesSchedulerDaysN6 SetPreferencesSchedulerDays = 6
	SetPreferencesSchedulerDaysN7 SetPreferencesSchedulerDays = 7
	SetPreferencesSchedulerDaysN8 SetPreferencesSchedulerDays = 8
	SetPreferencesSchedulerDaysN9 SetPreferencesSchedulerDays = 9
)

// Defines values for SetPreferencesUploadChokingAlgorithm.
const (
	SetPreferencesUploadChokingAlgorithmN0 SetPreferencesUploadChokingAlgorithm = 0
	SetPreferencesUploadChokingAlgorithmN1 SetPreferencesUploadChokingAlgorithm = 1
	SetPreferencesUploadChokingAlgorithmN2 SetPreferencesUploadChokingAlgorithm = 2
)

// Defines values for SetPreferencesUploadSlotsBehavior.
const (
	SetPreferencesUploadSlotsBehaviorN0 SetPreferencesUploadSlotsBehavior = 0
	SetPreferencesUploadSlotsBehaviorN1 SetPreferencesUploadSlotsBehavior = 1
)

// Defines values for SetPreferencesUtpTcpMixedMode.
const (
	SetPreferencesUtpTcpMixedModeN0 SetPreferencesUtpTcpMixedMode = 0
	SetPreferencesUtpTcpMixedModeN1 SetPreferencesUtpTcpMixedMode = 1
)

// Defines values for TorrentInfoState.
const (
	TorrentInfoStateAllocating         TorrentInfoState = "allocating"
	TorrentInfoStateCheckingDL         TorrentInfoState = "checkingDL"
	TorrentInfoStateCheckingResumeData TorrentInfoState = "checkingResumeData"
	TorrentInfoStateCheckingUP         TorrentInfoState = "checkingUP"
	TorrentInfoStateDownloading        TorrentInfoState = "downloading"
	TorrentInfoStateError              TorrentInfoState = "error"
	TorrentInfoStateForcedDL           TorrentInfoState = "forcedDL"
	TorrentInfoStateForcedUP           TorrentInfoState = "forcedUP"
	TorrentInfoStateMetaDL             TorrentInfoState = "metaDL"
	TorrentInfoStateMissingFiles       TorrentInfoState = "missingFiles"
	TorrentInfoStateMoving             TorrentInfoState = "moving"
	TorrentInfoStatePausedDL           TorrentInfoState = "pausedDL"
	TorrentInfoStatePausedUP           TorrentInfoState = "pausedUP"
	TorrentInfoStateQueuedDL           TorrentInfoState = "queuedDL"
	TorrentInfoStateQueuedUP           TorrentInfoState = "queuedUP"
	TorrentInfoStateStalledDL          TorrentInfoState = "stalledDL"
	TorrentInfoStateStalledUP          TorrentInfoState = "stalledUP"
	TorrentInfoStateUnknown            TorrentInfoState = "unknown"
	TorrentInfoStateUploading          TorrentInfoState = "uploading"
)

// Defines values for TorrentsFilesPriority.
const (
	TorrentsFilesPriorityN0 TorrentsFilesPriority = 0
	TorrentsFilesPriorityN1 TorrentsFilesPriority = 1
	TorrentsFilesPriorityN6 TorrentsFilesPriority = 6
	TorrentsFilesPriorityN7 TorrentsFilesPriority = 7
)

// Defines values for TorrentsTrackersStatus.
const (
	TorrentsTrackersStatusN0 TorrentsTrackersStatus = 0
	TorrentsTrackersStatusN1 TorrentsTrackersStatus = 1
	TorrentsTrackersStatusN2 TorrentsTrackersStatus = 2
	TorrentsTrackersStatusN3 TorrentsTrackersStatus = 3
	TorrentsTrackersStatusN4 TorrentsTrackersStatus = 4
)

// Defines values for TorrentsFilePrioPostRequestPriority.
const (
	N0 TorrentsFilePrioPostRequestPriority = 0
	N1 TorrentsFilePrioPostRequestPriority = 1
	N6 TorrentsFilePrioPostRequestPriority = 6
	N7 TorrentsFilePrioPostRequestPriority = 7
)

// Defines values for TorrentsInfoPostRequestFilter.
const (
	TorrentsInfoPostRequestFilterActive             TorrentsInfoPostRequestFilter = "active"
	TorrentsInfoPostRequestFilterAll                TorrentsInfoPostRequestFilter = "all"
	TorrentsInfoPostRequestFilterCompleted          TorrentsInfoPostRequestFilter = "completed"
	TorrentsInfoPostRequestFilterDownloading        TorrentsInfoPostRequestFilter = "downloading"
	TorrentsInfoPostRequestFilterErrored            TorrentsInfoPostRequestFilter = "errored"
	TorrentsInfoPostRequestFilterInactive           TorrentsInfoPostRequestFilter = "inactive"
	TorrentsInfoPostRequestFilterPaused             TorrentsInfoPostRequestFilter = "paused"
	TorrentsInfoPostRequestFilterResumed            TorrentsInfoPostRequestFilter = "resumed"
	TorrentsInfoPostRequestFilterSeeding            TorrentsInfoPostRequestFilter = "seeding"
	TorrentsInfoPostRequestFilterStalled            TorrentsInfoPostRequestFilter = "stalled"
	TorrentsInfoPostRequestFilterStalledDownloading TorrentsInfoPostRequestFilter = "stalled_downloading"
	TorrentsInfoPostRequestFilterStalledUploading   TorrentsInfoPostRequestFilter = "stalled_uploading"
)

// AddTorrentsCommon defines model for AddTorrentsCommon.
type AddTorrentsCommon struct {
	// AutoTMM Whether Automatic Torrent Management should be used
	AutoTMM *bool `json:"autoTMM,omitempty"`

	// Category Category for the torrent
	Category *string `json:"category,omitempty"`

	// Cookie Cookie sent to download the .torrent file
	Cookie *string `json:"cookie,omitempty"`

	// DlLimit Set torrent download speed limit. Unit in bytes/second
	DlLimit *int64 `json:"dlLimit,omitempty"`

	// FirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
	FirstLastPiecePrio *AddTorrentsCommonFirstLastPiecePrio `json:"firstLastPiecePrio,omitempty"`

	// Paused Add torrents in the paused state. Possible values are `true`, `false` (default)
	Paused *AddTorrentsCommonPaused `json:"paused,omitempty"`

	// RatioLimit Set torrent share ratio limit
	RatioLimit *float32 `json:"ratioLimit,omitempty"`

	// Rename Rename torrent
	Rename *string `json:"rename,omitempty"`

	// RootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
	RootFolder *AddTorrentsCommonRootFolder `json:"root_folder,omitempty"`

	// Savepath Download folder
	Savepath *string `json:"savepath,omitempty"`

	// SeedingTimeLimit Set torrent seeding time limit. Unit in seconds
	SeedingTimeLimit *int64 `json:"seedingTimeLimit,omitempty"`

	// SequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
	SequentialDownload *AddTorrentsCommonSequentialDownload `json:"sequentialDownload,omitempty"`

	// SkipChecking Skip hash checking. Possible values are `true`, `false` (default)
	SkipChecking *AddTorrentsCommonSkipChecking `json:"skip_checking,omitempty"`

	// Tags Tags for the torrent, split by ','
	Tags *[]string `json:"tags,omitempty"`

	// UpLimit Set torrent upload speed limit. Unit in bytes/second
	UpLimit *int64 `json:"upLimit,omitempty"`
}

// AddTorrentsCommonFirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
type AddTorrentsCommonFirstLastPiecePrio string

// AddTorrentsCommonPaused Add torrents in the paused state. Possible values are `true`, `false` (default)
type AddTorrentsCommonPaused string

// AddTorrentsCommonRootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
type AddTorrentsCommonRootFolder string

// AddTorrentsCommonSequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
type AddTorrentsCommonSequentialDownload string

// AddTorrentsCommonSkipChecking Skip hash checking. Possible values are `true`, `false` (default)
type AddTorrentsCommonSkipChecking string

// AddTorrentsFiles defines model for AddTorrentsFiles.
type AddTorrentsFiles struct {
	// AutoTMM Whether Automatic Torrent Management should be used
	AutoTMM *bool `json:"autoTMM,omitempty"`

	// Category Category for the torrent
	Category *string `json:"category,omitempty"`

	// Cookie Cookie sent to download the .torrent file
	Cookie *string `json:"cookie,omitempty"`

	// DlLimit Set torrent download speed limit. Unit in bytes/second
	DlLimit *int64 `json:"dlLimit,omitempty"`

	// FirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
	FirstLastPiecePrio *AddTorrentsFilesFirstLastPiecePrio `json:"firstLastPiecePrio,omitempty"`

	// Paused Add torrents in the paused state. Possible values are `true`, `false` (default)
	Paused *AddTorrentsFilesPaused `json:"paused,omitempty"`

	// RatioLimit Set torrent share ratio limit
	RatioLimit *float32 `json:"ratioLimit,omitempty"`

	// Rename Rename torrent
	Rename *string `json:"rename,omitempty"`

	// RootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
	RootFolder *AddTorrentsFilesRootFolder `json:"root_folder,omitempty"`

	// Savepath Download folder
	Savepath *string `json:"savepath,omitempty"`

	// SeedingTimeLimit Set torrent seeding time limit. Unit in seconds
	SeedingTimeLimit *int64 `json:"seedingTimeLimit,omitempty"`

	// SequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
	SequentialDownload *AddTorrentsFilesSequentialDownload `json:"sequentialDownload,omitempty"`

	// SkipChecking Skip hash checking. Possible values are `true`, `false` (default)
	SkipChecking *AddTorrentsFilesSkipChecking `json:"skip_checking,omitempty"`

	// Tags Tags for the torrent, split by ','
	Tags *[]string `json:"tags,omitempty"`

	// Torrents Raw data of torrent file. `torrents` can be presented multiple times.
	Torrents *[]openapi_types.File `json:"torrents,omitempty"`

	// UpLimit Set torrent upload speed limit. Unit in bytes/second
	UpLimit *int64 `json:"upLimit,omitempty"`
}

// AddTorrentsFilesFirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
type AddTorrentsFilesFirstLastPiecePrio string

// AddTorrentsFilesPaused Add torrents in the paused state. Possible values are `true`, `false` (default)
type AddTorrentsFilesPaused string

// AddTorrentsFilesRootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
type AddTorrentsFilesRootFolder string

// AddTorrentsFilesSequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
type AddTorrentsFilesSequentialDownload string

// AddTorrentsFilesSkipChecking Skip hash checking. Possible values are `true`, `false` (default)
type AddTorrentsFilesSkipChecking string

// AddTorrentsFilesAllOf defines model for AddTorrentsFiles_allOf.
type AddTorrentsFilesAllOf struct {
	// Torrents Raw data of torrent file. `torrents` can be presented multiple times.
	Torrents *[]openapi_types.File `json:"torrents,omitempty"`
}

// AddTorrentsURLs defines model for AddTorrentsURLs.
type AddTorrentsURLs struct {
	// AutoTMM Whether Automatic Torrent Management should be used
	AutoTMM *bool `json:"autoTMM,omitempty"`

	// Category Category for the torrent
	Category *string `json:"category,omitempty"`

	// Cookie Cookie sent to download the .torrent file
	Cookie *string `json:"cookie,omitempty"`

	// DlLimit Set torrent download speed limit. Unit in bytes/second
	DlLimit *int64 `json:"dlLimit,omitempty"`

	// FirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
	FirstLastPiecePrio *AddTorrentsURLsFirstLastPiecePrio `json:"firstLastPiecePrio,omitempty"`

	// Paused Add torrents in the paused state. Possible values are `true`, `false` (default)
	Paused *AddTorrentsURLsPaused `json:"paused,omitempty"`

	// RatioLimit Set torrent share ratio limit
	RatioLimit *float32 `json:"ratioLimit,omitempty"`

	// Rename Rename torrent
	Rename *string `json:"rename,omitempty"`

	// RootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
	RootFolder *AddTorrentsURLsRootFolder `json:"root_folder,omitempty"`

	// Savepath Download folder
	Savepath *string `json:"savepath,omitempty"`

	// SeedingTimeLimit Set torrent seeding time limit. Unit in seconds
	SeedingTimeLimit *int64 `json:"seedingTimeLimit,omitempty"`

	// SequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
	SequentialDownload *AddTorrentsURLsSequentialDownload `json:"sequentialDownload,omitempty"`

	// SkipChecking Skip hash checking. Possible values are `true`, `false` (default)
	SkipChecking *AddTorrentsURLsSkipChecking `json:"skip_checking,omitempty"`

	// Tags Tags for the torrent, split by ','
	Tags *[]string `json:"tags,omitempty"`

	// UpLimit Set torrent upload speed limit. Unit in bytes/second
	UpLimit *int64 `json:"upLimit,omitempty"`

	// Urls URLs separated with newlines
	Urls *string `json:"urls,omitempty"`
}

// AddTorrentsURLsFirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
type AddTorrentsURLsFirstLastPiecePrio string

// AddTorrentsURLsPaused Add torrents in the paused state. Possible values are `true`, `false` (default)
type AddTorrentsURLsPaused string

// AddTorrentsURLsRootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
type AddTorrentsURLsRootFolder string

// AddTorrentsURLsSequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
type AddTorrentsURLsSequentialDownload string

// AddTorrentsURLsSkipChecking Skip hash checking. Possible values are `true`, `false` (default)
type AddTorrentsURLsSkipChecking string

// AddTorrentsURLsAllOf defines model for AddTorrentsURLs_allOf.
type AddTorrentsURLsAllOf struct {
	// Urls URLs separated with newlines
	Urls *string `json:"urls,omitempty"`
}

// BuildInfo The response is a JSON object containing the following fields
type BuildInfo struct {
	Bitness    *int32  `json:"bitness,omitempty"`
	Boost      *string `json:"boost,omitempty"`
	Libtorrent *string `json:"libtorrent,omitempty"`
	Openssl    *string `json:"openssl,omitempty"`
	Qt         *string `json:"qt,omitempty"`
}

// Category defines model for Category.
type Category struct {
	Category string `json:"category"`
	SavePath string `json:"savePath"`
}

// Hashes defines model for Hashes.
type Hashes struct {
	Hashes []string `json:"hashes"`
}

// MainData The response is a JSON object with the following possible fields
type MainData struct {
	// Categories Info for categories added since last request
	Categories *map[string]TorrentsCategory `json:"categories,omitempty"`

	// CategoriesRemoved List of categories removed since last request
	CategoriesRemoved *[]string `json:"categories_removed,omitempty"`

	// FullUpdate Whether the response contains all the data or partial data
	FullUpdate *bool `json:"full_update,omitempty"`

	// Rid Response ID
	Rid *int64 `json:"rid,omitempty"`

	// ServerState The response is a JSON object with the following fields
	//
	// In addition to the above in partial data requests (see [Get partial data](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-partial-data) for more info):
	ServerState *TransferInfo `json:"server_state,omitempty"`

	// Tags List of tags added since last request
	Tags *[]string `json:"tags,omitempty"`

	// TagsRemoved List of tags removed since last request
	TagsRemoved *[]string `json:"tags_removed,omitempty"`

	// Torrents Property: torrent hash, value: same as [torrent list](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-torrent-list)
	Torrents *map[string]TorrentInfo `json:"torrents,omitempty"`

	// TorrentsRemoved List of hashes of torrents removed since last request
	TorrentsRemoved *[]string `json:"torrents_removed,omitempty"`
}

// MainLog defines model for MainLog.
type MainLog struct {
	// Id ID of the message
	Id *int64 `json:"id,omitempty"`

	// Message Text of the message
	Message *string `json:"message,omitempty"`

	// Timestamp Milliseconds since epoch
	Timestamp *int64 `json:"timestamp,omitempty"`

	// Type Type of the message: Log::NORMAL: `1`, Log::INFO: `2`, Log::WARNING: `4`, Log::CRITICAL: `8`
	Type *MainLogType `json:"type,omitempty"`
}

// MainLogType Type of the message: Log::NORMAL: `1`, Log::INFO: `2`, Log::WARNING: `4`, Log::CRITICAL: `8`
type MainLogType int32

// PeersLog defines model for PeersLog.
type PeersLog struct {
	// Blocked Whether or not the peer was blocked
	Blocked *bool `json:"blocked,omitempty"`

	// Id ID of the peer
	Id *int64 `json:"id,omitempty"`

	// Ip IP of the peer
	Ip *string `json:"ip,omitempty"`

	// Reason Reason of the block
	Reason *string `json:"reason,omitempty"`

	// Timestamp Milliseconds since epoch
	Timestamp *int64 `json:"timestamp,omitempty"`
}

// Preferences Possible fields:
type Preferences struct {
	// AddTrackers List of trackers to add to new torrent
	AddTrackers *string `json:"add_trackers,omitempty"`

	// AddTrackersEnabled Enable automatic adding of trackers to new torrents
	AddTrackersEnabled *bool `json:"add_trackers_enabled,omitempty"`

	// AltDlLimit Alternative global download speed limit in KiB/s
	AltDlLimit *int64 `json:"alt_dl_limit,omitempty"`

	// AltUpLimit Alternative global upload speed limit in KiB/s
	AltUpLimit *int64 `json:"alt_up_limit,omitempty"`

	// AlternativeWebuiEnabled True if an alternative WebUI should be used
	AlternativeWebuiEnabled *bool `json:"alternative_webui_enabled,omitempty"`

	// AlternativeWebuiPath File path to the alternative WebUI
	AlternativeWebuiPath *string `json:"alternative_webui_path,omitempty"`

	// AnnounceIp TODO
	AnnounceIp *string `json:"announce_ip,omitempty"`

	// AnnounceToAllTiers True always announce to all tiers
	AnnounceToAllTiers *bool `json:"announce_to_all_tiers,omitempty"`

	// AnnounceToAllTrackers True always announce to all trackers in a tier
	AnnounceToAllTrackers *bool `json:"announce_to_all_trackers,omitempty"`

	// AnonymousMode If true anonymous mode will be enabled; read more [here](https://github.com/qbittorrent/qBittorrent/wiki/Anonymous-Mode); this option is only available in qBittorent built against libtorrent version 0.16.X and higher
	AnonymousMode *bool `json:"anonymous_mode,omitempty"`

	// AsyncIoThreads Number of asynchronous I/O threads
	AsyncIoThreads *int64 `json:"async_io_threads,omitempty"`

	// AutoDeleteMode TODO
	AutoDeleteMode *int `json:"auto_delete_mode,omitempty"`

	// AutoTmmEnabled True if Automatic Torrent Management is enabled by default
	AutoTmmEnabled *bool `json:"auto_tmm_enabled,omitempty"`

	// AutorunEnabled True if external program should be run after torrent has finished downloading
	AutorunEnabled *bool `json:"autorun_enabled,omitempty"`

	// AutorunProgram Program path/name/arguments to run if `autorun_enabled` is enabled; path is separated by slashes; you can use `%f` and `%n` arguments, which will be expanded by qBittorent as path_to_torrent_file and torrent_name (from the GUI; not the .torrent file name) respectively
	AutorunProgram *string `json:"autorun_program,omitempty"`

	// BannedIPs List of banned IPs
	BannedIPs *string `json:"banned_IPs,omitempty"`

	// BittorrentProtocol Bittorrent Protocol to use (see list of possible values below)
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | 0     | TCP and μTP |
	// | 1     | TCP         |
	// | 2     | μTP         |
	BittorrentProtocol *PreferencesBittorrentProtocol `json:"bittorrent_protocol,omitempty"`

	// BypassAuthSubnetWhitelist (White)list of ipv4/ipv6 subnets for which webui authentication should be bypassed; list entries are separated by commas
	BypassAuthSubnetWhitelist *[]string `json:"bypass_auth_subnet_whitelist,omitempty"`

	// BypassAuthSubnetWhitelistEnabled True if webui authentication should be bypassed for clients whose ip resides within (at least) one of the subnets on the whitelist
	BypassAuthSubnetWhitelistEnabled *bool `json:"bypass_auth_subnet_whitelist_enabled,omitempty"`

	// BypassLocalAuth True if authentication challenge for loopback address (127.0.0.1) should be disabled
	BypassLocalAuth *bool `json:"bypass_local_auth,omitempty"`

	// CategoryChangedTmmEnabled True if torrent should be relocated when its Category's save path changes
	CategoryChangedTmmEnabled *bool `json:"category_changed_tmm_enabled,omitempty"`

	// CheckingMemoryUse Outstanding memory when checking torrents in MiB
	CheckingMemoryUse *int64 `json:"checking_memory_use,omitempty"`

	// CreateSubfolderEnabled True if a subfolder should be created when adding a torrent
	CreateSubfolderEnabled *bool `json:"create_subfolder_enabled,omitempty"`

	// CurrentInterfaceAddress IP Address to bind to. Empty String means All addresses
	CurrentInterfaceAddress *string `json:"current_interface_address,omitempty"`

	// CurrentNetworkInterface Network Interface used
	CurrentNetworkInterface *string `json:"current_network_interface,omitempty"`

	// Dht True if DHT is enabled
	Dht *bool `json:"dht,omitempty"`

	// DiskCache Disk cache used in MiB
	DiskCache *int64 `json:"disk_cache,omitempty"`

	// DiskCacheTtl Disk cache expiry interval in seconds
	DiskCacheTtl *int64 `json:"disk_cache_ttl,omitempty"`

	// DlLimit Global download speed limit in KiB/s; `-1` means no limit is applied
	DlLimit *int64 `json:"dl_limit,omitempty"`

	// DontCountSlowTorrents If true torrents w/o any activity (stalled ones) will not be counted towards `max_active_*` limits; see [dont_count_slow_torrents](https://www.libtorrent.org/reference-Settings.html#dont_count_slow_torrents) for more information
	DontCountSlowTorrents *bool `json:"dont_count_slow_torrents,omitempty"`

	// DyndnsDomain Your DDNS domain name
	DyndnsDomain *string `json:"dyndns_domain,omitempty"`

	// DyndnsEnabled True if server DNS should be updated dynamically
	DyndnsEnabled *bool `json:"dyndns_enabled,omitempty"`

	// DyndnsPassword Password for DDNS service
	DyndnsPassword *string `json:"dyndns_password,omitempty"`

	// DyndnsService See list of possible values here below
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | 0     | Use DyDNS   |
	// | 1     | Use NOIP    |
	DyndnsService *PreferencesDyndnsService `json:"dyndns_service,omitempty"`

	// DyndnsUsername Username for DDNS service
	DyndnsUsername *string `json:"dyndns_username,omitempty"`

	// EmbeddedTrackerPort Port used for embedded tracker
	EmbeddedTrackerPort *int32 `json:"embedded_tracker_port,omitempty"`

	// EnableCoalesceReadWrite True enables coalesce reads & writes
	EnableCoalesceReadWrite *bool `json:"enable_coalesce_read_write,omitempty"`

	// EnableEmbeddedTracker True enables embedded tracker
	EnableEmbeddedTracker *bool `json:"enable_embedded_tracker,omitempty"`

	// EnableMultiConnectionsFromSameIp True allows multiple connections from the same IP address
	EnableMultiConnectionsFromSameIp *bool `json:"enable_multi_connections_from_same_ip,omitempty"`

	// EnableOsCache True enables os cache
	EnableOsCache *bool `json:"enable_os_cache,omitempty"`

	// EnablePieceExtentAffinity True if the advanced libtorrent option `piece_extent_affinity` is enabled
	EnablePieceExtentAffinity *bool `json:"enable_piece_extent_affinity,omitempty"`

	// EnableUploadSuggestions True enables sending of upload piece suggestions
	EnableUploadSuggestions *bool `json:"enable_upload_suggestions,omitempty"`

	// Encryption See list of possible values here below
	//
	// | Value | Description          |
	// | ----- | -------------------- |
	// | 0     | Prefer encryption    |
	// | 1     | Force encryption on  |
	// | 2     | Force encryption off |
	Encryption *PreferencesEncryption `json:"encryption,omitempty"`

	// ExportDir Path to directory to copy .torrent files to. Slashes are used as path separators
	ExportDir *string `json:"export_dir,omitempty"`

	// ExportDirFin Path to directory to copy .torrent files of completed downloads to. Slashes are used as path separators
	ExportDirFin *string `json:"export_dir_fin,omitempty"`

	// FilePoolSize File pool size
	FilePoolSize *int64 `json:"file_pool_size,omitempty"`

	// IncompleteFilesExt True if ".!qB" should be appended to incomplete files
	IncompleteFilesExt *bool `json:"incomplete_files_ext,omitempty"`

	// IpFilterEnabled True if external IP filter should be enabled
	IpFilterEnabled *bool `json:"ip_filter_enabled,omitempty"`

	// IpFilterPath Path to IP filter file (.dat, .p2p, .p2b files are supported); path is separated by slashes
	IpFilterPath *string `json:"ip_filter_path,omitempty"`

	// IpFilterTrackers True if IP filters are applied to trackers
	IpFilterTrackers *bool `json:"ip_filter_trackers,omitempty"`

	// LimitLanPeers True if `[du]l_limit` should be applied to peers on the LAN
	LimitLanPeers *bool `json:"limit_lan_peers,omitempty"`

	// LimitTcpOverhead True if `[du]l_limit` should be applied to estimated TCP overhead (service data: e.g. packet headers)
	LimitTcpOverhead *bool `json:"limit_tcp_overhead,omitempty"`

	// LimitUtpRate True if `[du]l_limit` should be applied to uTP connections; this option is only available in qBittorent built against libtorrent version 0.16.X and higher
	LimitUtpRate *bool `json:"limit_utp_rate,omitempty"`

	// ListenPort Port for incoming connections
	ListenPort *int32 `json:"listen_port,omitempty"`

	// Locale Currently selected language (e.g. en_GB for English)
	Locale *string `json:"locale,omitempty"`

	// Lsd True if LSD is enabled
	Lsd *bool `json:"lsd,omitempty"`

	// MailNotificationAuthEnabled True if smtp server requires authentication
	MailNotificationAuthEnabled *bool `json:"mail_notification_auth_enabled,omitempty"`

	// MailNotificationEmail e-mail to send notifications to
	MailNotificationEmail *string `json:"mail_notification_email,omitempty"`

	// MailNotificationEnabled True if e-mail notification should be enabled
	MailNotificationEnabled *bool `json:"mail_notification_enabled,omitempty"`

	// MailNotificationPassword Password for smtp authentication
	MailNotificationPassword *string `json:"mail_notification_password,omitempty"`

	// MailNotificationSender e-mail where notifications should originate from
	MailNotificationSender *string `json:"mail_notification_sender,omitempty"`

	// MailNotificationSmtp smtp server for e-mail notifications
	MailNotificationSmtp *string `json:"mail_notification_smtp,omitempty"`

	// MailNotificationSslEnabled True if smtp server requires SSL connection
	MailNotificationSslEnabled *bool `json:"mail_notification_ssl_enabled,omitempty"`

	// MailNotificationUsername Username for smtp authentication
	MailNotificationUsername *string `json:"mail_notification_username,omitempty"`

	// MaxActiveDownloads Maximum number of active simultaneous downloads
	MaxActiveDownloads *int64 `json:"max_active_downloads,omitempty"`

	// MaxActiveTorrents Maximum number of active simultaneous downloads and uploads
	MaxActiveTorrents *int64 `json:"max_active_torrents,omitempty"`

	// MaxActiveUploads Maximum number of active simultaneous uploads
	MaxActiveUploads *int64 `json:"max_active_uploads,omitempty"`

	// MaxConnec Maximum global number of simultaneous connections
	MaxConnec *int64 `json:"max_connec,omitempty"`

	// MaxConnecPerTorrent Maximum number of simultaneous connections per torrent
	MaxConnecPerTorrent *int64 `json:"max_connec_per_torrent,omitempty"`

	// MaxRatio Get the global share ratio limit
	MaxRatio *float32 `json:"max_ratio,omitempty"`

	// MaxRatioAct Action performed when a torrent reaches the maximum share ratio. See list of possible values here below.
	//
	// | Value | Description    |
	// | ----- | -------------- |
	// | 0     | Pause torrent  |
	// | 1     | Remove torrent |
	MaxRatioAct *PreferencesMaxRatioAct `json:"max_ratio_act,omitempty"`

	// MaxRatioEnabled True if share ratio limit is enabled
	MaxRatioEnabled *bool `json:"max_ratio_enabled,omitempty"`

	// MaxSeedingTime Number of minutes to seed a torrent
	MaxSeedingTime *int64 `json:"max_seeding_time,omitempty"`

	// MaxSeedingTimeEnabled True enables max seeding time
	MaxSeedingTimeEnabled *bool `json:"max_seeding_time_enabled,omitempty"`

	// MaxUploads Maximum number of upload slots
	MaxUploads *int64 `json:"max_uploads,omitempty"`

	// MaxUploadsPerTorrent Maximum number of upload slots per torrent
	MaxUploadsPerTorrent *int64 `json:"max_uploads_per_torrent,omitempty"`

	// OutgoingPortsMax Maximal outgoing port (0: Disabled)
	OutgoingPortsMax *int32 `json:"outgoing_ports_max,omitempty"`

	// OutgoingPortsMin Minimal outgoing port (0: Disabled)
	OutgoingPortsMin *int32 `json:"outgoing_ports_min,omitempty"`

	// Pex True if PeX is enabled
	Pex *bool `json:"pex,omitempty"`

	// PreallocateAll True if disk space should be pre-allocated for all files
	PreallocateAll *bool `json:"preallocate_all,omitempty"`

	// ProxyAuthEnabled True proxy requires authentication; doesn't apply to SOCKS4 proxies
	ProxyAuthEnabled *bool `json:"proxy_auth_enabled,omitempty"`

	// ProxyIp Proxy IP address or domain name
	ProxyIp *string `json:"proxy_ip,omitempty"`

	// ProxyPassword Password for proxy authentication
	ProxyPassword *string `json:"proxy_password,omitempty"`

	// ProxyPeerConnections True if peer and web seed connections should be proxified; this option will have any effect only in qBittorent built against libtorrent version 0.16.X and higher
	ProxyPeerConnections *bool `json:"proxy_peer_connections,omitempty"`

	// ProxyPort Proxy port
	ProxyPort *int32 `json:"proxy_port,omitempty"`

	// ProxyTorrentsOnly True if proxy is only used for torrents
	ProxyTorrentsOnly *bool `json:"proxy_torrents_only,omitempty"`

	// ProxyType See list of possible values here below
	//
	// | Value | Description                         |
	// | ----- | ----------------------------------- |
	// | -1    | Proxy is disabled                   |
	// | 0     | Prefer encryption                   |
	// | 1     | HTTP proxy without authentication   |
	// | 2     | SOCKS5 proxy without authentication |
	// | 3     | HTTP proxy with authentication      |
	// | 4     | SOCKS5 proxy with authentication    |
	// | 5     | SOCKS4 proxy without authentication |
	ProxyType *PreferencesProxyType `json:"proxy_type,omitempty"`

	// ProxyUsername Username for proxy authentication
	ProxyUsername *string `json:"proxy_username,omitempty"`

	// QueueingEnabled True if torrent queuing is enabled
	QueueingEnabled *bool `json:"queueing_enabled,omitempty"`

	// RandomPort True if the port is randomly selected
	RandomPort *bool `json:"random_port,omitempty"`

	// RecheckCompletedTorrents True rechecks torrents on completion
	RecheckCompletedTorrents *bool `json:"recheck_completed_torrents,omitempty"`

	// ResolvePeerCountries True resolves peer countries
	ResolvePeerCountries *bool `json:"resolve_peer_countries,omitempty"`

	// RssAutoDownloadingEnabled Enable auto-downloading of torrents from the RSS feeds
	RssAutoDownloadingEnabled *bool `json:"rss_auto_downloading_enabled,omitempty"`

	// RssDownloadRepackProperEpisodes For API ≥ v2.5.1: Enable downloading of repack/proper Episodes
	RssDownloadRepackProperEpisodes *bool `json:"rss_download_repack_proper_episodes,omitempty"`

	// RssMaxArticlesPerFeed Max stored articles per RSS feed
	RssMaxArticlesPerFeed *int64 `json:"rss_max_articles_per_feed,omitempty"`

	// RssProcessingEnabled Enable processing of RSS feeds
	RssProcessingEnabled *bool `json:"rss_processing_enabled,omitempty"`

	// RssRefreshInterval RSS refresh interval
	RssRefreshInterval *int64 `json:"rss_refresh_interval,omitempty"`

	// RssSmartEpisodeFilters For API ≥ v2.5.1: List of RSS Smart Episode Filters
	RssSmartEpisodeFilters *string `json:"rss_smart_episode_filters,omitempty"`

	// SavePath Default save path for torrents, separated by slashes
	SavePath *string `json:"save_path,omitempty"`

	// SavePathChangedTmmEnabled True if torrent should be relocated when the default save path changes
	SavePathChangedTmmEnabled *bool `json:"save_path_changed_tmm_enabled,omitempty"`

	// SaveResumeDataInterval Save resume data interval in min
	SaveResumeDataInterval *int64 `json:"save_resume_data_interval,omitempty"`

	// ScanDirs Property: directory to watch for torrent files, value: where torrents loaded from this directory should be downloaded to (see list of possible values below). Slashes are used as path separators; multiple key/value pairs can be specified
	//
	// | Value                  | Description                       |
	// | ---------------------- | --------------------------------- |
	// | 0                      | Download to the monitored folder  |
	// | 1                      | Download to the default save path |
	// | "/path/to/download/to" | Download to this path             |
	ScanDirs *map[string]PreferencesScanDirsValue `json:"scan_dirs,omitempty"`

	// ScheduleFromHour Scheduler starting hour
	ScheduleFromHour *int32 `json:"schedule_from_hour,omitempty"`

	// ScheduleFromMin Scheduler starting minute
	ScheduleFromMin *int32 `json:"schedule_from_min,omitempty"`

	// ScheduleToHour Scheduler ending hour
	ScheduleToHour *int32 `json:"schedule_to_hour,omitempty"`

	// ScheduleToMin Scheduler ending minute
	ScheduleToMin *int32 `json:"schedule_to_min,omitempty"`

	// SchedulerDays Scheduler days. See possible values here below
	//
	// | Value | Description     |
	// | ----- | --------------- |
	// | 0     | Every day       |
	// | 1     | Every weekday   |
	// | 2     | Every weekend   |
	// | 3     | Every Monday    |
	// | 4     | Every Tuesday   |
	// | 5     | Every Wednesday |
	// | 6     | Every Thursday  |
	// | 7     | Every Friday    |
	// | 8     | Every Saturday  |
	// | 9     | Every Sunday    |
	SchedulerDays *PreferencesSchedulerDays `json:"scheduler_days,omitempty"`

	// SchedulerEnabled True if alternative limits should be applied according to schedule
	SchedulerEnabled *bool `json:"scheduler_enabled,omitempty"`

	// SendBufferLowWatermark Send buffer low watermark in KiB
	SendBufferLowWatermark *int64 `json:"send_buffer_low_watermark,omitempty"`

	// SendBufferWatermark Send buffer watermark in KiB
	SendBufferWatermark *int64 `json:"send_buffer_watermark,omitempty"`

	// SendBufferWatermarkFactor Send buffer watermark factor in percent
	SendBufferWatermarkFactor *int32 `json:"send_buffer_watermark_factor,omitempty"`

	// SlowTorrentDlRateThreshold Download rate in KiB/s for a torrent to be considered "slow"
	SlowTorrentDlRateThreshold *int64 `json:"slow_torrent_dl_rate_threshold,omitempty"`

	// SlowTorrentInactiveTimer Seconds a torrent should be inactive before considered "slow"
	SlowTorrentInactiveTimer *int64 `json:"slow_torrent_inactive_timer,omitempty"`

	// SlowTorrentUlRateThreshold Upload rate in KiB/s for a torrent to be considered "slow"
	SlowTorrentUlRateThreshold *int64 `json:"slow_torrent_ul_rate_threshold,omitempty"`

	// SocketBacklogSize Socket backlog size
	SocketBacklogSize *int64 `json:"socket_backlog_size,omitempty"`

	// SslCert For API < v2.0.1: SSL certificate contents (this is a not a path)
	SslCert *string `json:"ssl_cert,omitempty"`

	// SslKey For API < v2.0.1: SSL keyfile contents (this is a not a path)
	SslKey *string `json:"ssl_key,omitempty"`

	// StartPausedEnabled True if torrents should be added in a Paused state
	StartPausedEnabled *bool `json:"start_paused_enabled,omitempty"`

	// StopTrackerTimeout Timeout in seconds for a `stopped` announce request to trackers
	StopTrackerTimeout *int64 `json:"stop_tracker_timeout,omitempty"`

	// TempPath Path for incomplete torrents, separated by slashes
	TempPath *string `json:"temp_path,omitempty"`

	// TempPathEnabled True if folder for incomplete torrents is enabled
	TempPathEnabled *bool `json:"temp_path_enabled,omitempty"`

	// TorrentChangedTmmEnabled True if torrent should be relocated when its Category changes
	TorrentChangedTmmEnabled *bool `json:"torrent_changed_tmm_enabled,omitempty"`

	// UpLimit Global upload speed limit in KiB/s; `-1` means no limit is applied
	UpLimit *int64 `json:"up_limit,omitempty"`

	// UploadChokingAlgorithm Upload choking algorithm used (see list of possible values below)
	//
	// | Value | Description    |
	// | ----- | -------------- |
	// | 0     | Round-robin    |
	// | 1     | Fastest upload |
	// | 2     | Anti-leech     |
	UploadChokingAlgorithm *PreferencesUploadChokingAlgorithm `json:"upload_choking_algorithm,omitempty"`

	// UploadSlotsBehavior Upload slots behavior used (see list of possible values below)
	//
	// | Value | Description       |
	// | ----- | ----------------- |
	// | 0     | Fixed slots       |
	// | 1     | Upload rate based |
	UploadSlotsBehavior *PreferencesUploadSlotsBehavior `json:"upload_slots_behavior,omitempty"`

	// Upnp True if UPnP/NAT-PMP is enabled
	Upnp *bool `json:"upnp,omitempty"`

	// UpnpLeaseDuration UPnP lease duration (0: Permanent lease)
	UpnpLeaseDuration *int64 `json:"upnp_lease_duration,omitempty"`

	// UseHttps True if WebUI HTTPS access is enabled
	UseHttps *bool `json:"use_https,omitempty"`

	// UtpTcpMixedMode μTP-TCP mixed mode algorithm (see list of possible values below)
	//
	// | Value | Description       |
	// | ----- | ----------------- |
	// | 0     | Prefer TCP        |
	// | 1     | Peer proportional |
	UtpTcpMixedMode *PreferencesUtpTcpMixedMode `json:"utp_tcp_mixed_mode,omitempty"`

	// WebUiAddress IP address to use for the WebUI
	WebUiAddress *string `json:"web_ui_address,omitempty"`

	// WebUiBanDuration WebUI access ban duration in seconds
	WebUiBanDuration *int64 `json:"web_ui_ban_duration,omitempty"`

	// WebUiClickjackingProtectionEnabled True if WebUI clickjacking protection is enabled
	WebUiClickjackingProtectionEnabled *bool `json:"web_ui_clickjacking_protection_enabled,omitempty"`

	// WebUiCsrfProtectionEnabled True if WebUI CSRF protection is enabled
	WebUiCsrfProtectionEnabled *bool `json:"web_ui_csrf_protection_enabled,omitempty"`

	// WebUiCustomHttpHeaders For API ≥ v2.5.1: List of custom http headers
	WebUiCustomHttpHeaders *string `json:"web_ui_custom_http_headers,omitempty"`

	// WebUiDomainList Comma-separated list of domains to accept when performing Host header validation
	WebUiDomainList *[]string `json:"web_ui_domain_list,omitempty"`

	// WebUiHostHeaderValidationEnabled True if WebUI host header validation is enabled
	WebUiHostHeaderValidationEnabled *bool `json:"web_ui_host_header_validation_enabled,omitempty"`

	// WebUiHttpsCertPath For API ≥ v2.0.1: Path to SSL certificate
	WebUiHttpsCertPath *string `json:"web_ui_https_cert_path,omitempty"`

	// WebUiHttpsKeyPath For API ≥ v2.0.1: Path to SSL keyfile
	WebUiHttpsKeyPath *string `json:"web_ui_https_key_path,omitempty"`

	// WebUiMaxAuthFailCount Maximum number of authentication failures before WebUI access ban
	WebUiMaxAuthFailCount *int64 `json:"web_ui_max_auth_fail_count,omitempty"`

	// WebUiPort WebUI port
	WebUiPort *int32 `json:"web_ui_port,omitempty"`

	// WebUiSecureCookieEnabled True if WebUI cookie `Secure` flag is enabled
	WebUiSecureCookieEnabled *bool `json:"web_ui_secure_cookie_enabled,omitempty"`

	// WebUiSessionTimeout Seconds until WebUI is automatically signed off
	WebUiSessionTimeout *int64 `json:"web_ui_session_timeout,omitempty"`

	// WebUiUpnp True if UPnP is used for the WebUI port
	WebUiUpnp *bool `json:"web_ui_upnp,omitempty"`

	// WebUiUseCustomHttpHeadersEnabled For API ≥ v2.5.1: Enable custom http headers
	WebUiUseCustomHttpHeadersEnabled *bool `json:"web_ui_use_custom_http_headers_enabled,omitempty"`

	// WebUiUsername WebUI username
	WebUiUsername        *string                `json:"web_ui_username,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PreferencesBittorrentProtocol Bittorrent Protocol to use (see list of possible values below)
//
// | Value | Description |
// | ----- | ----------- |
// | 0     | TCP and μTP |
// | 1     | TCP         |
// | 2     | μTP         |
type PreferencesBittorrentProtocol int32

// PreferencesDyndnsService See list of possible values here below
//
// | Value | Description |
// | ----- | ----------- |
// | 0     | Use DyDNS   |
// | 1     | Use NOIP    |
type PreferencesDyndnsService int32

// PreferencesEncryption See list of possible values here below
//
// | Value | Description          |
// | ----- | -------------------- |
// | 0     | Prefer encryption    |
// | 1     | Force encryption on  |
// | 2     | Force encryption off |
type PreferencesEncryption int32

// PreferencesMaxRatioAct Action performed when a torrent reaches the maximum share ratio. See list of possible values here below.
//
// | Value | Description    |
// | ----- | -------------- |
// | 0     | Pause torrent  |
// | 1     | Remove torrent |
type PreferencesMaxRatioAct int64

// PreferencesProxyType See list of possible values here below
//
// | Value | Description                         |
// | ----- | ----------------------------------- |
// | -1    | Proxy is disabled                   |
// | 0     | Prefer encryption                   |
// | 1     | HTTP proxy without authentication   |
// | 2     | SOCKS5 proxy without authentication |
// | 3     | HTTP proxy with authentication      |
// | 4     | SOCKS5 proxy with authentication    |
// | 5     | SOCKS4 proxy without authentication |
type PreferencesProxyType int32

// PreferencesSchedulerDays Scheduler days. See possible values here below
//
// | Value | Description     |
// | ----- | --------------- |
// | 0     | Every day       |
// | 1     | Every weekday   |
// | 2     | Every weekend   |
// | 3     | Every Monday    |
// | 4     | Every Tuesday   |
// | 5     | Every Wednesday |
// | 6     | Every Thursday  |
// | 7     | Every Friday    |
// | 8     | Every Saturday  |
// | 9     | Every Sunday    |
type PreferencesSchedulerDays int32

// PreferencesUploadChokingAlgorithm Upload choking algorithm used (see list of possible values below)
//
// | Value | Description    |
// | ----- | -------------- |
// | 0     | Round-robin    |
// | 1     | Fastest upload |
// | 2     | Anti-leech     |
type PreferencesUploadChokingAlgorithm int32

// PreferencesUploadSlotsBehavior Upload slots behavior used (see list of possible values below)
//
// | Value | Description       |
// | ----- | ----------------- |
// | 0     | Fixed slots       |
// | 1     | Upload rate based |
type PreferencesUploadSlotsBehavior int32

// PreferencesUtpTcpMixedMode μTP-TCP mixed mode algorithm (see list of possible values below)
//
// | Value | Description       |
// | ----- | ----------------- |
// | 0     | Prefer TCP        |
// | 1     | Peer proportional |
type PreferencesUtpTcpMixedMode int32

// PreferencesScanDirsValue defines model for Preferences_scan_dirs_value.
type PreferencesScanDirsValue struct {
	union json.RawMessage
}

// PreferencesScanDirsValue0 defines model for .
type PreferencesScanDirsValue0 int

// PreferencesScanDirsValue1 defines model for .
type PreferencesScanDirsValue1 = string

// RenameTorrentFiles defines model for RenameTorrentFiles.
type RenameTorrentFiles struct {
	// Hash The hash of the torrent
	Hash string `json:"hash"`

	// NewPath The new path to use for the file
	NewPath string `json:"newPath"`

	// OldPath The old path of the torrent
	OldPath string `json:"oldPath"`
}

// RssRuleDef JSON encoded rule definition
//
// Rule definition is JSON encoded dictionary with the following fields:
// | Field                     | Type   | Description                                             |
// | ------------------------- | ------ | ------------------------------------------------------- |
// | enabled                   | bool   | Whether the rule is enabled                             |
// | mustContain               | string | The substring that the torrent name must contain        |
// | mustNotContain            | string | The substring that the torrent name must not contain    |
// | useRegex                  | bool   | Enable regex mode in "mustContain" and "mustNotContain" |
// | episodeFilter             | string | Episode filter definition                               |
// | smartFilter               | bool   | Enable smart episode filter                             |
// | previouslyMatchedEpisodes | list   | The list of episode IDs already matched by smart filter |
// | affectedFeeds             | list   | The feed URLs the rule applied to                       |
// | ignoreDays                | number | Ignore sunsequent rule matches                          |
// | lastMatch                 | string | The rule last match time                                |
// | addPaused                 | bool   | Add matched torrent in paused mode                      |
// | assignedCategory          | string | Assign category to the torrent                          |
// | savePath                  | string | Save torrent to the given directory                     |
type RssRuleDef struct {
	// AddPaused Add matched torrent in paused mode
	AddPaused *bool `json:"addPaused,omitempty"`

	// AffectedFeeds The feed URLs the rule applied to
	AffectedFeeds *[]string `json:"affectedFeeds,omitempty"`

	// AssignedCategory Assign category to the torrent
	AssignedCategory *string `json:"assignedCategory,omitempty"`

	// Enabled Whether the rule is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// EpisodeFilter Episode filter definition
	EpisodeFilter *string `json:"episodeFilter,omitempty"`

	// IgnoreDays Ignore sunsequent rule matches
	IgnoreDays *float32 `json:"ignoreDays,omitempty"`

	// LastMatch The rule last match time
	LastMatch *string `json:"lastMatch,omitempty"`

	// MustContain The substring that the torrent name must contain
	MustContain *string `json:"mustContain,omitempty"`

	// MustNotContain The substring that the torrent name must not contain
	MustNotContain *string `json:"mustNotContain,omitempty"`

	// PreviouslyMatchedEpisodes The list of episode IDs already matched by smart filter
	PreviouslyMatchedEpisodes *[]int64 `json:"previouslyMatchedEpisodes,omitempty"`

	// SavePath Save torrent to the given directory
	SavePath *string `json:"savePath,omitempty"`

	// SmartFilter Enable smart episode filter
	SmartFilter *bool `json:"smartFilter,omitempty"`

	// UseRegex Enable regex mode in "mustContain" and "mustNotContain"
	UseRegex *bool `json:"useRegex,omitempty"`
}

// SearchJob The response is a JSON object with the following fields
type SearchJob struct {
	// Id ID of the search job
	Id *float32 `json:"id,omitempty"`
}

// SearchJobStatus defines model for SearchJobStatus.
type SearchJobStatus struct {
	// Id ID of the search job
	Id *float32 `json:"id,omitempty"`

	// Status Current status of the search job (either `Running` or `Stopped`)
	Status *SearchJobStatusStatus `json:"status,omitempty"`

	// Total Total number of results. If the status is `Running` this number may contineu to increase
	Total *float32 `json:"total,omitempty"`
}

// SearchJobStatusStatus Current status of the search job (either `Running` or `Stopped`)
type SearchJobStatusStatus string

// SearchJobStatusAllOf defines model for SearchJobStatus_allOf.
type SearchJobStatusAllOf struct {
	// Status Current status of the search job (either `Running` or `Stopped`)
	Status *SearchJobStatusAllOfStatus `json:"status,omitempty"`

	// Total Total number of results. If the status is `Running` this number may contineu to increase
	Total *float32 `json:"total,omitempty"`
}

// SearchJobStatusAllOfStatus Current status of the search job (either `Running` or `Stopped`)
type SearchJobStatusAllOfStatus string

// SearchPlugin defines model for SearchPlugin.
type SearchPlugin struct {
	// Enabled Whether the plugin is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// FullName Full name of the plugin
	FullName *string `json:"fullName,omitempty"`

	// Name Short name of the plugin
	Name *string `json:"name,omitempty"`

	// SupportedCategories List of category objects
	SupportedCategories *[]SearchPluginSupportedCategoriesInner `json:"supportedCategories,omitempty"`

	// Url URL of the torrent site
	Url *string `json:"url,omitempty"`

	// Version Installed version of the plugin
	Version *string `json:"version,omitempty"`
}

// SearchPluginSupportedCategoriesInner defines model for SearchPlugin_supportedCategories_inner.
type SearchPluginSupportedCategoriesInner struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	// DescrLink URL of the torrent's description page
	DescrLink *string `json:"descrLink,omitempty"`

	// FileName Name of the file
	FileName *string `json:"fileName,omitempty"`

	// FileSize Size of the file in Bytes
	FileSize *float32 `json:"fileSize,omitempty"`

	// FileUrl Torrent download link (usually either .torrent file or magnet link)
	FileUrl *string `json:"fileUrl,omitempty"`

	// NbLeechers Number of leechers
	NbLeechers *float32 `json:"nbLeechers,omitempty"`

	// NbSeeders Number of seeders
	NbSeeders *float32 `json:"nbSeeders,omitempty"`

	// SiteUrl URL of the torrent site
	SiteUrl *string `json:"siteUrl,omitempty"`
}

// SearchResults defines model for SearchResults.
type SearchResults struct {
	Results *[]SearchResult `json:"results,omitempty"`

	// Status Current status of the search job (either `Running` or `Stopped`)
	Status *SearchResultsStatus `json:"status,omitempty"`

	// Total Total number of results. If the status is `Running` this number may continue to increase
	Total *float32 `json:"total,omitempty"`
}

// SearchResultsStatus Current status of the search job (either `Running` or `Stopped`)
type SearchResultsStatus string

// SetPreferences defines model for SetPreferences.
type SetPreferences struct {
	// AddTrackers List of trackers to add to new torrent
	AddTrackers *string `json:"add_trackers,omitempty"`

	// AddTrackersEnabled Enable automatic adding of trackers to new torrents
	AddTrackersEnabled *bool `json:"add_trackers_enabled,omitempty"`

	// AltDlLimit Alternative global download speed limit in KiB/s
	AltDlLimit *int64 `json:"alt_dl_limit,omitempty"`

	// AltUpLimit Alternative global upload speed limit in KiB/s
	AltUpLimit *int64 `json:"alt_up_limit,omitempty"`

	// AlternativeWebuiEnabled True if an alternative WebUI should be used
	AlternativeWebuiEnabled *bool `json:"alternative_webui_enabled,omitempty"`

	// AlternativeWebuiPath File path to the alternative WebUI
	AlternativeWebuiPath *string `json:"alternative_webui_path,omitempty"`

	// AnnounceIp TODO
	AnnounceIp *string `json:"announce_ip,omitempty"`

	// AnnounceToAllTiers True always announce to all tiers
	AnnounceToAllTiers *bool `json:"announce_to_all_tiers,omitempty"`

	// AnnounceToAllTrackers True always announce to all trackers in a tier
	AnnounceToAllTrackers *bool `json:"announce_to_all_trackers,omitempty"`

	// AnonymousMode If true anonymous mode will be enabled; read more [here](https://github.com/qbittorrent/qBittorrent/wiki/Anonymous-Mode); this option is only available in qBittorent built against libtorrent version 0.16.X and higher
	AnonymousMode *bool `json:"anonymous_mode,omitempty"`

	// AsyncIoThreads Number of asynchronous I/O threads
	AsyncIoThreads *int64 `json:"async_io_threads,omitempty"`

	// AutoDeleteMode TODO
	AutoDeleteMode *int `json:"auto_delete_mode,omitempty"`

	// AutoTmmEnabled True if Automatic Torrent Management is enabled by default
	AutoTmmEnabled *bool `json:"auto_tmm_enabled,omitempty"`

	// AutorunEnabled True if external program should be run after torrent has finished downloading
	AutorunEnabled *bool `json:"autorun_enabled,omitempty"`

	// AutorunProgram Program path/name/arguments to run if `autorun_enabled` is enabled; path is separated by slashes; you can use `%f` and `%n` arguments, which will be expanded by qBittorent as path_to_torrent_file and torrent_name (from the GUI; not the .torrent file name) respectively
	AutorunProgram *string `json:"autorun_program,omitempty"`

	// BannedIPs List of banned IPs
	BannedIPs *string `json:"banned_IPs,omitempty"`

	// BittorrentProtocol Bittorrent Protocol to use (see list of possible values below)
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | 0     | TCP and μTP |
	// | 1     | TCP         |
	// | 2     | μTP         |
	BittorrentProtocol *SetPreferencesBittorrentProtocol `json:"bittorrent_protocol,omitempty"`

	// BypassAuthSubnetWhitelist (White)list of ipv4/ipv6 subnets for which webui authentication should be bypassed; list entries are separated by commas
	BypassAuthSubnetWhitelist *[]string `json:"bypass_auth_subnet_whitelist,omitempty"`

	// BypassAuthSubnetWhitelistEnabled True if webui authentication should be bypassed for clients whose ip resides within (at least) one of the subnets on the whitelist
	BypassAuthSubnetWhitelistEnabled *bool `json:"bypass_auth_subnet_whitelist_enabled,omitempty"`

	// BypassLocalAuth True if authentication challenge for loopback address (127.0.0.1) should be disabled
	BypassLocalAuth *bool `json:"bypass_local_auth,omitempty"`

	// CategoryChangedTmmEnabled True if torrent should be relocated when its Category's save path changes
	CategoryChangedTmmEnabled *bool `json:"category_changed_tmm_enabled,omitempty"`

	// CheckingMemoryUse Outstanding memory when checking torrents in MiB
	CheckingMemoryUse *int64 `json:"checking_memory_use,omitempty"`

	// CreateSubfolderEnabled True if a subfolder should be created when adding a torrent
	CreateSubfolderEnabled *bool `json:"create_subfolder_enabled,omitempty"`

	// CurrentInterfaceAddress IP Address to bind to. Empty String means All addresses
	CurrentInterfaceAddress *string `json:"current_interface_address,omitempty"`

	// CurrentNetworkInterface Network Interface used
	CurrentNetworkInterface *string `json:"current_network_interface,omitempty"`

	// Dht True if DHT is enabled
	Dht *bool `json:"dht,omitempty"`

	// DiskCache Disk cache used in MiB
	DiskCache *int64 `json:"disk_cache,omitempty"`

	// DiskCacheTtl Disk cache expiry interval in seconds
	DiskCacheTtl *int64 `json:"disk_cache_ttl,omitempty"`

	// DlLimit Global download speed limit in KiB/s; `-1` means no limit is applied
	DlLimit *int64 `json:"dl_limit,omitempty"`

	// DontCountSlowTorrents If true torrents w/o any activity (stalled ones) will not be counted towards `max_active_*` limits; see [dont_count_slow_torrents](https://www.libtorrent.org/reference-Settings.html#dont_count_slow_torrents) for more information
	DontCountSlowTorrents *bool `json:"dont_count_slow_torrents,omitempty"`

	// DyndnsDomain Your DDNS domain name
	DyndnsDomain *string `json:"dyndns_domain,omitempty"`

	// DyndnsEnabled True if server DNS should be updated dynamically
	DyndnsEnabled *bool `json:"dyndns_enabled,omitempty"`

	// DyndnsPassword Password for DDNS service
	DyndnsPassword *string `json:"dyndns_password,omitempty"`

	// DyndnsService See list of possible values here below
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | 0     | Use DyDNS   |
	// | 1     | Use NOIP    |
	DyndnsService *SetPreferencesDyndnsService `json:"dyndns_service,omitempty"`

	// DyndnsUsername Username for DDNS service
	DyndnsUsername *string `json:"dyndns_username,omitempty"`

	// EmbeddedTrackerPort Port used for embedded tracker
	EmbeddedTrackerPort *int32 `json:"embedded_tracker_port,omitempty"`

	// EnableCoalesceReadWrite True enables coalesce reads & writes
	EnableCoalesceReadWrite *bool `json:"enable_coalesce_read_write,omitempty"`

	// EnableEmbeddedTracker True enables embedded tracker
	EnableEmbeddedTracker *bool `json:"enable_embedded_tracker,omitempty"`

	// EnableMultiConnectionsFromSameIp True allows multiple connections from the same IP address
	EnableMultiConnectionsFromSameIp *bool `json:"enable_multi_connections_from_same_ip,omitempty"`

	// EnableOsCache True enables os cache
	EnableOsCache *bool `json:"enable_os_cache,omitempty"`

	// EnablePieceExtentAffinity True if the advanced libtorrent option `piece_extent_affinity` is enabled
	EnablePieceExtentAffinity *bool `json:"enable_piece_extent_affinity,omitempty"`

	// EnableUploadSuggestions True enables sending of upload piece suggestions
	EnableUploadSuggestions *bool `json:"enable_upload_suggestions,omitempty"`

	// Encryption See list of possible values here below
	//
	// | Value | Description          |
	// | ----- | -------------------- |
	// | 0     | Prefer encryption    |
	// | 1     | Force encryption on  |
	// | 2     | Force encryption off |
	Encryption *SetPreferencesEncryption `json:"encryption,omitempty"`

	// ExportDir Path to directory to copy .torrent files to. Slashes are used as path separators
	ExportDir *string `json:"export_dir,omitempty"`

	// ExportDirFin Path to directory to copy .torrent files of completed downloads to. Slashes are used as path separators
	ExportDirFin *string `json:"export_dir_fin,omitempty"`

	// FilePoolSize File pool size
	FilePoolSize *int64 `json:"file_pool_size,omitempty"`

	// IncompleteFilesExt True if ".!qB" should be appended to incomplete files
	IncompleteFilesExt *bool `json:"incomplete_files_ext,omitempty"`

	// IpFilterEnabled True if external IP filter should be enabled
	IpFilterEnabled *bool `json:"ip_filter_enabled,omitempty"`

	// IpFilterPath Path to IP filter file (.dat, .p2p, .p2b files are supported); path is separated by slashes
	IpFilterPath *string `json:"ip_filter_path,omitempty"`

	// IpFilterTrackers True if IP filters are applied to trackers
	IpFilterTrackers *bool `json:"ip_filter_trackers,omitempty"`

	// LimitLanPeers True if `[du]l_limit` should be applied to peers on the LAN
	LimitLanPeers *bool `json:"limit_lan_peers,omitempty"`

	// LimitTcpOverhead True if `[du]l_limit` should be applied to estimated TCP overhead (service data: e.g. packet headers)
	LimitTcpOverhead *bool `json:"limit_tcp_overhead,omitempty"`

	// LimitUtpRate True if `[du]l_limit` should be applied to uTP connections; this option is only available in qBittorent built against libtorrent version 0.16.X and higher
	LimitUtpRate *bool `json:"limit_utp_rate,omitempty"`

	// ListenPort Port for incoming connections
	ListenPort *int32 `json:"listen_port,omitempty"`

	// Locale Currently selected language (e.g. en_GB for English)
	Locale *string `json:"locale,omitempty"`

	// Lsd True if LSD is enabled
	Lsd *bool `json:"lsd,omitempty"`

	// MailNotificationAuthEnabled True if smtp server requires authentication
	MailNotificationAuthEnabled *bool `json:"mail_notification_auth_enabled,omitempty"`

	// MailNotificationEmail e-mail to send notifications to
	MailNotificationEmail *string `json:"mail_notification_email,omitempty"`

	// MailNotificationEnabled True if e-mail notification should be enabled
	MailNotificationEnabled *bool `json:"mail_notification_enabled,omitempty"`

	// MailNotificationPassword Password for smtp authentication
	MailNotificationPassword *string `json:"mail_notification_password,omitempty"`

	// MailNotificationSender e-mail where notifications should originate from
	MailNotificationSender *string `json:"mail_notification_sender,omitempty"`

	// MailNotificationSmtp smtp server for e-mail notifications
	MailNotificationSmtp *string `json:"mail_notification_smtp,omitempty"`

	// MailNotificationSslEnabled True if smtp server requires SSL connection
	MailNotificationSslEnabled *bool `json:"mail_notification_ssl_enabled,omitempty"`

	// MailNotificationUsername Username for smtp authentication
	MailNotificationUsername *string `json:"mail_notification_username,omitempty"`

	// MaxActiveDownloads Maximum number of active simultaneous downloads
	MaxActiveDownloads *int64 `json:"max_active_downloads,omitempty"`

	// MaxActiveTorrents Maximum number of active simultaneous downloads and uploads
	MaxActiveTorrents *int64 `json:"max_active_torrents,omitempty"`

	// MaxActiveUploads Maximum number of active simultaneous uploads
	MaxActiveUploads *int64 `json:"max_active_uploads,omitempty"`

	// MaxConnec Maximum global number of simultaneous connections
	MaxConnec *int64 `json:"max_connec,omitempty"`

	// MaxConnecPerTorrent Maximum number of simultaneous connections per torrent
	MaxConnecPerTorrent *int64 `json:"max_connec_per_torrent,omitempty"`

	// MaxRatio Get the global share ratio limit
	MaxRatio *float32 `json:"max_ratio,omitempty"`

	// MaxRatioAct Action performed when a torrent reaches the maximum share ratio. See list of possible values here below.
	//
	// | Value | Description    |
	// | ----- | -------------- |
	// | 0     | Pause torrent  |
	// | 1     | Remove torrent |
	MaxRatioAct *SetPreferencesMaxRatioAct `json:"max_ratio_act,omitempty"`

	// MaxRatioEnabled True if share ratio limit is enabled
	MaxRatioEnabled *bool `json:"max_ratio_enabled,omitempty"`

	// MaxSeedingTime Number of minutes to seed a torrent
	MaxSeedingTime *int64 `json:"max_seeding_time,omitempty"`

	// MaxSeedingTimeEnabled True enables max seeding time
	MaxSeedingTimeEnabled *bool `json:"max_seeding_time_enabled,omitempty"`

	// MaxUploads Maximum number of upload slots
	MaxUploads *int64 `json:"max_uploads,omitempty"`

	// MaxUploadsPerTorrent Maximum number of upload slots per torrent
	MaxUploadsPerTorrent *int64 `json:"max_uploads_per_torrent,omitempty"`

	// OutgoingPortsMax Maximal outgoing port (0: Disabled)
	OutgoingPortsMax *int32 `json:"outgoing_ports_max,omitempty"`

	// OutgoingPortsMin Minimal outgoing port (0: Disabled)
	OutgoingPortsMin *int32 `json:"outgoing_ports_min,omitempty"`

	// Pex True if PeX is enabled
	Pex *bool `json:"pex,omitempty"`

	// PreallocateAll True if disk space should be pre-allocated for all files
	PreallocateAll *bool `json:"preallocate_all,omitempty"`

	// ProxyAuthEnabled True proxy requires authentication; doesn't apply to SOCKS4 proxies
	ProxyAuthEnabled *bool `json:"proxy_auth_enabled,omitempty"`

	// ProxyIp Proxy IP address or domain name
	ProxyIp *string `json:"proxy_ip,omitempty"`

	// ProxyPassword Password for proxy authentication
	ProxyPassword *string `json:"proxy_password,omitempty"`

	// ProxyPeerConnections True if peer and web seed connections should be proxified; this option will have any effect only in qBittorent built against libtorrent version 0.16.X and higher
	ProxyPeerConnections *bool `json:"proxy_peer_connections,omitempty"`

	// ProxyPort Proxy port
	ProxyPort *int32 `json:"proxy_port,omitempty"`

	// ProxyTorrentsOnly True if proxy is only used for torrents
	ProxyTorrentsOnly *bool `json:"proxy_torrents_only,omitempty"`

	// ProxyType See list of possible values here below
	//
	// | Value | Description                         |
	// | ----- | ----------------------------------- |
	// | -1    | Proxy is disabled                   |
	// | 0     | Prefer encryption                   |
	// | 1     | HTTP proxy without authentication   |
	// | 2     | SOCKS5 proxy without authentication |
	// | 3     | HTTP proxy with authentication      |
	// | 4     | SOCKS5 proxy with authentication    |
	// | 5     | SOCKS4 proxy without authentication |
	ProxyType *SetPreferencesProxyType `json:"proxy_type,omitempty"`

	// ProxyUsername Username for proxy authentication
	ProxyUsername *string `json:"proxy_username,omitempty"`

	// QueueingEnabled True if torrent queuing is enabled
	QueueingEnabled *bool `json:"queueing_enabled,omitempty"`

	// RandomPort True if the port is randomly selected
	RandomPort *bool `json:"random_port,omitempty"`

	// RecheckCompletedTorrents True rechecks torrents on completion
	RecheckCompletedTorrents *bool `json:"recheck_completed_torrents,omitempty"`

	// ResolvePeerCountries True resolves peer countries
	ResolvePeerCountries *bool `json:"resolve_peer_countries,omitempty"`

	// RssAutoDownloadingEnabled Enable auto-downloading of torrents from the RSS feeds
	RssAutoDownloadingEnabled *bool `json:"rss_auto_downloading_enabled,omitempty"`

	// RssDownloadRepackProperEpisodes For API ≥ v2.5.1: Enable downloading of repack/proper Episodes
	RssDownloadRepackProperEpisodes *bool `json:"rss_download_repack_proper_episodes,omitempty"`

	// RssMaxArticlesPerFeed Max stored articles per RSS feed
	RssMaxArticlesPerFeed *int64 `json:"rss_max_articles_per_feed,omitempty"`

	// RssProcessingEnabled Enable processing of RSS feeds
	RssProcessingEnabled *bool `json:"rss_processing_enabled,omitempty"`

	// RssRefreshInterval RSS refresh interval
	RssRefreshInterval *int64 `json:"rss_refresh_interval,omitempty"`

	// RssSmartEpisodeFilters For API ≥ v2.5.1: List of RSS Smart Episode Filters
	RssSmartEpisodeFilters *string `json:"rss_smart_episode_filters,omitempty"`

	// SavePath Default save path for torrents, separated by slashes
	SavePath *string `json:"save_path,omitempty"`

	// SavePathChangedTmmEnabled True if torrent should be relocated when the default save path changes
	SavePathChangedTmmEnabled *bool `json:"save_path_changed_tmm_enabled,omitempty"`

	// SaveResumeDataInterval Save resume data interval in min
	SaveResumeDataInterval *int64 `json:"save_resume_data_interval,omitempty"`

	// ScanDirs Property: directory to watch for torrent files, value: where torrents loaded from this directory should be downloaded to (see list of possible values below). Slashes are used as path separators; multiple key/value pairs can be specified
	//
	// | Value                  | Description                       |
	// | ---------------------- | --------------------------------- |
	// | 0                      | Download to the monitored folder  |
	// | 1                      | Download to the default save path |
	// | "/path/to/download/to" | Download to this path             |
	ScanDirs *map[string]PreferencesScanDirsValue `json:"scan_dirs,omitempty"`

	// ScheduleFromHour Scheduler starting hour
	ScheduleFromHour *int32 `json:"schedule_from_hour,omitempty"`

	// ScheduleFromMin Scheduler starting minute
	ScheduleFromMin *int32 `json:"schedule_from_min,omitempty"`

	// ScheduleToHour Scheduler ending hour
	ScheduleToHour *int32 `json:"schedule_to_hour,omitempty"`

	// ScheduleToMin Scheduler ending minute
	ScheduleToMin *int32 `json:"schedule_to_min,omitempty"`

	// SchedulerDays Scheduler days. See possible values here below
	//
	// | Value | Description     |
	// | ----- | --------------- |
	// | 0     | Every day       |
	// | 1     | Every weekday   |
	// | 2     | Every weekend   |
	// | 3     | Every Monday    |
	// | 4     | Every Tuesday   |
	// | 5     | Every Wednesday |
	// | 6     | Every Thursday  |
	// | 7     | Every Friday    |
	// | 8     | Every Saturday  |
	// | 9     | Every Sunday    |
	SchedulerDays *SetPreferencesSchedulerDays `json:"scheduler_days,omitempty"`

	// SchedulerEnabled True if alternative limits should be applied according to schedule
	SchedulerEnabled *bool `json:"scheduler_enabled,omitempty"`

	// SendBufferLowWatermark Send buffer low watermark in KiB
	SendBufferLowWatermark *int64 `json:"send_buffer_low_watermark,omitempty"`

	// SendBufferWatermark Send buffer watermark in KiB
	SendBufferWatermark *int64 `json:"send_buffer_watermark,omitempty"`

	// SendBufferWatermarkFactor Send buffer watermark factor in percent
	SendBufferWatermarkFactor *int32 `json:"send_buffer_watermark_factor,omitempty"`

	// SlowTorrentDlRateThreshold Download rate in KiB/s for a torrent to be considered "slow"
	SlowTorrentDlRateThreshold *int64 `json:"slow_torrent_dl_rate_threshold,omitempty"`

	// SlowTorrentInactiveTimer Seconds a torrent should be inactive before considered "slow"
	SlowTorrentInactiveTimer *int64 `json:"slow_torrent_inactive_timer,omitempty"`

	// SlowTorrentUlRateThreshold Upload rate in KiB/s for a torrent to be considered "slow"
	SlowTorrentUlRateThreshold *int64 `json:"slow_torrent_ul_rate_threshold,omitempty"`

	// SocketBacklogSize Socket backlog size
	SocketBacklogSize *int64 `json:"socket_backlog_size,omitempty"`

	// SslCert For API < v2.0.1: SSL certificate contents (this is a not a path)
	SslCert *string `json:"ssl_cert,omitempty"`

	// SslKey For API < v2.0.1: SSL keyfile contents (this is a not a path)
	SslKey *string `json:"ssl_key,omitempty"`

	// StartPausedEnabled True if torrents should be added in a Paused state
	StartPausedEnabled *bool `json:"start_paused_enabled,omitempty"`

	// StopTrackerTimeout Timeout in seconds for a `stopped` announce request to trackers
	StopTrackerTimeout *int64 `json:"stop_tracker_timeout,omitempty"`

	// TempPath Path for incomplete torrents, separated by slashes
	TempPath *string `json:"temp_path,omitempty"`

	// TempPathEnabled True if folder for incomplete torrents is enabled
	TempPathEnabled *bool `json:"temp_path_enabled,omitempty"`

	// TorrentChangedTmmEnabled True if torrent should be relocated when its Category changes
	TorrentChangedTmmEnabled *bool `json:"torrent_changed_tmm_enabled,omitempty"`

	// UpLimit Global upload speed limit in KiB/s; `-1` means no limit is applied
	UpLimit *int64 `json:"up_limit,omitempty"`

	// UploadChokingAlgorithm Upload choking algorithm used (see list of possible values below)
	//
	// | Value | Description    |
	// | ----- | -------------- |
	// | 0     | Round-robin    |
	// | 1     | Fastest upload |
	// | 2     | Anti-leech     |
	UploadChokingAlgorithm *SetPreferencesUploadChokingAlgorithm `json:"upload_choking_algorithm,omitempty"`

	// UploadSlotsBehavior Upload slots behavior used (see list of possible values below)
	//
	// | Value | Description       |
	// | ----- | ----------------- |
	// | 0     | Fixed slots       |
	// | 1     | Upload rate based |
	UploadSlotsBehavior *SetPreferencesUploadSlotsBehavior `json:"upload_slots_behavior,omitempty"`

	// Upnp True if UPnP/NAT-PMP is enabled
	Upnp *bool `json:"upnp,omitempty"`

	// UpnpLeaseDuration UPnP lease duration (0: Permanent lease)
	UpnpLeaseDuration *int64 `json:"upnp_lease_duration,omitempty"`

	// UseHttps True if WebUI HTTPS access is enabled
	UseHttps *bool `json:"use_https,omitempty"`

	// UtpTcpMixedMode μTP-TCP mixed mode algorithm (see list of possible values below)
	//
	// | Value | Description       |
	// | ----- | ----------------- |
	// | 0     | Prefer TCP        |
	// | 1     | Peer proportional |
	UtpTcpMixedMode *SetPreferencesUtpTcpMixedMode `json:"utp_tcp_mixed_mode,omitempty"`

	// WebUiAddress IP address to use for the WebUI
	WebUiAddress *string `json:"web_ui_address,omitempty"`

	// WebUiBanDuration WebUI access ban duration in seconds
	WebUiBanDuration *int64 `json:"web_ui_ban_duration,omitempty"`

	// WebUiClickjackingProtectionEnabled True if WebUI clickjacking protection is enabled
	WebUiClickjackingProtectionEnabled *bool `json:"web_ui_clickjacking_protection_enabled,omitempty"`

	// WebUiCsrfProtectionEnabled True if WebUI CSRF protection is enabled
	WebUiCsrfProtectionEnabled *bool `json:"web_ui_csrf_protection_enabled,omitempty"`

	// WebUiCustomHttpHeaders For API ≥ v2.5.1: List of custom http headers
	WebUiCustomHttpHeaders *string `json:"web_ui_custom_http_headers,omitempty"`

	// WebUiDomainList Comma-separated list of domains to accept when performing Host header validation
	WebUiDomainList *[]string `json:"web_ui_domain_list,omitempty"`

	// WebUiHostHeaderValidationEnabled True if WebUI host header validation is enabled
	WebUiHostHeaderValidationEnabled *bool `json:"web_ui_host_header_validation_enabled,omitempty"`

	// WebUiHttpsCertPath For API ≥ v2.0.1: Path to SSL certificate
	WebUiHttpsCertPath *string `json:"web_ui_https_cert_path,omitempty"`

	// WebUiHttpsKeyPath For API ≥ v2.0.1: Path to SSL keyfile
	WebUiHttpsKeyPath *string `json:"web_ui_https_key_path,omitempty"`

	// WebUiMaxAuthFailCount Maximum number of authentication failures before WebUI access ban
	WebUiMaxAuthFailCount *int64 `json:"web_ui_max_auth_fail_count,omitempty"`

	// WebUiPassword For API ≥ v2.3.0: Plaintext WebUI password, not readable, write-only. For API < v2.3.0: MD5 hash of WebUI password, hash is generated from the following string: `username:Web UI Access:plain_text_web_ui_password`
	WebUiPassword *string `json:"web_ui_password,omitempty"`

	// WebUiPort WebUI port
	WebUiPort *int32 `json:"web_ui_port,omitempty"`

	// WebUiSecureCookieEnabled True if WebUI cookie `Secure` flag is enabled
	WebUiSecureCookieEnabled *bool `json:"web_ui_secure_cookie_enabled,omitempty"`

	// WebUiSessionTimeout Seconds until WebUI is automatically signed off
	WebUiSessionTimeout *int64 `json:"web_ui_session_timeout,omitempty"`

	// WebUiUpnp True if UPnP is used for the WebUI port
	WebUiUpnp *bool `json:"web_ui_upnp,omitempty"`

	// WebUiUseCustomHttpHeadersEnabled For API ≥ v2.5.1: Enable custom http headers
	WebUiUseCustomHttpHeadersEnabled *bool `json:"web_ui_use_custom_http_headers_enabled,omitempty"`

	// WebUiUsername WebUI username
	WebUiUsername *string `json:"web_ui_username,omitempty"`
}

// SetPreferencesBittorrentProtocol Bittorrent Protocol to use (see list of possible values below)
//
// | Value | Description |
// | ----- | ----------- |
// | 0     | TCP and μTP |
// | 1     | TCP         |
// | 2     | μTP         |
type SetPreferencesBittorrentProtocol int32

// SetPreferencesDyndnsService See list of possible values here below
//
// | Value | Description |
// | ----- | ----------- |
// | 0     | Use DyDNS   |
// | 1     | Use NOIP    |
type SetPreferencesDyndnsService int32

// SetPreferencesEncryption See list of possible values here below
//
// | Value | Description          |
// | ----- | -------------------- |
// | 0     | Prefer encryption    |
// | 1     | Force encryption on  |
// | 2     | Force encryption off |
type SetPreferencesEncryption int32

// SetPreferencesMaxRatioAct Action performed when a torrent reaches the maximum share ratio. See list of possible values here below.
//
// | Value | Description    |
// | ----- | -------------- |
// | 0     | Pause torrent  |
// | 1     | Remove torrent |
type SetPreferencesMaxRatioAct int64

// SetPreferencesProxyType See list of possible values here below
//
// | Value | Description                         |
// | ----- | ----------------------------------- |
// | -1    | Proxy is disabled                   |
// | 0     | Prefer encryption                   |
// | 1     | HTTP proxy without authentication   |
// | 2     | SOCKS5 proxy without authentication |
// | 3     | HTTP proxy with authentication      |
// | 4     | SOCKS5 proxy with authentication    |
// | 5     | SOCKS4 proxy without authentication |
type SetPreferencesProxyType int32

// SetPreferencesSchedulerDays Scheduler days. See possible values here below
//
// | Value | Description     |
// | ----- | --------------- |
// | 0     | Every day       |
// | 1     | Every weekday   |
// | 2     | Every weekend   |
// | 3     | Every Monday    |
// | 4     | Every Tuesday   |
// | 5     | Every Wednesday |
// | 6     | Every Thursday  |
// | 7     | Every Friday    |
// | 8     | Every Saturday  |
// | 9     | Every Sunday    |
type SetPreferencesSchedulerDays int32

// SetPreferencesUploadChokingAlgorithm Upload choking algorithm used (see list of possible values below)
//
// | Value | Description    |
// | ----- | -------------- |
// | 0     | Round-robin    |
// | 1     | Fastest upload |
// | 2     | Anti-leech     |
type SetPreferencesUploadChokingAlgorithm int32

// SetPreferencesUploadSlotsBehavior Upload slots behavior used (see list of possible values below)
//
// | Value | Description       |
// | ----- | ----------------- |
// | 0     | Fixed slots       |
// | 1     | Upload rate based |
type SetPreferencesUploadSlotsBehavior int32

// SetPreferencesUtpTcpMixedMode μTP-TCP mixed mode algorithm (see list of possible values below)
//
// | Value | Description       |
// | ----- | ----------------- |
// | 0     | Prefer TCP        |
// | 1     | Peer proportional |
type SetPreferencesUtpTcpMixedMode int32

// SetPreferencesAllOf defines model for SetPreferences_allOf.
type SetPreferencesAllOf struct {
	// WebUiPassword For API ≥ v2.3.0: Plaintext WebUI password, not readable, write-only. For API < v2.3.0: MD5 hash of WebUI password, hash is generated from the following string: `username:Web UI Access:plain_text_web_ui_password`
	WebUiPassword *string `json:"web_ui_password,omitempty"`
}

// SetTorrentsLimit defines model for SetTorrentsLimit.
type SetTorrentsLimit struct {
	Hashes []string `json:"hashes"`
	Limit  *int64   `json:"limit,omitempty"`
}

// SetTorrentsLimitAllOf defines model for SetTorrentsLimit_allOf.
type SetTorrentsLimitAllOf struct {
	Limit *int64 `json:"limit,omitempty"`
}

// SetTorrentsValue defines model for SetTorrentsValue.
type SetTorrentsValue struct {
	Hashes []string `json:"hashes"`

	// Value `value` is a boolean, affects the torrents listed in `hashes`, default is `false`
	Value *bool `json:"value,omitempty"`
}

// SetTorrentsValueAllOf defines model for SetTorrentsValue_allOf.
type SetTorrentsValueAllOf struct {
	// Value `value` is a boolean, affects the torrents listed in `hashes`, default is `false`
	Value *bool `json:"value,omitempty"`
}

// TorrentInfo defines model for TorrentInfo.
type TorrentInfo struct {
	// AddedOn Time (Unix Epoch) when the torrent was added to the client
	AddedOn *int64 `json:"added_on,omitempty"`

	// AmountLeft Amount of data left to download (bytes)
	AmountLeft *int64 `json:"amount_left,omitempty"`

	// AutoTmm Whether this torrent is managed by Automatic Torrent Management
	AutoTmm *bool `json:"auto_tmm,omitempty"`

	// Availability Percentage of file pieces currently available
	Availability *float32 `json:"availability,omitempty"`

	// Category Category of the torrent
	Category *string `json:"category,omitempty"`

	// Completed Amount of transfer data completed (bytes)
	Completed *int64 `json:"completed,omitempty"`

	// CompletionOn Time (Unix Epoch) when the torrent completed
	CompletionOn *int64 `json:"completion_on,omitempty"`

	// ContentPath Absolute path of torrent content (root path for multifile torrents, absolute file path for singlefile torrents)
	ContentPath *string `json:"content_path,omitempty"`

	// DlLimit Torrent download speed limit (bytes/s). `-1` if ulimited.
	DlLimit *int64 `json:"dl_limit,omitempty"`

	// Dlspeed Torrent download speed (bytes/s)
	Dlspeed *int64 `json:"dlspeed,omitempty"`

	// Downloaded Amount of data downloaded
	Downloaded *int64 `json:"downloaded,omitempty"`

	// DownloadedSession Amount of data downloaded this session
	DownloadedSession *int64 `json:"downloaded_session,omitempty"`

	// Eta Torrent ETA (seconds)
	Eta *int64 `json:"eta,omitempty"`

	// FLPiecePrio True if first last piece are prioritized
	FLPiecePrio *bool `json:"f_l_piece_prio,omitempty"`

	// ForceStart True if force start is enabled for this torrent
	ForceStart *bool `json:"force_start,omitempty"`

	// Hash Torrent hash
	Hash *string `json:"hash,omitempty"`

	// LastActivity Last time (Unix Epoch) when a chunk was downloaded/uploaded
	LastActivity *int64 `json:"last_activity,omitempty"`

	// MagnetUri Magnet URI corresponding to this torrent
	MagnetUri *string `json:"magnet_uri,omitempty"`

	// MaxRatio Maximum share ratio until torrent is stopped from seeding/uploading
	MaxRatio *float32 `json:"max_ratio,omitempty"`

	// MaxSeedingTime Maximum seeding time (seconds) until torrent is stopped from seeding
	MaxSeedingTime *int64 `json:"max_seeding_time,omitempty"`

	// Name Torrent name
	Name *string `json:"name,omitempty"`

	// NumComplete Number of seeds in the swarm
	NumComplete *int64 `json:"num_complete,omitempty"`

	// NumIncomplete Number of leechers in the swarm
	NumIncomplete *int64 `json:"num_incomplete,omitempty"`

	// NumLeechs Number of leechers connected to
	NumLeechs *int64 `json:"num_leechs,omitempty"`

	// NumSeeds Number of seeds connected to
	NumSeeds *int64 `json:"num_seeds,omitempty"`

	// Priority Torrent priority. Returns -1 if queuing is disabled or torrent is in seed mode
	Priority *int64 `json:"priority,omitempty"`

	// Progress Torrent progress (percentage/100)
	Progress *float32 `json:"progress,omitempty"`

	// Ratio Torrent share ratio. Max ratio value: 9999.
	Ratio *float32 `json:"ratio,omitempty"`

	// RatioLimit TODO (what is different from max_ratio?)
	RatioLimit *float32 `json:"ratio_limit,omitempty"`

	// SavePath Path where this torrent's data is stored
	SavePath *string `json:"save_path,omitempty"`

	// SeedingTime Torrent elapsed time while complete (seconds)
	SeedingTime *int64 `json:"seeding_time,omitempty"`

	// SeedingTimeLimit TODO (what is different from `max_seeding_time`?) seeding_time_limit is a per torrent setting, when Automatic Torrent Management is disabled, furthermore then max_seeding_time is set to seeding_time_limit for this torrent. If Automatic Torrent Management is enabled, the value is -2. And if max_seeding_time is unset it have a default value -1.
	SeedingTimeLimit *int64 `json:"seeding_time_limit,omitempty"`

	// SeenComplete Time (Unix Epoch) when this torrent was last seen complete
	SeenComplete *int64 `json:"seen_complete,omitempty"`

	// SeqDl True if sequential download is enabled
	SeqDl *bool `json:"seq_dl,omitempty"`

	// Size Total size (bytes) of files selected for download
	Size *int64 `json:"size,omitempty"`

	// State Torrent state. See table here below for the possible values
	//
	// | Value              | Description                                                   |
	// | ------------------ | ------------------------------------------------------------- |
	// | error              | Some error occurred, applies to paused torrents               |
	// | missingFiles       | Torrent data files is missing                                 |
	// | uploading          | Torrent is being seeded and data is being transferred         |
	// | pausedUP           | Torrent is paused and has finished downloading                |
	// | queuedUP           | Queuing is enabled and torrent is queued for upload           |
	// | stalledUP          | Torrent is being seeded, but no connection were made          |
	// | checkingUP         | Torrent has finished downloading and is being checked         |
	// | forcedUP           | Torrent is forced to uploading and ignore queue limit         |
	// | allocating         | Torrent is allocating disk space for download                 |
	// | downloading        | Torrent is being downloaded and data is being transferred     |
	// | metaDL             | Torrent has just started downloading and is fetching metadata |
	// | pausedDL           | Torrent is paused and has NOT finished downloading            |
	// | queuedDL           | Queuing is enabled and torrent is queued for download         |
	// | stalledDL          | Torrent is being downloaded, but no connection were made      |
	// | checkingDL         | Same as checkingUP, but torrent has NOT finished downloading  |
	// | forcedDL           | Torrent is forced to downloading to ignore queue limit        |
	// | checkingResumeData | Checking resume data on qBt startup                           |
	// | moving             | Torrent is moving to another location                         |
	// | unknown            | Unknown status                                                |
	State *TorrentInfoState `json:"state,omitempty"`

	// SuperSeeding True if super seeding is enabled
	SuperSeeding *bool `json:"super_seeding,omitempty"`

	// Tags Comma-concatenated tag list of the torrent
	Tags *string `json:"tags,omitempty"`

	// TimeActive Total active time (seconds)
	TimeActive *int64 `json:"time_active,omitempty"`

	// TotalSize Total size (bytes) of all file in this torrent (including unselected ones)
	TotalSize *int64 `json:"total_size,omitempty"`

	// Tracker The first tracker with working status. Returns empty string if no tracker is working.
	Tracker *string `json:"tracker,omitempty"`

	// UpLimit Torrent upload speed limit (bytes/s). `-1` if ulimited.
	UpLimit *int64 `json:"up_limit,omitempty"`

	// Uploaded Amount of data uploaded
	Uploaded *int64 `json:"uploaded,omitempty"`

	// UploadedSession Amount of data uploaded this session
	UploadedSession *int64 `json:"uploaded_session,omitempty"`

	// Upspeed Torrent upload speed (bytes/s)
	Upspeed *int64 `json:"upspeed,omitempty"`
}

// TorrentInfoState Torrent state. See table here below for the possible values
//
// | Value              | Description                                                   |
// | ------------------ | ------------------------------------------------------------- |
// | error              | Some error occurred, applies to paused torrents               |
// | missingFiles       | Torrent data files is missing                                 |
// | uploading          | Torrent is being seeded and data is being transferred         |
// | pausedUP           | Torrent is paused and has finished downloading                |
// | queuedUP           | Queuing is enabled and torrent is queued for upload           |
// | stalledUP          | Torrent is being seeded, but no connection were made          |
// | checkingUP         | Torrent has finished downloading and is being checked         |
// | forcedUP           | Torrent is forced to uploading and ignore queue limit         |
// | allocating         | Torrent is allocating disk space for download                 |
// | downloading        | Torrent is being downloaded and data is being transferred     |
// | metaDL             | Torrent has just started downloading and is fetching metadata |
// | pausedDL           | Torrent is paused and has NOT finished downloading            |
// | queuedDL           | Queuing is enabled and torrent is queued for download         |
// | stalledDL          | Torrent is being downloaded, but no connection were made      |
// | checkingDL         | Same as checkingUP, but torrent has NOT finished downloading  |
// | forcedDL           | Torrent is forced to downloading to ignore queue limit        |
// | checkingResumeData | Checking resume data on qBt startup                           |
// | moving             | Torrent is moving to another location                         |
// | unknown            | Unknown status                                                |
type TorrentInfoState string

// TorrentPeers The response is TODO
type TorrentPeers = map[string]interface{}

// TorrentsCategory defines model for TorrentsCategory.
type TorrentsCategory struct {
	Name     *string `json:"name,omitempty"`
	SavePath *string `json:"savePath,omitempty"`
}

// TorrentsFiles defines model for TorrentsFiles.
type TorrentsFiles struct {
	// Availability Percentage of file pieces currently available (percentage/100)
	Availability *float32 `json:"availability,omitempty"`

	// Index File index
	Index *int64 `json:"index,omitempty"`

	// IsSeed True if file is seeding/complete
	IsSeed *bool `json:"is_seed,omitempty"`

	// Name File name (including relative path)
	Name *string `json:"name,omitempty"`

	// PieceRange The first number is the starting piece index and the second number is the ending piece index (inclusive)
	PieceRange *[]int64 `json:"piece_range,omitempty"`

	// Priority File priority. See possible values here below
	//
	// | Value | Description      |
	// | ----- | ---------------- |
	// | 0     | Do not download  |
	// | 1     | Normal priority  |
	// | 6     | High priority    |
	// | 7     | Maximal priority |
	Priority *TorrentsFilesPriority `json:"priority,omitempty"`

	// Progress File progress (percentage/100)
	Progress *float32 `json:"progress,omitempty"`

	// Size File size (bytes)
	Size *int64 `json:"size,omitempty"`
}

// TorrentsFilesPriority File priority. See possible values here below
//
// | Value | Description      |
// | ----- | ---------------- |
// | 0     | Do not download  |
// | 1     | Normal priority  |
// | 6     | High priority    |
// | 7     | Maximal priority |
type TorrentsFilesPriority int64

// TorrentsLimit defines model for TorrentsLimit.
type TorrentsLimit map[string]int64

// TorrentsProperties The response is:
// - empty, if the torrent hash is invalid
// - otherwise, a JSON object with the following fields
//
// NB: `-1` is returned if the type of the property is integer but its value is not known.
type TorrentsProperties struct {
	// AdditionDate When this torrent was added (unix timestamp)
	AdditionDate *int64 `json:"addition_date,omitempty"`

	// Comment Torrent comment
	Comment *string `json:"comment,omitempty"`

	// CompletionDate Torrent completion date (unix timestamp)
	CompletionDate *int64 `json:"completion_date,omitempty"`

	// CreatedBy Torrent creator
	CreatedBy *string `json:"created_by,omitempty"`

	// CreationDate Torrent creation date (Unix timestamp)
	CreationDate *int64 `json:"creation_date,omitempty"`

	// DlLimit Torrent download limit (bytes/s)
	DlLimit *int64 `json:"dl_limit,omitempty"`

	// DlSpeed Torrent download speed (bytes/second)
	DlSpeed *int64 `json:"dl_speed,omitempty"`

	// DlSpeedAvg Torrent average download speed (bytes/second)
	DlSpeedAvg *int64 `json:"dl_speed_avg,omitempty"`

	// Eta Torrent ETA (seconds)
	Eta *int64 `json:"eta,omitempty"`

	// LastSeen Last seen complete date (unix timestamp)
	LastSeen *int64 `json:"last_seen,omitempty"`

	// NbConnections Torrent connection count
	NbConnections *int64 `json:"nb_connections,omitempty"`

	// NbConnectionsLimit Torrent connection count limit
	NbConnectionsLimit *int64 `json:"nb_connections_limit,omitempty"`

	// Peers Number of peers connected to
	Peers *int64 `json:"peers,omitempty"`

	// PeersTotal Number of peers in the swarm
	PeersTotal *int64 `json:"peers_total,omitempty"`

	// PieceSize Torrent piece size (bytes)
	PieceSize *int64 `json:"piece_size,omitempty"`

	// PiecesHave Number of pieces owned
	PiecesHave *int64 `json:"pieces_have,omitempty"`

	// PiecesNum Number of pieces of the torrent
	PiecesNum *int64 `json:"pieces_num,omitempty"`

	// Reannounce Number of seconds until the next announce
	Reannounce *int64 `json:"reannounce,omitempty"`

	// SavePath Torrent save path
	SavePath *string `json:"save_path,omitempty"`

	// SeedingTime Torrent elapsed time while complete (seconds)
	SeedingTime *int64 `json:"seeding_time,omitempty"`

	// Seeds Number of seeds connected to
	Seeds *int64 `json:"seeds,omitempty"`

	// SeedsTotal Number of seeds in the swarm
	SeedsTotal *int64 `json:"seeds_total,omitempty"`

	// ShareRatio Torrent share ratio
	ShareRatio *float32 `json:"share_ratio,omitempty"`

	// TimeElapsed Torrent elapsed time (seconds)
	TimeElapsed *int64 `json:"time_elapsed,omitempty"`

	// TotalDownloaded Total data downloaded for torrent (bytes)
	TotalDownloaded *int64 `json:"total_downloaded,omitempty"`

	// TotalDownloadedSession Total data downloaded this session (bytes)
	TotalDownloadedSession *int64 `json:"total_downloaded_session,omitempty"`

	// TotalSize Torrent total size (bytes)
	TotalSize *int64 `json:"total_size,omitempty"`

	// TotalUploaded Total data uploaded for torrent (bytes)
	TotalUploaded *int64 `json:"total_uploaded,omitempty"`

	// TotalUploadedSession Total data uploaded this session (bytes)
	TotalUploadedSession *int64 `json:"total_uploaded_session,omitempty"`

	// TotalWasted Total data wasted for torrent (bytes)
	TotalWasted *int64 `json:"total_wasted,omitempty"`

	// UpLimit Torrent upload limit (bytes/s)
	UpLimit *int64 `json:"up_limit,omitempty"`

	// UpSpeed Torrent upload speed (bytes/second)
	UpSpeed *int64 `json:"up_speed,omitempty"`

	// UpSpeedAvg Torrent average upload speed (bytes/second)
	UpSpeedAvg *int64 `json:"up_speed_avg,omitempty"`
}

// TorrentsTags defines model for TorrentsTags.
type TorrentsTags struct {
	Hashes []string  `json:"hashes"`
	Tags   *[]string `json:"tags,omitempty"`
}

// TorrentsTagsAllOf defines model for TorrentsTags_allOf.
type TorrentsTagsAllOf struct {
	Tags *[]string `json:"tags,omitempty"`
}

// TorrentsTrackers defines model for TorrentsTrackers.
type TorrentsTrackers struct {
	// Msg Tracker message (there is no way of knowing what this message is - it's up to tracker admins)
	Msg *string `json:"msg,omitempty"`

	// NumDownloaded Number of completed downlods for current torrent, as reported by the tracker
	NumDownloaded *int64 `json:"num_downloaded,omitempty"`

	// NumLeeches Number of leeches for current torrent, as reported by the tracker
	NumLeeches *int64 `json:"num_leeches,omitempty"`

	// NumPeers Number of peers for current torrent, as reported by the tracker
	NumPeers *int64 `json:"num_peers,omitempty"`

	// NumSeeds Number of seeds for current torrent, asreported by the tracker
	NumSeeds *int64 `json:"num_seeds,omitempty"`

	// Status Tracker status. See the table below for possible values
	//
	// | Value | Description                                                                        |
	// | ----- | ---------------------------------------------------------------------------------- |
	// | 0     | Tracker is disabled (used for DHT, PeX, and LSD)                                   |
	// | 1     | Tracker has not been contacted yet                                                 |
	// | 2     | Tracker has been contacted and is working                                          |
	// | 3     | Tracker is updating                                                                |
	// | 4     | Tracker has been contacted, but it is not working (or doesn't send proper replies) |
	Status *TorrentsTrackersStatus `json:"status,omitempty"`

	// Tier Tracker priority tier. Lower tier trackers are tried before higher tiers. Tier numbers are valid when `>= 0`, `< 0` is used as placeholder when `tier` does not exist for special entries (such as DHT).
	Tier *int64 `json:"tier,omitempty"`

	// Url Tracker url
	Url *string `json:"url,omitempty"`
}

// TorrentsTrackersStatus Tracker status. See the table below for possible values
//
// | Value | Description                                                                        |
// | ----- | ---------------------------------------------------------------------------------- |
// | 0     | Tracker is disabled (used for DHT, PeX, and LSD)                                   |
// | 1     | Tracker has not been contacted yet                                                 |
// | 2     | Tracker has been contacted and is working                                          |
// | 3     | Tracker is updating                                                                |
// | 4     | Tracker has been contacted, but it is not working (or doesn't send proper replies) |
type TorrentsTrackersStatus int32

// TorrentsWebseeds defines model for TorrentsWebseeds.
type TorrentsWebseeds struct {
	// Url URL of the web seed
	Url *string `json:"url,omitempty"`
}

// TransferInfo The response is a JSON object with the following fields
//
// In addition to the above in partial data requests (see [Get partial data](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-partial-data) for more info):
type TransferInfo struct {
	// ConnectionStatus Connection status. See possible values here below
	//
	// Possible values of connection_status:
	// | Value        |
	// | ------------ |
	// | connected    |
	// | firewalled   |
	// | disconnected |
	ConnectionStatus *string `json:"connection_status,omitempty"`

	// DhtNodes DHT nodes connected to
	DhtNodes *int64 `json:"dht_nodes,omitempty"`

	// DlInfoData Data downloaded this session (bytes)
	DlInfoData *int64 `json:"dl_info_data,omitempty"`

	// DlInfoSpeed Global download rate (bytes/s)
	DlInfoSpeed *int64 `json:"dl_info_speed,omitempty"`

	// DlRateLimit Download rate limit (bytes/s)
	DlRateLimit *int64 `json:"dl_rate_limit,omitempty"`

	// Queueing True if torrent queueing is enabled
	Queueing *bool `json:"queueing,omitempty"`

	// RefreshInterval Transfer list refresh interval (milliseconds)
	RefreshInterval *int64 `json:"refresh_interval,omitempty"`

	// UpInfoData Data uploaded this session (bytes)
	UpInfoData *int64 `json:"up_info_data,omitempty"`

	// UpInfoSpeed Global upload rate (bytes/s)
	UpInfoSpeed *int64 `json:"up_info_speed,omitempty"`

	// UpRateLimit Upload rate limit (bytes/s)
	UpRateLimit *int64 `json:"up_rate_limit,omitempty"`

	// UseAltSpeedLimits True if alternative speed limits are enabled
	UseAltSpeedLimits *bool `json:"use_alt_speed_limits,omitempty"`
}

// AppSetPreferencesPostRequest defines model for appSetPreferencesPost_request.
type AppSetPreferencesPostRequest struct {
	// Json A json object with key-value pairs of the settings you want to change and their new values.
	Json SetPreferences `json:"json"`
}

// AuthLoginPostRequest defines model for authLoginPost_request.
type AuthLoginPostRequest struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// LogMainPostRequest defines model for logMainPost_request.
type LogMainPostRequest struct {
	// Critical Include critical messages (default: `true`)
	Critical bool `json:"critical"`

	// Info Include info messages (default: `true`)
	Info bool `json:"info"`

	// LastKnownId Exclude messages with "message id" <= `last_known_id` (default: `-1`)
	LastKnownId int64 `json:"last_known_id"`

	// Normal Include normal messages (default: `true`)
	Normal bool `json:"normal"`

	// Warning Include warning messages (default: `true`)
	Warning bool `json:"warning"`
}

// LogPeersPostRequest defines model for logPeersPost_request.
type LogPeersPostRequest struct {
	// LastKnownId Exclude messages with "message id" <= `last_known_id` (default: `-1`)
	LastKnownId int64 `json:"last_known_id"`
}

// RssAddFeedPostRequest defines model for rssAddFeedPost_request.
type RssAddFeedPostRequest struct {
	// Path Full path of added folder (e.g. "The Pirate Bay\Top100\Video")
	Path *string `json:"path,omitempty"`

	// Url URL of RSS feed (e.g. "http://thepiratebay.org/rss//top100/200")
	Url string `json:"url"`
}

// RssAddFolderPostRequest defines model for rssAddFolderPost_request.
type RssAddFolderPostRequest struct {
	// Path Full path of added folder (e.g. "The Pirate Bay\Top100")
	Path string `json:"path"`
}

// RssItemsPostRequest defines model for rssItemsPost_request.
type RssItemsPostRequest struct {
	// WithData True if you need current feed articles
	WithData *bool `json:"withData,omitempty"`
}

// RssMarkAsReadPostRequest defines model for rssMarkAsReadPost_request.
type RssMarkAsReadPostRequest struct {
	// ArticleId ID of article
	ArticleId *string `json:"articleId,omitempty"`

	// ItemPath Current full path of item (e.g. "The Pirate Bay\Top100")
	ItemPath string `json:"itemPath"`
}

// RssMatchingArticlesPostRequest defines model for rssMatchingArticlesPost_request.
type RssMatchingArticlesPostRequest struct {
	// RuleName Rule name (e.g. "Linux")
	RuleName string `json:"ruleName"`
}

// RssMoveItemPostRequest defines model for rssMoveItemPost_request.
type RssMoveItemPostRequest struct {
	// DestPath New full path of item (e.g. "The Pirate Bay")
	DestPath string `json:"destPath"`

	// ItemPath Current full path of item (e.g. "The Pirate Bay\Top100")
	ItemPath string `json:"itemPath"`
}

// RssRefreshItemPostRequest defines model for rssRefreshItemPost_request.
type RssRefreshItemPostRequest struct {
	// ItemPath Current full path of item (e.g. "The Pirate Bay\Top100")
	ItemPath string `json:"itemPath"`
}

// RssRemoveItemPostRequest defines model for rssRemoveItemPost_request.
type RssRemoveItemPostRequest struct {
	// Path Full path of removed item (e.g. "The Pirate Bay\Top100")
	Path string `json:"path"`
}

// RssRemoveRulePostRequest defines model for rssRemoveRulePost_request.
type RssRemoveRulePostRequest struct {
	// RuleName Rule name (e.g. "Punisher")
	RuleName string `json:"ruleName"`
}

// RssRenameRulePostRequest defines model for rssRenameRulePost_request.
type RssRenameRulePostRequest struct {
	// NewRuleName New rule name (e.g. "The Punisher")
	NewRuleName string `json:"newRuleName"`

	// RuleName Rule name (e.g. "Punisher")
	RuleName string `json:"ruleName"`
}

// RssSetRulePostRequest defines model for rssSetRulePost_request.
type RssSetRulePostRequest struct {
	// RuleDef JSON encoded rule definition
	//
	// Rule definition is JSON encoded dictionary with the following fields:
	// | Field                     | Type   | Description                                             |
	// | ------------------------- | ------ | ------------------------------------------------------- |
	// | enabled                   | bool   | Whether the rule is enabled                             |
	// | mustContain               | string | The substring that the torrent name must contain        |
	// | mustNotContain            | string | The substring that the torrent name must not contain    |
	// | useRegex                  | bool   | Enable regex mode in "mustContain" and "mustNotContain" |
	// | episodeFilter             | string | Episode filter definition                               |
	// | smartFilter               | bool   | Enable smart episode filter                             |
	// | previouslyMatchedEpisodes | list   | The list of episode IDs already matched by smart filter |
	// | affectedFeeds             | list   | The feed URLs the rule applied to                       |
	// | ignoreDays                | number | Ignore sunsequent rule matches                          |
	// | lastMatch                 | string | The rule last match time                                |
	// | addPaused                 | bool   | Add matched torrent in paused mode                      |
	// | assignedCategory          | string | Assign category to the torrent                          |
	// | savePath                  | string | Save torrent to the given directory                     |
	RuleDef RssRuleDef `json:"ruleDef"`

	// RuleName Rule name (e.g. "Punisher")
	RuleName string `json:"ruleName"`
}

// SearchDeletePostRequest defines model for searchDeletePost_request.
type SearchDeletePostRequest struct {
	// Id ID of the search job
	Id float32 `json:"id"`
}

// SearchEnablePluginPostRequest defines model for searchEnablePluginPost_request.
type SearchEnablePluginPostRequest struct {
	// Enable Whether the plugins should be enabled
	Enable bool `json:"enable"`

	// Names Name of the plugin to enable/disable (e.g. "legittorrents"). Supports multiple names separated by `|`
	Names []string `json:"names"`
}

// SearchInstallPluginPostRequest defines model for searchInstallPluginPost_request.
type SearchInstallPluginPostRequest struct {
	// Sources Url or file path of the plugin to install (e.g. "https://raw.githubusercontent.com/qbittorrent/search-plugins/master/nova3/engines/legittorrents.py"). Supports multiple sources separated by `|`
	Sources []string `json:"sources"`
}

// SearchResultsPostRequest defines model for searchResultsPost_request.
type SearchResultsPostRequest struct {
	// Id ID of the search job
	Id *float32 `json:"id,omitempty"`

	// Limit max number of results to return. 0 or negative means no limit
	Limit *float32 `json:"limit,omitempty"`

	// Offset result to start at. A negative number means count backwards (e.g. -2 returns the 2 most recent results)
	Offset *float32 `json:"offset,omitempty"`
}

// SearchResultsPostRequestAllOf defines model for searchResultsPost_request_allOf.
type SearchResultsPostRequestAllOf struct {
	// Limit max number of results to return. 0 or negative means no limit
	Limit *float32 `json:"limit,omitempty"`

	// Offset result to start at. A negative number means count backwards (e.g. -2 returns the 2 most recent results)
	Offset *float32 `json:"offset,omitempty"`
}

// SearchStartPostRequest defines model for searchStartPost_request.
type SearchStartPostRequest struct {
	// Category Categories to limit your search to (e.g. "legittorrents"). Available categories depend on the specified `plugins`. Also supports `all`
	Category []string `json:"category"`

	// Pattern Pattern to search for (e.g. "Ubuntu 18.04")
	Pattern string `json:"pattern"`

	// Plugins Plugins to use for searching (e.g. "legittorrents"). Supports multiple plugins separated by `|`. Also supports `all` and `enabled`
	Plugins []string `json:"plugins"`
}

// SearchStatusPostRequest defines model for searchStatusPost_request.
type SearchStatusPostRequest struct {
	// Id ID of the search job. If not specified, all search jobs are returned
	Id *float32 `json:"id,omitempty"`
}

// SearchStopPostRequest The response is a JSON object with the following fields
type SearchStopPostRequest = SearchJob

// SearchUninstallPluginPostRequest defines model for searchUninstallPluginPost_request.
type SearchUninstallPluginPostRequest struct {
	// Names Name of the plugin to uninstall (e.g. "legittorrents"). Supports multiple names separated by `|`
	Names []string `json:"names"`
}

// SyncMaindataPostRequest defines model for syncMaindataPost_request.
type SyncMaindataPostRequest struct {
	// Rid Response ID. If not provided, `rid=0` will be assumed. If the given `rid` is different from the one of last server reply, `full_update` will be `true` (see the server reply details for more info)
	Rid *int64 `json:"rid,omitempty"`
}

// SyncTorrentPeersPostRequest defines model for syncTorrentPeersPost_request.
type SyncTorrentPeersPostRequest struct {
	// Hash Torrent hash
	Hash string `json:"hash"`

	// Rid Response ID. If not provided, `rid=0` will be assumed. If the given `rid` is different from the one of last server reply, `full_update` will be `true` (see the server reply details for more info)
	Rid *int64 `json:"rid,omitempty"`
}

// TorrentWebseedsPostRequest defines model for torrentWebseedsPost_request.
type TorrentWebseedsPostRequest struct {
	// Hash The hash of the torrent you want to get the webseeds of
	Hash string `json:"hash"`
}

// TorrentsAddPeersPostRequest defines model for torrentsAddPeersPost_request.
type TorrentsAddPeersPostRequest struct {
	// Hashes The hash of the torrent, or multiple hashes separated by a pipe `|`
	Hashes []string `json:"hashes"`

	// Peers The peer to add, or multiple peers separated by a pipe `|`. Each peer is a colon-separated `host:port`
	Peers []string `json:"peers"`
}

// TorrentsAddPostRequest defines model for torrentsAddPost_request.
type TorrentsAddPostRequest struct {
	union json.RawMessage
}

// TorrentsAddTrackersPostRequest defines model for torrentsAddTrackersPost_request.
type TorrentsAddTrackersPostRequest struct {
	Hash string `json:"hash"`
	Urls string `json:"urls"`
}

// TorrentsCreateCategoryPostRequest defines model for torrentsCreateCategoryPost_request.
type TorrentsCreateCategoryPostRequest = Category

// TorrentsCreateTagsPostRequest defines model for torrentsCreateTagsPost_request.
type TorrentsCreateTagsPostRequest struct {
	// Tags `tags` is a list of tags you want to create. Can contain multiple tags separated by `,`.
	Tags []string `json:"tags"`
}

// TorrentsDeletePostRequest defines model for torrentsDeletePost_request.
type TorrentsDeletePostRequest struct {
	// DeleteFiles If set to `true`, the downloaded data will also be deleted, otherwise has no effect.
	DeleteFiles *bool    `json:"deleteFiles,omitempty"`
	Hashes      []string `json:"hashes"`
}

// TorrentsDeletePostRequestAllOf defines model for torrentsDeletePost_request_allOf.
type TorrentsDeletePostRequestAllOf struct {
	// DeleteFiles If set to `true`, the downloaded data will also be deleted, otherwise has no effect.
	DeleteFiles *bool `json:"deleteFiles,omitempty"`
}

// TorrentsDeleteTagsPostRequest defines model for torrentsDeleteTagsPost_request.
type TorrentsDeleteTagsPostRequest struct {
	// Tags `tags` is a list of tags you want to delete. Can contain multiple tags separated by `,`.
	Tags []string `json:"tags"`
}

// TorrentsEditTrackerPostRequest defines model for torrentsEditTrackerPost_request.
type TorrentsEditTrackerPostRequest struct {
	// Hash The hash of the torrent
	Hash string `json:"hash"`

	// NewUrl The new URL to replace the `origUrl`
	NewUrl string `json:"newUrl"`

	// OrigUrl The tracker URL you want to edit
	OrigUrl string `json:"origUrl"`
}

// TorrentsFilePrioPostRequest defines model for torrentsFilePrioPost_request.
type TorrentsFilePrioPostRequest struct {
	// Hash The hash of the torrent
	Hash string `json:"hash"`

	// Id File ids, separated by `|`
	Id []int64 `json:"id"`

	// Priority File priority to set (consult [torrent contents API](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-torrent-contents) for possible values)
	Priority TorrentsFilePrioPostRequestPriority `json:"priority"`
}

// TorrentsFilePrioPostRequestPriority File priority to set (consult [torrent contents API](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-torrent-contents) for possible values)
type TorrentsFilePrioPostRequestPriority int32

// TorrentsFilesPostRequest defines model for torrentsFilesPost_request.
type TorrentsFilesPostRequest struct {
	// Hash The hash of the torrent you want to get the contents of
	Hash string `json:"hash"`

	// Indexes The indexes of the files you want to retrieve. `indexes` can contain multiple values separated by `|`.
	Indexes *[]string `json:"indexes,omitempty"`
}

// TorrentsInfoPostRequest defines model for torrentsInfoPost_request.
type TorrentsInfoPostRequest struct {
	// Category Get torrents with the given category (empty string means "without category"; no "category" parameter means "any category" <- broken until [#11748](https://github.com/qbittorrent/qBittorrent/issues/11748) is resolved). Remember to URL-encode the category name. For example, `My category` becomes `My%20category`
	Category *string `json:"category,omitempty"`

	// Filter Filter torrent list by state. Allowed state filters: `all`, `downloading`, `seeding`, `completed`, `paused`, `active`, `inactive`, `resumed`, `stalled`, `stalled_uploading`, `stalled_downloading`, `errored`
	Filter *TorrentsInfoPostRequestFilter `json:"filter,omitempty"`

	// Hashes Filter by hashes. Can contain multiple hashes separated by `|`
	Hashes *[]string `json:"hashes,omitempty"`

	// Limit Limit the number of torrents returned
	Limit *int64 `json:"limit,omitempty"`

	// Offset Set offset (if less than 0, offset from end)
	Offset *int64 `json:"offset,omitempty"`

	// Reverse Enable reverse sorting. Defaults to `false`
	Reverse *bool `json:"reverse,omitempty"`

	// Sort Sort torrents by given key. They can be sorted using any field of the response's JSON array (which are documented below) as the sort key.
	Sort *string `json:"sort,omitempty"`

	// Tag Get torrents with the given tag (empty string means "without tag"; no "tag" parameter means "any tag". Remember to URL-encode the category name. For example, `My tag` becomes `My%20tag`
	Tag *string `json:"tag,omitempty"`
}

// TorrentsInfoPostRequestFilter Filter torrent list by state. Allowed state filters: `all`, `downloading`, `seeding`, `completed`, `paused`, `active`, `inactive`, `resumed`, `stalled`, `stalled_uploading`, `stalled_downloading`, `errored`
type TorrentsInfoPostRequestFilter string

// TorrentsPieceHashesPostRequest defines model for torrentsPieceHashesPost_request.
type TorrentsPieceHashesPostRequest struct {
	// Hash The hash of the torrent you want to get the pieces' hashes of
	Hash string `json:"hash"`
}

// TorrentsPieceStatesPostRequest defines model for torrentsPieceStatesPost_request.
type TorrentsPieceStatesPostRequest struct {
	// Hash The hash of the torrent you want to get the pieces' states of
	Hash string `json:"hash"`
}

// TorrentsPropertiesPostRequest defines model for torrentsPropertiesPost_request.
type TorrentsPropertiesPostRequest struct {
	// Hash The hash of the torrent you want to get the generic properties of
	Hash string `json:"hash"`
}

// TorrentsRemoveCategoriesPostRequest defines model for torrentsRemoveCategoriesPost_request.
type TorrentsRemoveCategoriesPostRequest struct {
	// Categories `categories` can contain multiple cateogies separated by `\n` (%0A urlencoded)
	Categories string `json:"categories"`
}

// TorrentsRemoveTrackersPostRequest defines model for torrentsRemoveTrackersPost_request.
type TorrentsRemoveTrackersPostRequest struct {
	// Hash The hash of the torrent
	Hash string `json:"hash"`

	// Urls URLs to remove, separated by `|`
	Urls []string `json:"urls"`
}

// TorrentsRenamePostRequest defines model for torrentsRenamePost_request.
type TorrentsRenamePostRequest struct {
	Hash string `json:"hash"`
	Name string `json:"name"`
}

// TorrentsSetAutoManagementPostRequest defines model for torrentsSetAutoManagementPost_request.
type TorrentsSetAutoManagementPostRequest struct {
	// Enable `enable` is a boolean, affects the torrents listed in `hashes`, default is `false`
	Enable *bool    `json:"enable,omitempty"`
	Hashes []string `json:"hashes"`
}

// TorrentsSetAutoManagementPostRequestAllOf defines model for torrentsSetAutoManagementPost_request_allOf.
type TorrentsSetAutoManagementPostRequestAllOf struct {
	// Enable `enable` is a boolean, affects the torrents listed in `hashes`, default is `false`
	Enable *bool `json:"enable,omitempty"`
}

// TorrentsSetCategoryPostRequest defines model for torrentsSetCategoryPost_request.
type TorrentsSetCategoryPostRequest struct {
	// Category `category` is the torrent category you want to set.
	Category *string  `json:"category,omitempty"`
	Hashes   []string `json:"hashes"`
}

// TorrentsSetCategoryPostRequestAllOf defines model for torrentsSetCategoryPost_request_allOf.
type TorrentsSetCategoryPostRequestAllOf struct {
	// Category `category` is the torrent category you want to set.
	Category *string `json:"category,omitempty"`
}

// TorrentsSetLocationPostRequest defines model for torrentsSetLocationPost_request.
type TorrentsSetLocationPostRequest struct {
	Hashes []string `json:"hashes"`

	// Location `location` is the location to download the torrent to. If the location doesn't exist, the torrent's location is unchanged.
	Location *string `json:"location,omitempty"`
}

// TorrentsSetLocationPostRequestAllOf defines model for torrentsSetLocationPost_request_allOf.
type TorrentsSetLocationPostRequestAllOf struct {
	// Location `location` is the location to download the torrent to. If the location doesn't exist, the torrent's location is unchanged.
	Location *string `json:"location,omitempty"`
}

// TorrentsSetShareLimitsPostRequest defines model for torrentsSetShareLimitsPost_request.
type TorrentsSetShareLimitsPostRequest struct {
	Hashes []string `json:"hashes"`

	// RatioLimit `ratioLimit` is the max ratio the torrent should be seeded until. `-2` means the global limit should be used, -1 means no limit.
	RatioLimit *float32 `json:"ratioLimit,omitempty"`

	// SeedingTimeLimit `seedingTimeLimit` is the max amount of time the torrent should be seeded. `-2` means the global limit should be used, `-1` means no limit.
	SeedingTimeLimit *float32 `json:"seedingTimeLimit,omitempty"`
}

// TorrentsSetShareLimitsPostRequestAllOf defines model for torrentsSetShareLimitsPost_request_allOf.
type TorrentsSetShareLimitsPostRequestAllOf struct {
	// RatioLimit `ratioLimit` is the max ratio the torrent should be seeded until. `-2` means the global limit should be used, -1 means no limit.
	RatioLimit *float32 `json:"ratioLimit,omitempty"`

	// SeedingTimeLimit `seedingTimeLimit` is the max amount of time the torrent should be seeded. `-2` means the global limit should be used, `-1` means no limit.
	SeedingTimeLimit *float32 `json:"seedingTimeLimit,omitempty"`
}

// TorrentsTrackersPostRequest defines model for torrentsTrackersPost_request.
type TorrentsTrackersPostRequest struct {
	// Hash The hash of the torrent you want to get the trackers of
	Hash string `json:"hash"`
}

// TransferBanPeersPostRequest defines model for transferBanPeersPost_request.
type TransferBanPeersPostRequest struct {
	// Peers The peer to ban, or multiple peers separated by a pipe `|`. Each peer is a colon-separated `host:port`
	Peers *[]string `json:"peers,omitempty"`
}

// TransferSetDownloadLimitPostRequest defines model for transferSetDownloadLimitPost_request.
type TransferSetDownloadLimitPostRequest struct {
	// Limit The global download speed limit to set in bytes/second
	Limit *int64 `json:"limit,omitempty"`
}

// TransferSetUploadLimitPostRequest defines model for transferSetUploadLimitPost_request.
type TransferSetUploadLimitPostRequest struct {
	// Limit The global upload speed limit to set in bytes/second
	Limit *int64 `json:"limit,omitempty"`
}

// AuthLoginPostParams defines parameters for AuthLoginPost.
type AuthLoginPostParams struct {
	Referer *string `json:"Referer,omitempty"`
	Origin  *string `json:"Origin,omitempty"`
}

// AppSetPreferencesPostFormdataRequestBody defines body for AppSetPreferencesPost for application/x-www-form-urlencoded ContentType.
type AppSetPreferencesPostFormdataRequestBody = AppSetPreferencesPostRequest

// AuthLoginPostFormdataRequestBody defines body for AuthLoginPost for application/x-www-form-urlencoded ContentType.
type AuthLoginPostFormdataRequestBody = AuthLoginPostRequest

// LogMainPostFormdataRequestBody defines body for LogMainPost for application/x-www-form-urlencoded ContentType.
type LogMainPostFormdataRequestBody = LogMainPostRequest

// LogPeersPostFormdataRequestBody defines body for LogPeersPost for application/x-www-form-urlencoded ContentType.
type LogPeersPostFormdataRequestBody = LogPeersPostRequest

// RssAddFeedPostFormdataRequestBody defines body for RssAddFeedPost for application/x-www-form-urlencoded ContentType.
type RssAddFeedPostFormdataRequestBody = RssAddFeedPostRequest

// RssAddFolderPostFormdataRequestBody defines body for RssAddFolderPost for application/x-www-form-urlencoded ContentType.
type RssAddFolderPostFormdataRequestBody = RssAddFolderPostRequest

// RssItemsPostFormdataRequestBody defines body for RssItemsPost for application/x-www-form-urlencoded ContentType.
type RssItemsPostFormdataRequestBody = RssItemsPostRequest

// RssMarkAsReadPostFormdataRequestBody defines body for RssMarkAsReadPost for application/x-www-form-urlencoded ContentType.
type RssMarkAsReadPostFormdataRequestBody = RssMarkAsReadPostRequest

// RssMatchingArticlesPostFormdataRequestBody defines body for RssMatchingArticlesPost for application/x-www-form-urlencoded ContentType.
type RssMatchingArticlesPostFormdataRequestBody = RssMatchingArticlesPostRequest

// RssMoveItemPostFormdataRequestBody defines body for RssMoveItemPost for application/x-www-form-urlencoded ContentType.
type RssMoveItemPostFormdataRequestBody = RssMoveItemPostRequest

// RssRefreshItemPostFormdataRequestBody defines body for RssRefreshItemPost for application/x-www-form-urlencoded ContentType.
type RssRefreshItemPostFormdataRequestBody = RssRefreshItemPostRequest

// RssRemoveItemPostFormdataRequestBody defines body for RssRemoveItemPost for application/x-www-form-urlencoded ContentType.
type RssRemoveItemPostFormdataRequestBody = RssRemoveItemPostRequest

// RssRemoveRulePostFormdataRequestBody defines body for RssRemoveRulePost for application/x-www-form-urlencoded ContentType.
type RssRemoveRulePostFormdataRequestBody = RssRemoveRulePostRequest

// RssRenameRulePostFormdataRequestBody defines body for RssRenameRulePost for application/x-www-form-urlencoded ContentType.
type RssRenameRulePostFormdataRequestBody = RssRenameRulePostRequest

// RssSetRulePostFormdataRequestBody defines body for RssSetRulePost for application/x-www-form-urlencoded ContentType.
type RssSetRulePostFormdataRequestBody = RssSetRulePostRequest

// SearchDeletePostFormdataRequestBody defines body for SearchDeletePost for application/x-www-form-urlencoded ContentType.
type SearchDeletePostFormdataRequestBody = SearchDeletePostRequest

// SearchEnablePluginPostFormdataRequestBody defines body for SearchEnablePluginPost for application/x-www-form-urlencoded ContentType.
type SearchEnablePluginPostFormdataRequestBody = SearchEnablePluginPostRequest

// SearchInstallPluginPostFormdataRequestBody defines body for SearchInstallPluginPost for application/x-www-form-urlencoded ContentType.
type SearchInstallPluginPostFormdataRequestBody = SearchInstallPluginPostRequest

// SearchResultsPostFormdataRequestBody defines body for SearchResultsPost for application/x-www-form-urlencoded ContentType.
type SearchResultsPostFormdataRequestBody = SearchResultsPostRequest

// SearchStartPostFormdataRequestBody defines body for SearchStartPost for application/x-www-form-urlencoded ContentType.
type SearchStartPostFormdataRequestBody = SearchStartPostRequest

// SearchStatusPostFormdataRequestBody defines body for SearchStatusPost for application/x-www-form-urlencoded ContentType.
type SearchStatusPostFormdataRequestBody = SearchStatusPostRequest

// SearchStopPostFormdataRequestBody defines body for SearchStopPost for application/x-www-form-urlencoded ContentType.
type SearchStopPostFormdataRequestBody = SearchStopPostRequest

// SearchUninstallPluginPostFormdataRequestBody defines body for SearchUninstallPluginPost for application/x-www-form-urlencoded ContentType.
type SearchUninstallPluginPostFormdataRequestBody = SearchUninstallPluginPostRequest

// SyncMaindataPostFormdataRequestBody defines body for SyncMaindataPost for application/x-www-form-urlencoded ContentType.
type SyncMaindataPostFormdataRequestBody = SyncMaindataPostRequest

// SyncTorrentPeersPostFormdataRequestBody defines body for SyncTorrentPeersPost for application/x-www-form-urlencoded ContentType.
type SyncTorrentPeersPostFormdataRequestBody = SyncTorrentPeersPostRequest

// TorrentsAddPostMultipartRequestBody defines body for TorrentsAddPost for multipart/form-data ContentType.
type TorrentsAddPostMultipartRequestBody = TorrentsAddPostRequest

// TorrentsAddPeersPostFormdataRequestBody defines body for TorrentsAddPeersPost for application/x-www-form-urlencoded ContentType.
type TorrentsAddPeersPostFormdataRequestBody = TorrentsAddPeersPostRequest

// TorrentsAddTagsPostFormdataRequestBody defines body for TorrentsAddTagsPost for application/x-www-form-urlencoded ContentType.
type TorrentsAddTagsPostFormdataRequestBody = TorrentsTags

// TorrentsAddTrackersPostFormdataRequestBody defines body for TorrentsAddTrackersPost for application/x-www-form-urlencoded ContentType.
type TorrentsAddTrackersPostFormdataRequestBody = TorrentsAddTrackersPostRequest

// TorrentsBottomPrioPostFormdataRequestBody defines body for TorrentsBottomPrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsBottomPrioPostFormdataRequestBody = Hashes

// TorrentsCreateCategoryPostFormdataRequestBody defines body for TorrentsCreateCategoryPost for application/x-www-form-urlencoded ContentType.
type TorrentsCreateCategoryPostFormdataRequestBody = TorrentsCreateCategoryPostRequest

// TorrentsCreateTagsPostFormdataRequestBody defines body for TorrentsCreateTagsPost for application/x-www-form-urlencoded ContentType.
type TorrentsCreateTagsPostFormdataRequestBody = TorrentsCreateTagsPostRequest

// TorrentsDecreasePrioPostFormdataRequestBody defines body for TorrentsDecreasePrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsDecreasePrioPostFormdataRequestBody = Hashes

// TorrentsDeletePostFormdataRequestBody defines body for TorrentsDeletePost for application/x-www-form-urlencoded ContentType.
type TorrentsDeletePostFormdataRequestBody = TorrentsDeletePostRequest

// TorrentsDeleteTagsPostFormdataRequestBody defines body for TorrentsDeleteTagsPost for application/x-www-form-urlencoded ContentType.
type TorrentsDeleteTagsPostFormdataRequestBody = TorrentsDeleteTagsPostRequest

// TorrentsDownloadLimitPostFormdataRequestBody defines body for TorrentsDownloadLimitPost for application/x-www-form-urlencoded ContentType.
type TorrentsDownloadLimitPostFormdataRequestBody = Hashes

// TorrentsEditCategoryPostFormdataRequestBody defines body for TorrentsEditCategoryPost for application/x-www-form-urlencoded ContentType.
type TorrentsEditCategoryPostFormdataRequestBody = TorrentsCreateCategoryPostRequest

// TorrentsEditTrackerPostFormdataRequestBody defines body for TorrentsEditTrackerPost for application/x-www-form-urlencoded ContentType.
type TorrentsEditTrackerPostFormdataRequestBody = TorrentsEditTrackerPostRequest

// TorrentsFilePrioPostFormdataRequestBody defines body for TorrentsFilePrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsFilePrioPostFormdataRequestBody = TorrentsFilePrioPostRequest

// TorrentsFilesPostFormdataRequestBody defines body for TorrentsFilesPost for application/x-www-form-urlencoded ContentType.
type TorrentsFilesPostFormdataRequestBody = TorrentsFilesPostRequest

// TorrentsIncreasePrioPostFormdataRequestBody defines body for TorrentsIncreasePrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsIncreasePrioPostFormdataRequestBody = Hashes

// TorrentsInfoPostFormdataRequestBody defines body for TorrentsInfoPost for application/x-www-form-urlencoded ContentType.
type TorrentsInfoPostFormdataRequestBody = TorrentsInfoPostRequest

// TorrentsPausePostFormdataRequestBody defines body for TorrentsPausePost for application/x-www-form-urlencoded ContentType.
type TorrentsPausePostFormdataRequestBody = Hashes

// TorrentsPieceHashesPostFormdataRequestBody defines body for TorrentsPieceHashesPost for application/x-www-form-urlencoded ContentType.
type TorrentsPieceHashesPostFormdataRequestBody = TorrentsPieceHashesPostRequest

// TorrentsPieceStatesPostFormdataRequestBody defines body for TorrentsPieceStatesPost for application/x-www-form-urlencoded ContentType.
type TorrentsPieceStatesPostFormdataRequestBody = TorrentsPieceStatesPostRequest

// TorrentsPropertiesPostFormdataRequestBody defines body for TorrentsPropertiesPost for application/x-www-form-urlencoded ContentType.
type TorrentsPropertiesPostFormdataRequestBody = TorrentsPropertiesPostRequest

// TorrentsReannouncePostFormdataRequestBody defines body for TorrentsReannouncePost for application/x-www-form-urlencoded ContentType.
type TorrentsReannouncePostFormdataRequestBody = Hashes

// TorrentsRecheckPostFormdataRequestBody defines body for TorrentsRecheckPost for application/x-www-form-urlencoded ContentType.
type TorrentsRecheckPostFormdataRequestBody = Hashes

// TorrentsRemoveCategoriesPostFormdataRequestBody defines body for TorrentsRemoveCategoriesPost for application/x-www-form-urlencoded ContentType.
type TorrentsRemoveCategoriesPostFormdataRequestBody = TorrentsRemoveCategoriesPostRequest

// TorrentsRemoveTagsPostFormdataRequestBody defines body for TorrentsRemoveTagsPost for application/x-www-form-urlencoded ContentType.
type TorrentsRemoveTagsPostFormdataRequestBody = TorrentsTags

// TorrentsRemoveTrackersPostFormdataRequestBody defines body for TorrentsRemoveTrackersPost for application/x-www-form-urlencoded ContentType.
type TorrentsRemoveTrackersPostFormdataRequestBody = TorrentsRemoveTrackersPostRequest

// TorrentsRenamePostFormdataRequestBody defines body for TorrentsRenamePost for application/x-www-form-urlencoded ContentType.
type TorrentsRenamePostFormdataRequestBody = TorrentsRenamePostRequest

// TorrentsRenameFilePostFormdataRequestBody defines body for TorrentsRenameFilePost for application/x-www-form-urlencoded ContentType.
type TorrentsRenameFilePostFormdataRequestBody = RenameTorrentFiles

// TorrentsRenameFolderPostFormdataRequestBody defines body for TorrentsRenameFolderPost for application/x-www-form-urlencoded ContentType.
type TorrentsRenameFolderPostFormdataRequestBody = RenameTorrentFiles

// TorrentsResumePostFormdataRequestBody defines body for TorrentsResumePost for application/x-www-form-urlencoded ContentType.
type TorrentsResumePostFormdataRequestBody = Hashes

// TorrentsSetAutoManagementPostFormdataRequestBody defines body for TorrentsSetAutoManagementPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetAutoManagementPostFormdataRequestBody = TorrentsSetAutoManagementPostRequest

// TorrentsSetCategoryPostFormdataRequestBody defines body for TorrentsSetCategoryPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetCategoryPostFormdataRequestBody = TorrentsSetCategoryPostRequest

// TorrentsSetDownloadLimitPostFormdataRequestBody defines body for TorrentsSetDownloadLimitPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetDownloadLimitPostFormdataRequestBody = SetTorrentsLimit

// TorrentsSetForceStartPostFormdataRequestBody defines body for TorrentsSetForceStartPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetForceStartPostFormdataRequestBody = SetTorrentsValue

// TorrentsSetLocationPostFormdataRequestBody defines body for TorrentsSetLocationPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetLocationPostFormdataRequestBody = TorrentsSetLocationPostRequest

// TorrentsSetShareLimitsPostFormdataRequestBody defines body for TorrentsSetShareLimitsPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetShareLimitsPostFormdataRequestBody = TorrentsSetShareLimitsPostRequest

// TorrentsSetSuperSeedingPostFormdataRequestBody defines body for TorrentsSetSuperSeedingPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetSuperSeedingPostFormdataRequestBody = SetTorrentsValue

// TorrentsSetUploadLimitPostFormdataRequestBody defines body for TorrentsSetUploadLimitPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetUploadLimitPostFormdataRequestBody = SetTorrentsLimit

// TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody defines body for TorrentsToggleFirstLastPiecePrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody = Hashes

// TorrentsToggleSequentialDownloadPostFormdataRequestBody defines body for TorrentsToggleSequentialDownloadPost for application/x-www-form-urlencoded ContentType.
type TorrentsToggleSequentialDownloadPostFormdataRequestBody = Hashes

// TorrentsTopPrioPostFormdataRequestBody defines body for TorrentsTopPrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsTopPrioPostFormdataRequestBody = Hashes

// TorrentsTrackersPostFormdataRequestBody defines body for TorrentsTrackersPost for application/x-www-form-urlencoded ContentType.
type TorrentsTrackersPostFormdataRequestBody = TorrentsTrackersPostRequest

// TorrentsUploadLimitPostFormdataRequestBody defines body for TorrentsUploadLimitPost for application/x-www-form-urlencoded ContentType.
type TorrentsUploadLimitPostFormdataRequestBody = Hashes

// TorrentWebseedsPostFormdataRequestBody defines body for TorrentWebseedsPost for application/x-www-form-urlencoded ContentType.
type TorrentWebseedsPostFormdataRequestBody = TorrentWebseedsPostRequest

// TransferBanPeersPostFormdataRequestBody defines body for TransferBanPeersPost for application/x-www-form-urlencoded ContentType.
type TransferBanPeersPostFormdataRequestBody = TransferBanPeersPostRequest

// TransferSetDownloadLimitPostFormdataRequestBody defines body for TransferSetDownloadLimitPost for application/x-www-form-urlencoded ContentType.
type TransferSetDownloadLimitPostFormdataRequestBody = TransferSetDownloadLimitPostRequest

// TransferSetUploadLimitPostFormdataRequestBody defines body for TransferSetUploadLimitPost for application/x-www-form-urlencoded ContentType.
type TransferSetUploadLimitPostFormdataRequestBody = TransferSetUploadLimitPostRequest

// Getter for additional properties for Preferences. Returns the specified
// element and whether it was found
func (a Preferences) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Preferences
func (a *Preferences) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Preferences to handle AdditionalProperties
func (a *Preferences) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_trackers"]; found {
		err = json.Unmarshal(raw, &a.AddTrackers)
		if err != nil {
			return fmt.Errorf("error reading 'add_trackers': %w", err)
		}
		delete(object, "add_trackers")
	}

	if raw, found := object["add_trackers_enabled"]; found {
		err = json.Unmarshal(raw, &a.AddTrackersEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'add_trackers_enabled': %w", err)
		}
		delete(object, "add_trackers_enabled")
	}

	if raw, found := object["alt_dl_limit"]; found {
		err = json.Unmarshal(raw, &a.AltDlLimit)
		if err != nil {
			return fmt.Errorf("error reading 'alt_dl_limit': %w", err)
		}
		delete(object, "alt_dl_limit")
	}

	if raw, found := object["alt_up_limit"]; found {
		err = json.Unmarshal(raw, &a.AltUpLimit)
		if err != nil {
			return fmt.Errorf("error reading 'alt_up_limit': %w", err)
		}
		delete(object, "alt_up_limit")
	}

	if raw, found := object["alternative_webui_enabled"]; found {
		err = json.Unmarshal(raw, &a.AlternativeWebuiEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'alternative_webui_enabled': %w", err)
		}
		delete(object, "alternative_webui_enabled")
	}

	if raw, found := object["alternative_webui_path"]; found {
		err = json.Unmarshal(raw, &a.AlternativeWebuiPath)
		if err != nil {
			return fmt.Errorf("error reading 'alternative_webui_path': %w", err)
		}
		delete(object, "alternative_webui_path")
	}

	if raw, found := object["announce_ip"]; found {
		err = json.Unmarshal(raw, &a.AnnounceIp)
		if err != nil {
			return fmt.Errorf("error reading 'announce_ip': %w", err)
		}
		delete(object, "announce_ip")
	}

	if raw, found := object["announce_to_all_tiers"]; found {
		err = json.Unmarshal(raw, &a.AnnounceToAllTiers)
		if err != nil {
			return fmt.Errorf("error reading 'announce_to_all_tiers': %w", err)
		}
		delete(object, "announce_to_all_tiers")
	}

	if raw, found := object["announce_to_all_trackers"]; found {
		err = json.Unmarshal(raw, &a.AnnounceToAllTrackers)
		if err != nil {
			return fmt.Errorf("error reading 'announce_to_all_trackers': %w", err)
		}
		delete(object, "announce_to_all_trackers")
	}

	if raw, found := object["anonymous_mode"]; found {
		err = json.Unmarshal(raw, &a.AnonymousMode)
		if err != nil {
			return fmt.Errorf("error reading 'anonymous_mode': %w", err)
		}
		delete(object, "anonymous_mode")
	}

	if raw, found := object["async_io_threads"]; found {
		err = json.Unmarshal(raw, &a.AsyncIoThreads)
		if err != nil {
			return fmt.Errorf("error reading 'async_io_threads': %w", err)
		}
		delete(object, "async_io_threads")
	}

	if raw, found := object["auto_delete_mode"]; found {
		err = json.Unmarshal(raw, &a.AutoDeleteMode)
		if err != nil {
			return fmt.Errorf("error reading 'auto_delete_mode': %w", err)
		}
		delete(object, "auto_delete_mode")
	}

	if raw, found := object["auto_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.AutoTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'auto_tmm_enabled': %w", err)
		}
		delete(object, "auto_tmm_enabled")
	}

	if raw, found := object["autorun_enabled"]; found {
		err = json.Unmarshal(raw, &a.AutorunEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'autorun_enabled': %w", err)
		}
		delete(object, "autorun_enabled")
	}

	if raw, found := object["autorun_program"]; found {
		err = json.Unmarshal(raw, &a.AutorunProgram)
		if err != nil {
			return fmt.Errorf("error reading 'autorun_program': %w", err)
		}
		delete(object, "autorun_program")
	}

	if raw, found := object["banned_IPs"]; found {
		err = json.Unmarshal(raw, &a.BannedIPs)
		if err != nil {
			return fmt.Errorf("error reading 'banned_IPs': %w", err)
		}
		delete(object, "banned_IPs")
	}

	if raw, found := object["bittorrent_protocol"]; found {
		err = json.Unmarshal(raw, &a.BittorrentProtocol)
		if err != nil {
			return fmt.Errorf("error reading 'bittorrent_protocol': %w", err)
		}
		delete(object, "bittorrent_protocol")
	}

	if raw, found := object["bypass_auth_subnet_whitelist"]; found {
		err = json.Unmarshal(raw, &a.BypassAuthSubnetWhitelist)
		if err != nil {
			return fmt.Errorf("error reading 'bypass_auth_subnet_whitelist': %w", err)
		}
		delete(object, "bypass_auth_subnet_whitelist")
	}

	if raw, found := object["bypass_auth_subnet_whitelist_enabled"]; found {
		err = json.Unmarshal(raw, &a.BypassAuthSubnetWhitelistEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'bypass_auth_subnet_whitelist_enabled': %w", err)
		}
		delete(object, "bypass_auth_subnet_whitelist_enabled")
	}

	if raw, found := object["bypass_local_auth"]; found {
		err = json.Unmarshal(raw, &a.BypassLocalAuth)
		if err != nil {
			return fmt.Errorf("error reading 'bypass_local_auth': %w", err)
		}
		delete(object, "bypass_local_auth")
	}

	if raw, found := object["category_changed_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.CategoryChangedTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'category_changed_tmm_enabled': %w", err)
		}
		delete(object, "category_changed_tmm_enabled")
	}

	if raw, found := object["checking_memory_use"]; found {
		err = json.Unmarshal(raw, &a.CheckingMemoryUse)
		if err != nil {
			return fmt.Errorf("error reading 'checking_memory_use': %w", err)
		}
		delete(object, "checking_memory_use")
	}

	if raw, found := object["create_subfolder_enabled"]; found {
		err = json.Unmarshal(raw, &a.CreateSubfolderEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'create_subfolder_enabled': %w", err)
		}
		delete(object, "create_subfolder_enabled")
	}

	if raw, found := object["current_interface_address"]; found {
		err = json.Unmarshal(raw, &a.CurrentInterfaceAddress)
		if err != nil {
			return fmt.Errorf("error reading 'current_interface_address': %w", err)
		}
		delete(object, "current_interface_address")
	}

	if raw, found := object["current_network_interface"]; found {
		err = json.Unmarshal(raw, &a.CurrentNetworkInterface)
		if err != nil {
			return fmt.Errorf("error reading 'current_network_interface': %w", err)
		}
		delete(object, "current_network_interface")
	}

	if raw, found := object["dht"]; found {
		err = json.Unmarshal(raw, &a.Dht)
		if err != nil {
			return fmt.Errorf("error reading 'dht': %w", err)
		}
		delete(object, "dht")
	}

	if raw, found := object["disk_cache"]; found {
		err = json.Unmarshal(raw, &a.DiskCache)
		if err != nil {
			return fmt.Errorf("error reading 'disk_cache': %w", err)
		}
		delete(object, "disk_cache")
	}

	if raw, found := object["disk_cache_ttl"]; found {
		err = json.Unmarshal(raw, &a.DiskCacheTtl)
		if err != nil {
			return fmt.Errorf("error reading 'disk_cache_ttl': %w", err)
		}
		delete(object, "disk_cache_ttl")
	}

	if raw, found := object["dl_limit"]; found {
		err = json.Unmarshal(raw, &a.DlLimit)
		if err != nil {
			return fmt.Errorf("error reading 'dl_limit': %w", err)
		}
		delete(object, "dl_limit")
	}

	if raw, found := object["dont_count_slow_torrents"]; found {
		err = json.Unmarshal(raw, &a.DontCountSlowTorrents)
		if err != nil {
			return fmt.Errorf("error reading 'dont_count_slow_torrents': %w", err)
		}
		delete(object, "dont_count_slow_torrents")
	}

	if raw, found := object["dyndns_domain"]; found {
		err = json.Unmarshal(raw, &a.DyndnsDomain)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_domain': %w", err)
		}
		delete(object, "dyndns_domain")
	}

	if raw, found := object["dyndns_enabled"]; found {
		err = json.Unmarshal(raw, &a.DyndnsEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_enabled': %w", err)
		}
		delete(object, "dyndns_enabled")
	}

	if raw, found := object["dyndns_password"]; found {
		err = json.Unmarshal(raw, &a.DyndnsPassword)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_password': %w", err)
		}
		delete(object, "dyndns_password")
	}

	if raw, found := object["dyndns_service"]; found {
		err = json.Unmarshal(raw, &a.DyndnsService)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_service': %w", err)
		}
		delete(object, "dyndns_service")
	}

	if raw, found := object["dyndns_username"]; found {
		err = json.Unmarshal(raw, &a.DyndnsUsername)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_username': %w", err)
		}
		delete(object, "dyndns_username")
	}

	if raw, found := object["embedded_tracker_port"]; found {
		err = json.Unmarshal(raw, &a.EmbeddedTrackerPort)
		if err != nil {
			return fmt.Errorf("error reading 'embedded_tracker_port': %w", err)
		}
		delete(object, "embedded_tracker_port")
	}

	if raw, found := object["enable_coalesce_read_write"]; found {
		err = json.Unmarshal(raw, &a.EnableCoalesceReadWrite)
		if err != nil {
			return fmt.Errorf("error reading 'enable_coalesce_read_write': %w", err)
		}
		delete(object, "enable_coalesce_read_write")
	}

	if raw, found := object["enable_embedded_tracker"]; found {
		err = json.Unmarshal(raw, &a.EnableEmbeddedTracker)
		if err != nil {
			return fmt.Errorf("error reading 'enable_embedded_tracker': %w", err)
		}
		delete(object, "enable_embedded_tracker")
	}

	if raw, found := object["enable_multi_connections_from_same_ip"]; found {
		err = json.Unmarshal(raw, &a.EnableMultiConnectionsFromSameIp)
		if err != nil {
			return fmt.Errorf("error reading 'enable_multi_connections_from_same_ip': %w", err)
		}
		delete(object, "enable_multi_connections_from_same_ip")
	}

	if raw, found := object["enable_os_cache"]; found {
		err = json.Unmarshal(raw, &a.EnableOsCache)
		if err != nil {
			return fmt.Errorf("error reading 'enable_os_cache': %w", err)
		}
		delete(object, "enable_os_cache")
	}

	if raw, found := object["enable_piece_extent_affinity"]; found {
		err = json.Unmarshal(raw, &a.EnablePieceExtentAffinity)
		if err != nil {
			return fmt.Errorf("error reading 'enable_piece_extent_affinity': %w", err)
		}
		delete(object, "enable_piece_extent_affinity")
	}

	if raw, found := object["enable_upload_suggestions"]; found {
		err = json.Unmarshal(raw, &a.EnableUploadSuggestions)
		if err != nil {
			return fmt.Errorf("error reading 'enable_upload_suggestions': %w", err)
		}
		delete(object, "enable_upload_suggestions")
	}

	if raw, found := object["encryption"]; found {
		err = json.Unmarshal(raw, &a.Encryption)
		if err != nil {
			return fmt.Errorf("error reading 'encryption': %w", err)
		}
		delete(object, "encryption")
	}

	if raw, found := object["export_dir"]; found {
		err = json.Unmarshal(raw, &a.ExportDir)
		if err != nil {
			return fmt.Errorf("error reading 'export_dir': %w", err)
		}
		delete(object, "export_dir")
	}

	if raw, found := object["export_dir_fin"]; found {
		err = json.Unmarshal(raw, &a.ExportDirFin)
		if err != nil {
			return fmt.Errorf("error reading 'export_dir_fin': %w", err)
		}
		delete(object, "export_dir_fin")
	}

	if raw, found := object["file_pool_size"]; found {
		err = json.Unmarshal(raw, &a.FilePoolSize)
		if err != nil {
			return fmt.Errorf("error reading 'file_pool_size': %w", err)
		}
		delete(object, "file_pool_size")
	}

	if raw, found := object["incomplete_files_ext"]; found {
		err = json.Unmarshal(raw, &a.IncompleteFilesExt)
		if err != nil {
			return fmt.Errorf("error reading 'incomplete_files_ext': %w", err)
		}
		delete(object, "incomplete_files_ext")
	}

	if raw, found := object["ip_filter_enabled"]; found {
		err = json.Unmarshal(raw, &a.IpFilterEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'ip_filter_enabled': %w", err)
		}
		delete(object, "ip_filter_enabled")
	}

	if raw, found := object["ip_filter_path"]; found {
		err = json.Unmarshal(raw, &a.IpFilterPath)
		if err != nil {
			return fmt.Errorf("error reading 'ip_filter_path': %w", err)
		}
		delete(object, "ip_filter_path")
	}

	if raw, found := object["ip_filter_trackers"]; found {
		err = json.Unmarshal(raw, &a.IpFilterTrackers)
		if err != nil {
			return fmt.Errorf("error reading 'ip_filter_trackers': %w", err)
		}
		delete(object, "ip_filter_trackers")
	}

	if raw, found := object["limit_lan_peers"]; found {
		err = json.Unmarshal(raw, &a.LimitLanPeers)
		if err != nil {
			return fmt.Errorf("error reading 'limit_lan_peers': %w", err)
		}
		delete(object, "limit_lan_peers")
	}

	if raw, found := object["limit_tcp_overhead"]; found {
		err = json.Unmarshal(raw, &a.LimitTcpOverhead)
		if err != nil {
			return fmt.Errorf("error reading 'limit_tcp_overhead': %w", err)
		}
		delete(object, "limit_tcp_overhead")
	}

	if raw, found := object["limit_utp_rate"]; found {
		err = json.Unmarshal(raw, &a.LimitUtpRate)
		if err != nil {
			return fmt.Errorf("error reading 'limit_utp_rate': %w", err)
		}
		delete(object, "limit_utp_rate")
	}

	if raw, found := object["listen_port"]; found {
		err = json.Unmarshal(raw, &a.ListenPort)
		if err != nil {
			return fmt.Errorf("error reading 'listen_port': %w", err)
		}
		delete(object, "listen_port")
	}

	if raw, found := object["locale"]; found {
		err = json.Unmarshal(raw, &a.Locale)
		if err != nil {
			return fmt.Errorf("error reading 'locale': %w", err)
		}
		delete(object, "locale")
	}

	if raw, found := object["lsd"]; found {
		err = json.Unmarshal(raw, &a.Lsd)
		if err != nil {
			return fmt.Errorf("error reading 'lsd': %w", err)
		}
		delete(object, "lsd")
	}

	if raw, found := object["mail_notification_auth_enabled"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationAuthEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_auth_enabled': %w", err)
		}
		delete(object, "mail_notification_auth_enabled")
	}

	if raw, found := object["mail_notification_email"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationEmail)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_email': %w", err)
		}
		delete(object, "mail_notification_email")
	}

	if raw, found := object["mail_notification_enabled"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_enabled': %w", err)
		}
		delete(object, "mail_notification_enabled")
	}

	if raw, found := object["mail_notification_password"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationPassword)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_password': %w", err)
		}
		delete(object, "mail_notification_password")
	}

	if raw, found := object["mail_notification_sender"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationSender)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_sender': %w", err)
		}
		delete(object, "mail_notification_sender")
	}

	if raw, found := object["mail_notification_smtp"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationSmtp)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_smtp': %w", err)
		}
		delete(object, "mail_notification_smtp")
	}

	if raw, found := object["mail_notification_ssl_enabled"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationSslEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_ssl_enabled': %w", err)
		}
		delete(object, "mail_notification_ssl_enabled")
	}

	if raw, found := object["mail_notification_username"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationUsername)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_username': %w", err)
		}
		delete(object, "mail_notification_username")
	}

	if raw, found := object["max_active_downloads"]; found {
		err = json.Unmarshal(raw, &a.MaxActiveDownloads)
		if err != nil {
			return fmt.Errorf("error reading 'max_active_downloads': %w", err)
		}
		delete(object, "max_active_downloads")
	}

	if raw, found := object["max_active_torrents"]; found {
		err = json.Unmarshal(raw, &a.MaxActiveTorrents)
		if err != nil {
			return fmt.Errorf("error reading 'max_active_torrents': %w", err)
		}
		delete(object, "max_active_torrents")
	}

	if raw, found := object["max_active_uploads"]; found {
		err = json.Unmarshal(raw, &a.MaxActiveUploads)
		if err != nil {
			return fmt.Errorf("error reading 'max_active_uploads': %w", err)
		}
		delete(object, "max_active_uploads")
	}

	if raw, found := object["max_connec"]; found {
		err = json.Unmarshal(raw, &a.MaxConnec)
		if err != nil {
			return fmt.Errorf("error reading 'max_connec': %w", err)
		}
		delete(object, "max_connec")
	}

	if raw, found := object["max_connec_per_torrent"]; found {
		err = json.Unmarshal(raw, &a.MaxConnecPerTorrent)
		if err != nil {
			return fmt.Errorf("error reading 'max_connec_per_torrent': %w", err)
		}
		delete(object, "max_connec_per_torrent")
	}

	if raw, found := object["max_ratio"]; found {
		err = json.Unmarshal(raw, &a.MaxRatio)
		if err != nil {
			return fmt.Errorf("error reading 'max_ratio': %w", err)
		}
		delete(object, "max_ratio")
	}

	if raw, found := object["max_ratio_act"]; found {
		err = json.Unmarshal(raw, &a.MaxRatioAct)
		if err != nil {
			return fmt.Errorf("error reading 'max_ratio_act': %w", err)
		}
		delete(object, "max_ratio_act")
	}

	if raw, found := object["max_ratio_enabled"]; found {
		err = json.Unmarshal(raw, &a.MaxRatioEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'max_ratio_enabled': %w", err)
		}
		delete(object, "max_ratio_enabled")
	}

	if raw, found := object["max_seeding_time"]; found {
		err = json.Unmarshal(raw, &a.MaxSeedingTime)
		if err != nil {
			return fmt.Errorf("error reading 'max_seeding_time': %w", err)
		}
		delete(object, "max_seeding_time")
	}

	if raw, found := object["max_seeding_time_enabled"]; found {
		err = json.Unmarshal(raw, &a.MaxSeedingTimeEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'max_seeding_time_enabled': %w", err)
		}
		delete(object, "max_seeding_time_enabled")
	}

	if raw, found := object["max_uploads"]; found {
		err = json.Unmarshal(raw, &a.MaxUploads)
		if err != nil {
			return fmt.Errorf("error reading 'max_uploads': %w", err)
		}
		delete(object, "max_uploads")
	}

	if raw, found := object["max_uploads_per_torrent"]; found {
		err = json.Unmarshal(raw, &a.MaxUploadsPerTorrent)
		if err != nil {
			return fmt.Errorf("error reading 'max_uploads_per_torrent': %w", err)
		}
		delete(object, "max_uploads_per_torrent")
	}

	if raw, found := object["outgoing_ports_max"]; found {
		err = json.Unmarshal(raw, &a.OutgoingPortsMax)
		if err != nil {
			return fmt.Errorf("error reading 'outgoing_ports_max': %w", err)
		}
		delete(object, "outgoing_ports_max")
	}

	if raw, found := object["outgoing_ports_min"]; found {
		err = json.Unmarshal(raw, &a.OutgoingPortsMin)
		if err != nil {
			return fmt.Errorf("error reading 'outgoing_ports_min': %w", err)
		}
		delete(object, "outgoing_ports_min")
	}

	if raw, found := object["pex"]; found {
		err = json.Unmarshal(raw, &a.Pex)
		if err != nil {
			return fmt.Errorf("error reading 'pex': %w", err)
		}
		delete(object, "pex")
	}

	if raw, found := object["preallocate_all"]; found {
		err = json.Unmarshal(raw, &a.PreallocateAll)
		if err != nil {
			return fmt.Errorf("error reading 'preallocate_all': %w", err)
		}
		delete(object, "preallocate_all")
	}

	if raw, found := object["proxy_auth_enabled"]; found {
		err = json.Unmarshal(raw, &a.ProxyAuthEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_auth_enabled': %w", err)
		}
		delete(object, "proxy_auth_enabled")
	}

	if raw, found := object["proxy_ip"]; found {
		err = json.Unmarshal(raw, &a.ProxyIp)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_ip': %w", err)
		}
		delete(object, "proxy_ip")
	}

	if raw, found := object["proxy_password"]; found {
		err = json.Unmarshal(raw, &a.ProxyPassword)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_password': %w", err)
		}
		delete(object, "proxy_password")
	}

	if raw, found := object["proxy_peer_connections"]; found {
		err = json.Unmarshal(raw, &a.ProxyPeerConnections)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_peer_connections': %w", err)
		}
		delete(object, "proxy_peer_connections")
	}

	if raw, found := object["proxy_port"]; found {
		err = json.Unmarshal(raw, &a.ProxyPort)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_port': %w", err)
		}
		delete(object, "proxy_port")
	}

	if raw, found := object["proxy_torrents_only"]; found {
		err = json.Unmarshal(raw, &a.ProxyTorrentsOnly)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_torrents_only': %w", err)
		}
		delete(object, "proxy_torrents_only")
	}

	if raw, found := object["proxy_type"]; found {
		err = json.Unmarshal(raw, &a.ProxyType)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_type': %w", err)
		}
		delete(object, "proxy_type")
	}

	if raw, found := object["proxy_username"]; found {
		err = json.Unmarshal(raw, &a.ProxyUsername)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_username': %w", err)
		}
		delete(object, "proxy_username")
	}

	if raw, found := object["queueing_enabled"]; found {
		err = json.Unmarshal(raw, &a.QueueingEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'queueing_enabled': %w", err)
		}
		delete(object, "queueing_enabled")
	}

	if raw, found := object["random_port"]; found {
		err = json.Unmarshal(raw, &a.RandomPort)
		if err != nil {
			return fmt.Errorf("error reading 'random_port': %w", err)
		}
		delete(object, "random_port")
	}

	if raw, found := object["recheck_completed_torrents"]; found {
		err = json.Unmarshal(raw, &a.RecheckCompletedTorrents)
		if err != nil {
			return fmt.Errorf("error reading 'recheck_completed_torrents': %w", err)
		}
		delete(object, "recheck_completed_torrents")
	}

	if raw, found := object["resolve_peer_countries"]; found {
		err = json.Unmarshal(raw, &a.ResolvePeerCountries)
		if err != nil {
			return fmt.Errorf("error reading 'resolve_peer_countries': %w", err)
		}
		delete(object, "resolve_peer_countries")
	}

	if raw, found := object["rss_auto_downloading_enabled"]; found {
		err = json.Unmarshal(raw, &a.RssAutoDownloadingEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'rss_auto_downloading_enabled': %w", err)
		}
		delete(object, "rss_auto_downloading_enabled")
	}

	if raw, found := object["rss_download_repack_proper_episodes"]; found {
		err = json.Unmarshal(raw, &a.RssDownloadRepackProperEpisodes)
		if err != nil {
			return fmt.Errorf("error reading 'rss_download_repack_proper_episodes': %w", err)
		}
		delete(object, "rss_download_repack_proper_episodes")
	}

	if raw, found := object["rss_max_articles_per_feed"]; found {
		err = json.Unmarshal(raw, &a.RssMaxArticlesPerFeed)
		if err != nil {
			return fmt.Errorf("error reading 'rss_max_articles_per_feed': %w", err)
		}
		delete(object, "rss_max_articles_per_feed")
	}

	if raw, found := object["rss_processing_enabled"]; found {
		err = json.Unmarshal(raw, &a.RssProcessingEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'rss_processing_enabled': %w", err)
		}
		delete(object, "rss_processing_enabled")
	}

	if raw, found := object["rss_refresh_interval"]; found {
		err = json.Unmarshal(raw, &a.RssRefreshInterval)
		if err != nil {
			return fmt.Errorf("error reading 'rss_refresh_interval': %w", err)
		}
		delete(object, "rss_refresh_interval")
	}

	if raw, found := object["rss_smart_episode_filters"]; found {
		err = json.Unmarshal(raw, &a.RssSmartEpisodeFilters)
		if err != nil {
			return fmt.Errorf("error reading 'rss_smart_episode_filters': %w", err)
		}
		delete(object, "rss_smart_episode_filters")
	}

	if raw, found := object["save_path"]; found {
		err = json.Unmarshal(raw, &a.SavePath)
		if err != nil {
			return fmt.Errorf("error reading 'save_path': %w", err)
		}
		delete(object, "save_path")
	}

	if raw, found := object["save_path_changed_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.SavePathChangedTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'save_path_changed_tmm_enabled': %w", err)
		}
		delete(object, "save_path_changed_tmm_enabled")
	}

	if raw, found := object["save_resume_data_interval"]; found {
		err = json.Unmarshal(raw, &a.SaveResumeDataInterval)
		if err != nil {
			return fmt.Errorf("error reading 'save_resume_data_interval': %w", err)
		}
		delete(object, "save_resume_data_interval")
	}

	if raw, found := object["scan_dirs"]; found {
		err = json.Unmarshal(raw, &a.ScanDirs)
		if err != nil {
			return fmt.Errorf("error reading 'scan_dirs': %w", err)
		}
		delete(object, "scan_dirs")
	}

	if raw, found := object["schedule_from_hour"]; found {
		err = json.Unmarshal(raw, &a.ScheduleFromHour)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_from_hour': %w", err)
		}
		delete(object, "schedule_from_hour")
	}

	if raw, found := object["schedule_from_min"]; found {
		err = json.Unmarshal(raw, &a.ScheduleFromMin)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_from_min': %w", err)
		}
		delete(object, "schedule_from_min")
	}

	if raw, found := object["schedule_to_hour"]; found {
		err = json.Unmarshal(raw, &a.ScheduleToHour)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_to_hour': %w", err)
		}
		delete(object, "schedule_to_hour")
	}

	if raw, found := object["schedule_to_min"]; found {
		err = json.Unmarshal(raw, &a.ScheduleToMin)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_to_min': %w", err)
		}
		delete(object, "schedule_to_min")
	}

	if raw, found := object["scheduler_days"]; found {
		err = json.Unmarshal(raw, &a.SchedulerDays)
		if err != nil {
			return fmt.Errorf("error reading 'scheduler_days': %w", err)
		}
		delete(object, "scheduler_days")
	}

	if raw, found := object["scheduler_enabled"]; found {
		err = json.Unmarshal(raw, &a.SchedulerEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'scheduler_enabled': %w", err)
		}
		delete(object, "scheduler_enabled")
	}

	if raw, found := object["send_buffer_low_watermark"]; found {
		err = json.Unmarshal(raw, &a.SendBufferLowWatermark)
		if err != nil {
			return fmt.Errorf("error reading 'send_buffer_low_watermark': %w", err)
		}
		delete(object, "send_buffer_low_watermark")
	}

	if raw, found := object["send_buffer_watermark"]; found {
		err = json.Unmarshal(raw, &a.SendBufferWatermark)
		if err != nil {
			return fmt.Errorf("error reading 'send_buffer_watermark': %w", err)
		}
		delete(object, "send_buffer_watermark")
	}

	if raw, found := object["send_buffer_watermark_factor"]; found {
		err = json.Unmarshal(raw, &a.SendBufferWatermarkFactor)
		if err != nil {
			return fmt.Errorf("error reading 'send_buffer_watermark_factor': %w", err)
		}
		delete(object, "send_buffer_watermark_factor")
	}

	if raw, found := object["slow_torrent_dl_rate_threshold"]; found {
		err = json.Unmarshal(raw, &a.SlowTorrentDlRateThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'slow_torrent_dl_rate_threshold': %w", err)
		}
		delete(object, "slow_torrent_dl_rate_threshold")
	}

	if raw, found := object["slow_torrent_inactive_timer"]; found {
		err = json.Unmarshal(raw, &a.SlowTorrentInactiveTimer)
		if err != nil {
			return fmt.Errorf("error reading 'slow_torrent_inactive_timer': %w", err)
		}
		delete(object, "slow_torrent_inactive_timer")
	}

	if raw, found := object["slow_torrent_ul_rate_threshold"]; found {
		err = json.Unmarshal(raw, &a.SlowTorrentUlRateThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'slow_torrent_ul_rate_threshold': %w", err)
		}
		delete(object, "slow_torrent_ul_rate_threshold")
	}

	if raw, found := object["socket_backlog_size"]; found {
		err = json.Unmarshal(raw, &a.SocketBacklogSize)
		if err != nil {
			return fmt.Errorf("error reading 'socket_backlog_size': %w", err)
		}
		delete(object, "socket_backlog_size")
	}

	if raw, found := object["ssl_cert"]; found {
		err = json.Unmarshal(raw, &a.SslCert)
		if err != nil {
			return fmt.Errorf("error reading 'ssl_cert': %w", err)
		}
		delete(object, "ssl_cert")
	}

	if raw, found := object["ssl_key"]; found {
		err = json.Unmarshal(raw, &a.SslKey)
		if err != nil {
			return fmt.Errorf("error reading 'ssl_key': %w", err)
		}
		delete(object, "ssl_key")
	}

	if raw, found := object["start_paused_enabled"]; found {
		err = json.Unmarshal(raw, &a.StartPausedEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'start_paused_enabled': %w", err)
		}
		delete(object, "start_paused_enabled")
	}

	if raw, found := object["stop_tracker_timeout"]; found {
		err = json.Unmarshal(raw, &a.StopTrackerTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'stop_tracker_timeout': %w", err)
		}
		delete(object, "stop_tracker_timeout")
	}

	if raw, found := object["temp_path"]; found {
		err = json.Unmarshal(raw, &a.TempPath)
		if err != nil {
			return fmt.Errorf("error reading 'temp_path': %w", err)
		}
		delete(object, "temp_path")
	}

	if raw, found := object["temp_path_enabled"]; found {
		err = json.Unmarshal(raw, &a.TempPathEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'temp_path_enabled': %w", err)
		}
		delete(object, "temp_path_enabled")
	}

	if raw, found := object["torrent_changed_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.TorrentChangedTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'torrent_changed_tmm_enabled': %w", err)
		}
		delete(object, "torrent_changed_tmm_enabled")
	}

	if raw, found := object["up_limit"]; found {
		err = json.Unmarshal(raw, &a.UpLimit)
		if err != nil {
			return fmt.Errorf("error reading 'up_limit': %w", err)
		}
		delete(object, "up_limit")
	}

	if raw, found := object["upload_choking_algorithm"]; found {
		err = json.Unmarshal(raw, &a.UploadChokingAlgorithm)
		if err != nil {
			return fmt.Errorf("error reading 'upload_choking_algorithm': %w", err)
		}
		delete(object, "upload_choking_algorithm")
	}

	if raw, found := object["upload_slots_behavior"]; found {
		err = json.Unmarshal(raw, &a.UploadSlotsBehavior)
		if err != nil {
			return fmt.Errorf("error reading 'upload_slots_behavior': %w", err)
		}
		delete(object, "upload_slots_behavior")
	}

	if raw, found := object["upnp"]; found {
		err = json.Unmarshal(raw, &a.Upnp)
		if err != nil {
			return fmt.Errorf("error reading 'upnp': %w", err)
		}
		delete(object, "upnp")
	}

	if raw, found := object["upnp_lease_duration"]; found {
		err = json.Unmarshal(raw, &a.UpnpLeaseDuration)
		if err != nil {
			return fmt.Errorf("error reading 'upnp_lease_duration': %w", err)
		}
		delete(object, "upnp_lease_duration")
	}

	if raw, found := object["use_https"]; found {
		err = json.Unmarshal(raw, &a.UseHttps)
		if err != nil {
			return fmt.Errorf("error reading 'use_https': %w", err)
		}
		delete(object, "use_https")
	}

	if raw, found := object["utp_tcp_mixed_mode"]; found {
		err = json.Unmarshal(raw, &a.UtpTcpMixedMode)
		if err != nil {
			return fmt.Errorf("error reading 'utp_tcp_mixed_mode': %w", err)
		}
		delete(object, "utp_tcp_mixed_mode")
	}

	if raw, found := object["web_ui_address"]; found {
		err = json.Unmarshal(raw, &a.WebUiAddress)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_address': %w", err)
		}
		delete(object, "web_ui_address")
	}

	if raw, found := object["web_ui_ban_duration"]; found {
		err = json.Unmarshal(raw, &a.WebUiBanDuration)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_ban_duration': %w", err)
		}
		delete(object, "web_ui_ban_duration")
	}

	if raw, found := object["web_ui_clickjacking_protection_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiClickjackingProtectionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_clickjacking_protection_enabled': %w", err)
		}
		delete(object, "web_ui_clickjacking_protection_enabled")
	}

	if raw, found := object["web_ui_csrf_protection_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiCsrfProtectionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_csrf_protection_enabled': %w", err)
		}
		delete(object, "web_ui_csrf_protection_enabled")
	}

	if raw, found := object["web_ui_custom_http_headers"]; found {
		err = json.Unmarshal(raw, &a.WebUiCustomHttpHeaders)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_custom_http_headers': %w", err)
		}
		delete(object, "web_ui_custom_http_headers")
	}

	if raw, found := object["web_ui_domain_list"]; found {
		err = json.Unmarshal(raw, &a.WebUiDomainList)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_domain_list': %w", err)
		}
		delete(object, "web_ui_domain_list")
	}

	if raw, found := object["web_ui_host_header_validation_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiHostHeaderValidationEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_host_header_validation_enabled': %w", err)
		}
		delete(object, "web_ui_host_header_validation_enabled")
	}

	if raw, found := object["web_ui_https_cert_path"]; found {
		err = json.Unmarshal(raw, &a.WebUiHttpsCertPath)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_https_cert_path': %w", err)
		}
		delete(object, "web_ui_https_cert_path")
	}

	if raw, found := object["web_ui_https_key_path"]; found {
		err = json.Unmarshal(raw, &a.WebUiHttpsKeyPath)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_https_key_path': %w", err)
		}
		delete(object, "web_ui_https_key_path")
	}

	if raw, found := object["web_ui_max_auth_fail_count"]; found {
		err = json.Unmarshal(raw, &a.WebUiMaxAuthFailCount)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_max_auth_fail_count': %w", err)
		}
		delete(object, "web_ui_max_auth_fail_count")
	}

	if raw, found := object["web_ui_port"]; found {
		err = json.Unmarshal(raw, &a.WebUiPort)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_port': %w", err)
		}
		delete(object, "web_ui_port")
	}

	if raw, found := object["web_ui_secure_cookie_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiSecureCookieEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_secure_cookie_enabled': %w", err)
		}
		delete(object, "web_ui_secure_cookie_enabled")
	}

	if raw, found := object["web_ui_session_timeout"]; found {
		err = json.Unmarshal(raw, &a.WebUiSessionTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_session_timeout': %w", err)
		}
		delete(object, "web_ui_session_timeout")
	}

	if raw, found := object["web_ui_upnp"]; found {
		err = json.Unmarshal(raw, &a.WebUiUpnp)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_upnp': %w", err)
		}
		delete(object, "web_ui_upnp")
	}

	if raw, found := object["web_ui_use_custom_http_headers_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiUseCustomHttpHeadersEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_use_custom_http_headers_enabled': %w", err)
		}
		delete(object, "web_ui_use_custom_http_headers_enabled")
	}

	if raw, found := object["web_ui_username"]; found {
		err = json.Unmarshal(raw, &a.WebUiUsername)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_username': %w", err)
		}
		delete(object, "web_ui_username")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Preferences to handle AdditionalProperties
func (a Preferences) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddTrackers != nil {
		object["add_trackers"], err = json.Marshal(a.AddTrackers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_trackers': %w", err)
		}
	}

	if a.AddTrackersEnabled != nil {
		object["add_trackers_enabled"], err = json.Marshal(a.AddTrackersEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_trackers_enabled': %w", err)
		}
	}

	if a.AltDlLimit != nil {
		object["alt_dl_limit"], err = json.Marshal(a.AltDlLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alt_dl_limit': %w", err)
		}
	}

	if a.AltUpLimit != nil {
		object["alt_up_limit"], err = json.Marshal(a.AltUpLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alt_up_limit': %w", err)
		}
	}

	if a.AlternativeWebuiEnabled != nil {
		object["alternative_webui_enabled"], err = json.Marshal(a.AlternativeWebuiEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alternative_webui_enabled': %w", err)
		}
	}

	if a.AlternativeWebuiPath != nil {
		object["alternative_webui_path"], err = json.Marshal(a.AlternativeWebuiPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alternative_webui_path': %w", err)
		}
	}

	if a.AnnounceIp != nil {
		object["announce_ip"], err = json.Marshal(a.AnnounceIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'announce_ip': %w", err)
		}
	}

	if a.AnnounceToAllTiers != nil {
		object["announce_to_all_tiers"], err = json.Marshal(a.AnnounceToAllTiers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'announce_to_all_tiers': %w", err)
		}
	}

	if a.AnnounceToAllTrackers != nil {
		object["announce_to_all_trackers"], err = json.Marshal(a.AnnounceToAllTrackers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'announce_to_all_trackers': %w", err)
		}
	}

	if a.AnonymousMode != nil {
		object["anonymous_mode"], err = json.Marshal(a.AnonymousMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'anonymous_mode': %w", err)
		}
	}

	if a.AsyncIoThreads != nil {
		object["async_io_threads"], err = json.Marshal(a.AsyncIoThreads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'async_io_threads': %w", err)
		}
	}

	if a.AutoDeleteMode != nil {
		object["auto_delete_mode"], err = json.Marshal(a.AutoDeleteMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'auto_delete_mode': %w", err)
		}
	}

	if a.AutoTmmEnabled != nil {
		object["auto_tmm_enabled"], err = json.Marshal(a.AutoTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'auto_tmm_enabled': %w", err)
		}
	}

	if a.AutorunEnabled != nil {
		object["autorun_enabled"], err = json.Marshal(a.AutorunEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'autorun_enabled': %w", err)
		}
	}

	if a.AutorunProgram != nil {
		object["autorun_program"], err = json.Marshal(a.AutorunProgram)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'autorun_program': %w", err)
		}
	}

	if a.BannedIPs != nil {
		object["banned_IPs"], err = json.Marshal(a.BannedIPs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'banned_IPs': %w", err)
		}
	}

	if a.BittorrentProtocol != nil {
		object["bittorrent_protocol"], err = json.Marshal(a.BittorrentProtocol)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bittorrent_protocol': %w", err)
		}
	}

	if a.BypassAuthSubnetWhitelist != nil {
		object["bypass_auth_subnet_whitelist"], err = json.Marshal(a.BypassAuthSubnetWhitelist)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bypass_auth_subnet_whitelist': %w", err)
		}
	}

	if a.BypassAuthSubnetWhitelistEnabled != nil {
		object["bypass_auth_subnet_whitelist_enabled"], err = json.Marshal(a.BypassAuthSubnetWhitelistEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bypass_auth_subnet_whitelist_enabled': %w", err)
		}
	}

	if a.BypassLocalAuth != nil {
		object["bypass_local_auth"], err = json.Marshal(a.BypassLocalAuth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bypass_local_auth': %w", err)
		}
	}

	if a.CategoryChangedTmmEnabled != nil {
		object["category_changed_tmm_enabled"], err = json.Marshal(a.CategoryChangedTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category_changed_tmm_enabled': %w", err)
		}
	}

	if a.CheckingMemoryUse != nil {
		object["checking_memory_use"], err = json.Marshal(a.CheckingMemoryUse)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'checking_memory_use': %w", err)
		}
	}

	if a.CreateSubfolderEnabled != nil {
		object["create_subfolder_enabled"], err = json.Marshal(a.CreateSubfolderEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'create_subfolder_enabled': %w", err)
		}
	}

	if a.CurrentInterfaceAddress != nil {
		object["current_interface_address"], err = json.Marshal(a.CurrentInterfaceAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'current_interface_address': %w", err)
		}
	}

	if a.CurrentNetworkInterface != nil {
		object["current_network_interface"], err = json.Marshal(a.CurrentNetworkInterface)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'current_network_interface': %w", err)
		}
	}

	if a.Dht != nil {
		object["dht"], err = json.Marshal(a.Dht)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dht': %w", err)
		}
	}

	if a.DiskCache != nil {
		object["disk_cache"], err = json.Marshal(a.DiskCache)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disk_cache': %w", err)
		}
	}

	if a.DiskCacheTtl != nil {
		object["disk_cache_ttl"], err = json.Marshal(a.DiskCacheTtl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disk_cache_ttl': %w", err)
		}
	}

	if a.DlLimit != nil {
		object["dl_limit"], err = json.Marshal(a.DlLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dl_limit': %w", err)
		}
	}

	if a.DontCountSlowTorrents != nil {
		object["dont_count_slow_torrents"], err = json.Marshal(a.DontCountSlowTorrents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dont_count_slow_torrents': %w", err)
		}
	}

	if a.DyndnsDomain != nil {
		object["dyndns_domain"], err = json.Marshal(a.DyndnsDomain)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_domain': %w", err)
		}
	}

	if a.DyndnsEnabled != nil {
		object["dyndns_enabled"], err = json.Marshal(a.DyndnsEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_enabled': %w", err)
		}
	}

	if a.DyndnsPassword != nil {
		object["dyndns_password"], err = json.Marshal(a.DyndnsPassword)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_password': %w", err)
		}
	}

	if a.DyndnsService != nil {
		object["dyndns_service"], err = json.Marshal(a.DyndnsService)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_service': %w", err)
		}
	}

	if a.DyndnsUsername != nil {
		object["dyndns_username"], err = json.Marshal(a.DyndnsUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_username': %w", err)
		}
	}

	if a.EmbeddedTrackerPort != nil {
		object["embedded_tracker_port"], err = json.Marshal(a.EmbeddedTrackerPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'embedded_tracker_port': %w", err)
		}
	}

	if a.EnableCoalesceReadWrite != nil {
		object["enable_coalesce_read_write"], err = json.Marshal(a.EnableCoalesceReadWrite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_coalesce_read_write': %w", err)
		}
	}

	if a.EnableEmbeddedTracker != nil {
		object["enable_embedded_tracker"], err = json.Marshal(a.EnableEmbeddedTracker)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_embedded_tracker': %w", err)
		}
	}

	if a.EnableMultiConnectionsFromSameIp != nil {
		object["enable_multi_connections_from_same_ip"], err = json.Marshal(a.EnableMultiConnectionsFromSameIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_multi_connections_from_same_ip': %w", err)
		}
	}

	if a.EnableOsCache != nil {
		object["enable_os_cache"], err = json.Marshal(a.EnableOsCache)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_os_cache': %w", err)
		}
	}

	if a.EnablePieceExtentAffinity != nil {
		object["enable_piece_extent_affinity"], err = json.Marshal(a.EnablePieceExtentAffinity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_piece_extent_affinity': %w", err)
		}
	}

	if a.EnableUploadSuggestions != nil {
		object["enable_upload_suggestions"], err = json.Marshal(a.EnableUploadSuggestions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_upload_suggestions': %w", err)
		}
	}

	if a.Encryption != nil {
		object["encryption"], err = json.Marshal(a.Encryption)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'encryption': %w", err)
		}
	}

	if a.ExportDir != nil {
		object["export_dir"], err = json.Marshal(a.ExportDir)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'export_dir': %w", err)
		}
	}

	if a.ExportDirFin != nil {
		object["export_dir_fin"], err = json.Marshal(a.ExportDirFin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'export_dir_fin': %w", err)
		}
	}

	if a.FilePoolSize != nil {
		object["file_pool_size"], err = json.Marshal(a.FilePoolSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'file_pool_size': %w", err)
		}
	}

	if a.IncompleteFilesExt != nil {
		object["incomplete_files_ext"], err = json.Marshal(a.IncompleteFilesExt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'incomplete_files_ext': %w", err)
		}
	}

	if a.IpFilterEnabled != nil {
		object["ip_filter_enabled"], err = json.Marshal(a.IpFilterEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ip_filter_enabled': %w", err)
		}
	}

	if a.IpFilterPath != nil {
		object["ip_filter_path"], err = json.Marshal(a.IpFilterPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ip_filter_path': %w", err)
		}
	}

	if a.IpFilterTrackers != nil {
		object["ip_filter_trackers"], err = json.Marshal(a.IpFilterTrackers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ip_filter_trackers': %w", err)
		}
	}

	if a.LimitLanPeers != nil {
		object["limit_lan_peers"], err = json.Marshal(a.LimitLanPeers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit_lan_peers': %w", err)
		}
	}

	if a.LimitTcpOverhead != nil {
		object["limit_tcp_overhead"], err = json.Marshal(a.LimitTcpOverhead)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit_tcp_overhead': %w", err)
		}
	}

	if a.LimitUtpRate != nil {
		object["limit_utp_rate"], err = json.Marshal(a.LimitUtpRate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit_utp_rate': %w", err)
		}
	}

	if a.ListenPort != nil {
		object["listen_port"], err = json.Marshal(a.ListenPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'listen_port': %w", err)
		}
	}

	if a.Locale != nil {
		object["locale"], err = json.Marshal(a.Locale)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'locale': %w", err)
		}
	}

	if a.Lsd != nil {
		object["lsd"], err = json.Marshal(a.Lsd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lsd': %w", err)
		}
	}

	if a.MailNotificationAuthEnabled != nil {
		object["mail_notification_auth_enabled"], err = json.Marshal(a.MailNotificationAuthEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_auth_enabled': %w", err)
		}
	}

	if a.MailNotificationEmail != nil {
		object["mail_notification_email"], err = json.Marshal(a.MailNotificationEmail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_email': %w", err)
		}
	}

	if a.MailNotificationEnabled != nil {
		object["mail_notification_enabled"], err = json.Marshal(a.MailNotificationEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_enabled': %w", err)
		}
	}

	if a.MailNotificationPassword != nil {
		object["mail_notification_password"], err = json.Marshal(a.MailNotificationPassword)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_password': %w", err)
		}
	}

	if a.MailNotificationSender != nil {
		object["mail_notification_sender"], err = json.Marshal(a.MailNotificationSender)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_sender': %w", err)
		}
	}

	if a.MailNotificationSmtp != nil {
		object["mail_notification_smtp"], err = json.Marshal(a.MailNotificationSmtp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_smtp': %w", err)
		}
	}

	if a.MailNotificationSslEnabled != nil {
		object["mail_notification_ssl_enabled"], err = json.Marshal(a.MailNotificationSslEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_ssl_enabled': %w", err)
		}
	}

	if a.MailNotificationUsername != nil {
		object["mail_notification_username"], err = json.Marshal(a.MailNotificationUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_username': %w", err)
		}
	}

	if a.MaxActiveDownloads != nil {
		object["max_active_downloads"], err = json.Marshal(a.MaxActiveDownloads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_active_downloads': %w", err)
		}
	}

	if a.MaxActiveTorrents != nil {
		object["max_active_torrents"], err = json.Marshal(a.MaxActiveTorrents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_active_torrents': %w", err)
		}
	}

	if a.MaxActiveUploads != nil {
		object["max_active_uploads"], err = json.Marshal(a.MaxActiveUploads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_active_uploads': %w", err)
		}
	}

	if a.MaxConnec != nil {
		object["max_connec"], err = json.Marshal(a.MaxConnec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_connec': %w", err)
		}
	}

	if a.MaxConnecPerTorrent != nil {
		object["max_connec_per_torrent"], err = json.Marshal(a.MaxConnecPerTorrent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_connec_per_torrent': %w", err)
		}
	}

	if a.MaxRatio != nil {
		object["max_ratio"], err = json.Marshal(a.MaxRatio)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_ratio': %w", err)
		}
	}

	if a.MaxRatioAct != nil {
		object["max_ratio_act"], err = json.Marshal(a.MaxRatioAct)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_ratio_act': %w", err)
		}
	}

	if a.MaxRatioEnabled != nil {
		object["max_ratio_enabled"], err = json.Marshal(a.MaxRatioEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_ratio_enabled': %w", err)
		}
	}

	if a.MaxSeedingTime != nil {
		object["max_seeding_time"], err = json.Marshal(a.MaxSeedingTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_seeding_time': %w", err)
		}
	}

	if a.MaxSeedingTimeEnabled != nil {
		object["max_seeding_time_enabled"], err = json.Marshal(a.MaxSeedingTimeEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_seeding_time_enabled': %w", err)
		}
	}

	if a.MaxUploads != nil {
		object["max_uploads"], err = json.Marshal(a.MaxUploads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_uploads': %w", err)
		}
	}

	if a.MaxUploadsPerTorrent != nil {
		object["max_uploads_per_torrent"], err = json.Marshal(a.MaxUploadsPerTorrent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_uploads_per_torrent': %w", err)
		}
	}

	if a.OutgoingPortsMax != nil {
		object["outgoing_ports_max"], err = json.Marshal(a.OutgoingPortsMax)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outgoing_ports_max': %w", err)
		}
	}

	if a.OutgoingPortsMin != nil {
		object["outgoing_ports_min"], err = json.Marshal(a.OutgoingPortsMin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outgoing_ports_min': %w", err)
		}
	}

	if a.Pex != nil {
		object["pex"], err = json.Marshal(a.Pex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pex': %w", err)
		}
	}

	if a.PreallocateAll != nil {
		object["preallocate_all"], err = json.Marshal(a.PreallocateAll)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preallocate_all': %w", err)
		}
	}

	if a.ProxyAuthEnabled != nil {
		object["proxy_auth_enabled"], err = json.Marshal(a.ProxyAuthEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_auth_enabled': %w", err)
		}
	}

	if a.ProxyIp != nil {
		object["proxy_ip"], err = json.Marshal(a.ProxyIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_ip': %w", err)
		}
	}

	if a.ProxyPassword != nil {
		object["proxy_password"], err = json.Marshal(a.ProxyPassword)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_password': %w", err)
		}
	}

	if a.ProxyPeerConnections != nil {
		object["proxy_peer_connections"], err = json.Marshal(a.ProxyPeerConnections)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_peer_connections': %w", err)
		}
	}

	if a.ProxyPort != nil {
		object["proxy_port"], err = json.Marshal(a.ProxyPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_port': %w", err)
		}
	}

	if a.ProxyTorrentsOnly != nil {
		object["proxy_torrents_only"], err = json.Marshal(a.ProxyTorrentsOnly)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_torrents_only': %w", err)
		}
	}

	if a.ProxyType != nil {
		object["proxy_type"], err = json.Marshal(a.ProxyType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_type': %w", err)
		}
	}

	if a.ProxyUsername != nil {
		object["proxy_username"], err = json.Marshal(a.ProxyUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_username': %w", err)
		}
	}

	if a.QueueingEnabled != nil {
		object["queueing_enabled"], err = json.Marshal(a.QueueingEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'queueing_enabled': %w", err)
		}
	}

	if a.RandomPort != nil {
		object["random_port"], err = json.Marshal(a.RandomPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'random_port': %w", err)
		}
	}

	if a.RecheckCompletedTorrents != nil {
		object["recheck_completed_torrents"], err = json.Marshal(a.RecheckCompletedTorrents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recheck_completed_torrents': %w", err)
		}
	}

	if a.ResolvePeerCountries != nil {
		object["resolve_peer_countries"], err = json.Marshal(a.ResolvePeerCountries)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'resolve_peer_countries': %w", err)
		}
	}

	if a.RssAutoDownloadingEnabled != nil {
		object["rss_auto_downloading_enabled"], err = json.Marshal(a.RssAutoDownloadingEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_auto_downloading_enabled': %w", err)
		}
	}

	if a.RssDownloadRepackProperEpisodes != nil {
		object["rss_download_repack_proper_episodes"], err = json.Marshal(a.RssDownloadRepackProperEpisodes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_download_repack_proper_episodes': %w", err)
		}
	}

	if a.RssMaxArticlesPerFeed != nil {
		object["rss_max_articles_per_feed"], err = json.Marshal(a.RssMaxArticlesPerFeed)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_max_articles_per_feed': %w", err)
		}
	}

	if a.RssProcessingEnabled != nil {
		object["rss_processing_enabled"], err = json.Marshal(a.RssProcessingEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_processing_enabled': %w", err)
		}
	}

	if a.RssRefreshInterval != nil {
		object["rss_refresh_interval"], err = json.Marshal(a.RssRefreshInterval)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_refresh_interval': %w", err)
		}
	}

	if a.RssSmartEpisodeFilters != nil {
		object["rss_smart_episode_filters"], err = json.Marshal(a.RssSmartEpisodeFilters)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_smart_episode_filters': %w", err)
		}
	}

	if a.SavePath != nil {
		object["save_path"], err = json.Marshal(a.SavePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'save_path': %w", err)
		}
	}

	if a.SavePathChangedTmmEnabled != nil {
		object["save_path_changed_tmm_enabled"], err = json.Marshal(a.SavePathChangedTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'save_path_changed_tmm_enabled': %w", err)
		}
	}

	if a.SaveResumeDataInterval != nil {
		object["save_resume_data_interval"], err = json.Marshal(a.SaveResumeDataInterval)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'save_resume_data_interval': %w", err)
		}
	}

	if a.ScanDirs != nil {
		object["scan_dirs"], err = json.Marshal(a.ScanDirs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scan_dirs': %w", err)
		}
	}

	if a.ScheduleFromHour != nil {
		object["schedule_from_hour"], err = json.Marshal(a.ScheduleFromHour)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_from_hour': %w", err)
		}
	}

	if a.ScheduleFromMin != nil {
		object["schedule_from_min"], err = json.Marshal(a.ScheduleFromMin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_from_min': %w", err)
		}
	}

	if a.ScheduleToHour != nil {
		object["schedule_to_hour"], err = json.Marshal(a.ScheduleToHour)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_to_hour': %w", err)
		}
	}

	if a.ScheduleToMin != nil {
		object["schedule_to_min"], err = json.Marshal(a.ScheduleToMin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_to_min': %w", err)
		}
	}

	if a.SchedulerDays != nil {
		object["scheduler_days"], err = json.Marshal(a.SchedulerDays)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scheduler_days': %w", err)
		}
	}

	if a.SchedulerEnabled != nil {
		object["scheduler_enabled"], err = json.Marshal(a.SchedulerEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scheduler_enabled': %w", err)
		}
	}

	if a.SendBufferLowWatermark != nil {
		object["send_buffer_low_watermark"], err = json.Marshal(a.SendBufferLowWatermark)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'send_buffer_low_watermark': %w", err)
		}
	}

	if a.SendBufferWatermark != nil {
		object["send_buffer_watermark"], err = json.Marshal(a.SendBufferWatermark)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'send_buffer_watermark': %w", err)
		}
	}

	if a.SendBufferWatermarkFactor != nil {
		object["send_buffer_watermark_factor"], err = json.Marshal(a.SendBufferWatermarkFactor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'send_buffer_watermark_factor': %w", err)
		}
	}

	if a.SlowTorrentDlRateThreshold != nil {
		object["slow_torrent_dl_rate_threshold"], err = json.Marshal(a.SlowTorrentDlRateThreshold)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'slow_torrent_dl_rate_threshold': %w", err)
		}
	}

	if a.SlowTorrentInactiveTimer != nil {
		object["slow_torrent_inactive_timer"], err = json.Marshal(a.SlowTorrentInactiveTimer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'slow_torrent_inactive_timer': %w", err)
		}
	}

	if a.SlowTorrentUlRateThreshold != nil {
		object["slow_torrent_ul_rate_threshold"], err = json.Marshal(a.SlowTorrentUlRateThreshold)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'slow_torrent_ul_rate_threshold': %w", err)
		}
	}

	if a.SocketBacklogSize != nil {
		object["socket_backlog_size"], err = json.Marshal(a.SocketBacklogSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'socket_backlog_size': %w", err)
		}
	}

	if a.SslCert != nil {
		object["ssl_cert"], err = json.Marshal(a.SslCert)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl_cert': %w", err)
		}
	}

	if a.SslKey != nil {
		object["ssl_key"], err = json.Marshal(a.SslKey)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl_key': %w", err)
		}
	}

	if a.StartPausedEnabled != nil {
		object["start_paused_enabled"], err = json.Marshal(a.StartPausedEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start_paused_enabled': %w", err)
		}
	}

	if a.StopTrackerTimeout != nil {
		object["stop_tracker_timeout"], err = json.Marshal(a.StopTrackerTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stop_tracker_timeout': %w", err)
		}
	}

	if a.TempPath != nil {
		object["temp_path"], err = json.Marshal(a.TempPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'temp_path': %w", err)
		}
	}

	if a.TempPathEnabled != nil {
		object["temp_path_enabled"], err = json.Marshal(a.TempPathEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'temp_path_enabled': %w", err)
		}
	}

	if a.TorrentChangedTmmEnabled != nil {
		object["torrent_changed_tmm_enabled"], err = json.Marshal(a.TorrentChangedTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'torrent_changed_tmm_enabled': %w", err)
		}
	}

	if a.UpLimit != nil {
		object["up_limit"], err = json.Marshal(a.UpLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'up_limit': %w", err)
		}
	}

	if a.UploadChokingAlgorithm != nil {
		object["upload_choking_algorithm"], err = json.Marshal(a.UploadChokingAlgorithm)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upload_choking_algorithm': %w", err)
		}
	}

	if a.UploadSlotsBehavior != nil {
		object["upload_slots_behavior"], err = json.Marshal(a.UploadSlotsBehavior)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upload_slots_behavior': %w", err)
		}
	}

	if a.Upnp != nil {
		object["upnp"], err = json.Marshal(a.Upnp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upnp': %w", err)
		}
	}

	if a.UpnpLeaseDuration != nil {
		object["upnp_lease_duration"], err = json.Marshal(a.UpnpLeaseDuration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upnp_lease_duration': %w", err)
		}
	}

	if a.UseHttps != nil {
		object["use_https"], err = json.Marshal(a.UseHttps)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'use_https': %w", err)
		}
	}

	if a.UtpTcpMixedMode != nil {
		object["utp_tcp_mixed_mode"], err = json.Marshal(a.UtpTcpMixedMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'utp_tcp_mixed_mode': %w", err)
		}
	}

	if a.WebUiAddress != nil {
		object["web_ui_address"], err = json.Marshal(a.WebUiAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_address': %w", err)
		}
	}

	if a.WebUiBanDuration != nil {
		object["web_ui_ban_duration"], err = json.Marshal(a.WebUiBanDuration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_ban_duration': %w", err)
		}
	}

	if a.WebUiClickjackingProtectionEnabled != nil {
		object["web_ui_clickjacking_protection_enabled"], err = json.Marshal(a.WebUiClickjackingProtectionEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_clickjacking_protection_enabled': %w", err)
		}
	}

	if a.WebUiCsrfProtectionEnabled != nil {
		object["web_ui_csrf_protection_enabled"], err = json.Marshal(a.WebUiCsrfProtectionEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_csrf_protection_enabled': %w", err)
		}
	}

	if a.WebUiCustomHttpHeaders != nil {
		object["web_ui_custom_http_headers"], err = json.Marshal(a.WebUiCustomHttpHeaders)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_custom_http_headers': %w", err)
		}
	}

	if a.WebUiDomainList != nil {
		object["web_ui_domain_list"], err = json.Marshal(a.WebUiDomainList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_domain_list': %w", err)
		}
	}

	if a.WebUiHostHeaderValidationEnabled != nil {
		object["web_ui_host_header_validation_enabled"], err = json.Marshal(a.WebUiHostHeaderValidationEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_host_header_validation_enabled': %w", err)
		}
	}

	if a.WebUiHttpsCertPath != nil {
		object["web_ui_https_cert_path"], err = json.Marshal(a.WebUiHttpsCertPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_https_cert_path': %w", err)
		}
	}

	if a.WebUiHttpsKeyPath != nil {
		object["web_ui_https_key_path"], err = json.Marshal(a.WebUiHttpsKeyPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_https_key_path': %w", err)
		}
	}

	if a.WebUiMaxAuthFailCount != nil {
		object["web_ui_max_auth_fail_count"], err = json.Marshal(a.WebUiMaxAuthFailCount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_max_auth_fail_count': %w", err)
		}
	}

	if a.WebUiPort != nil {
		object["web_ui_port"], err = json.Marshal(a.WebUiPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_port': %w", err)
		}
	}

	if a.WebUiSecureCookieEnabled != nil {
		object["web_ui_secure_cookie_enabled"], err = json.Marshal(a.WebUiSecureCookieEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_secure_cookie_enabled': %w", err)
		}
	}

	if a.WebUiSessionTimeout != nil {
		object["web_ui_session_timeout"], err = json.Marshal(a.WebUiSessionTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_session_timeout': %w", err)
		}
	}

	if a.WebUiUpnp != nil {
		object["web_ui_upnp"], err = json.Marshal(a.WebUiUpnp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_upnp': %w", err)
		}
	}

	if a.WebUiUseCustomHttpHeadersEnabled != nil {
		object["web_ui_use_custom_http_headers_enabled"], err = json.Marshal(a.WebUiUseCustomHttpHeadersEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_use_custom_http_headers_enabled': %w", err)
		}
	}

	if a.WebUiUsername != nil {
		object["web_ui_username"], err = json.Marshal(a.WebUiUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_username': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsPreferencesScanDirsValue0 returns the union data inside the PreferencesScanDirsValue as a PreferencesScanDirsValue0
func (t PreferencesScanDirsValue) AsPreferencesScanDirsValue0() (PreferencesScanDirsValue0, error) {
	var body PreferencesScanDirsValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreferencesScanDirsValue0 overwrites any union data inside the PreferencesScanDirsValue as the provided PreferencesScanDirsValue0
func (t *PreferencesScanDirsValue) FromPreferencesScanDirsValue0(v PreferencesScanDirsValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreferencesScanDirsValue0 performs a merge with any union data inside the PreferencesScanDirsValue, using the provided PreferencesScanDirsValue0
func (t *PreferencesScanDirsValue) MergePreferencesScanDirsValue0(v PreferencesScanDirsValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPreferencesScanDirsValue1 returns the union data inside the PreferencesScanDirsValue as a PreferencesScanDirsValue1
func (t PreferencesScanDirsValue) AsPreferencesScanDirsValue1() (PreferencesScanDirsValue1, error) {
	var body PreferencesScanDirsValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreferencesScanDirsValue1 overwrites any union data inside the PreferencesScanDirsValue as the provided PreferencesScanDirsValue1
func (t *PreferencesScanDirsValue) FromPreferencesScanDirsValue1(v PreferencesScanDirsValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreferencesScanDirsValue1 performs a merge with any union data inside the PreferencesScanDirsValue, using the provided PreferencesScanDirsValue1
func (t *PreferencesScanDirsValue) MergePreferencesScanDirsValue1(v PreferencesScanDirsValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PreferencesScanDirsValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PreferencesScanDirsValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAddTorrentsURLs returns the union data inside the TorrentsAddPostRequest as a AddTorrentsURLs
func (t TorrentsAddPostRequest) AsAddTorrentsURLs() (AddTorrentsURLs, error) {
	var body AddTorrentsURLs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddTorrentsURLs overwrites any union data inside the TorrentsAddPostRequest as the provided AddTorrentsURLs
func (t *TorrentsAddPostRequest) FromAddTorrentsURLs(v AddTorrentsURLs) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddTorrentsURLs performs a merge with any union data inside the TorrentsAddPostRequest, using the provided AddTorrentsURLs
func (t *TorrentsAddPostRequest) MergeAddTorrentsURLs(v AddTorrentsURLs) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAddTorrentsFiles returns the union data inside the TorrentsAddPostRequest as a AddTorrentsFiles
func (t TorrentsAddPostRequest) AsAddTorrentsFiles() (AddTorrentsFiles, error) {
	var body AddTorrentsFiles
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddTorrentsFiles overwrites any union data inside the TorrentsAddPostRequest as the provided AddTorrentsFiles
func (t *TorrentsAddPostRequest) FromAddTorrentsFiles(v AddTorrentsFiles) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddTorrentsFiles performs a merge with any union data inside the TorrentsAddPostRequest, using the provided AddTorrentsFiles
func (t *TorrentsAddPostRequest) MergeAddTorrentsFiles(v AddTorrentsFiles) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t TorrentsAddPostRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TorrentsAddPostRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AppBuildInfoGet request
	AppBuildInfoGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppDefaultSavePathGet request
	AppDefaultSavePathGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppPreferencesGet request
	AppPreferencesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppSetPreferencesPost request with any body
	AppSetPreferencesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppSetPreferencesPostWithFormdataBody(ctx context.Context, body AppSetPreferencesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppShutdownGet request
	AppShutdownGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppVersionGet request
	AppVersionGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppWebapiVersionGet request
	AppWebapiVersionGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLoginPost request with any body
	AuthLoginPostWithBody(ctx context.Context, params *AuthLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthLoginPostWithFormdataBody(ctx context.Context, params *AuthLoginPostParams, body AuthLoginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLogoutPost request
	AuthLogoutPost(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogMainPost request with any body
	LogMainPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LogMainPostWithFormdataBody(ctx context.Context, body LogMainPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogPeersPost request with any body
	LogPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LogPeersPostWithFormdataBody(ctx context.Context, body LogPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssAddFeedPost request with any body
	RssAddFeedPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssAddFeedPostWithFormdataBody(ctx context.Context, body RssAddFeedPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssAddFolderPost request with any body
	RssAddFolderPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssAddFolderPostWithFormdataBody(ctx context.Context, body RssAddFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssItemsPost request with any body
	RssItemsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssItemsPostWithFormdataBody(ctx context.Context, body RssItemsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssMarkAsReadPost request with any body
	RssMarkAsReadPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssMarkAsReadPostWithFormdataBody(ctx context.Context, body RssMarkAsReadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssMatchingArticlesPost request with any body
	RssMatchingArticlesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssMatchingArticlesPostWithFormdataBody(ctx context.Context, body RssMatchingArticlesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssMoveItemPost request with any body
	RssMoveItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssMoveItemPostWithFormdataBody(ctx context.Context, body RssMoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssRefreshItemPost request with any body
	RssRefreshItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssRefreshItemPostWithFormdataBody(ctx context.Context, body RssRefreshItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssRemoveItemPost request with any body
	RssRemoveItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssRemoveItemPostWithFormdataBody(ctx context.Context, body RssRemoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssRemoveRulePost request with any body
	RssRemoveRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssRemoveRulePostWithFormdataBody(ctx context.Context, body RssRemoveRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssRenameRulePost request with any body
	RssRenameRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssRenameRulePostWithFormdataBody(ctx context.Context, body RssRenameRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssRulesGet request
	RssRulesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssSetRulePost request with any body
	RssSetRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssSetRulePostWithFormdataBody(ctx context.Context, body RssSetRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDeletePost request with any body
	SearchDeletePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDeletePostWithFormdataBody(ctx context.Context, body SearchDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchEnablePluginPost request with any body
	SearchEnablePluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchEnablePluginPostWithFormdataBody(ctx context.Context, body SearchEnablePluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchInstallPluginPost request with any body
	SearchInstallPluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchInstallPluginPostWithFormdataBody(ctx context.Context, body SearchInstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPluginsGet request
	SearchPluginsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchResultsPost request with any body
	SearchResultsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchResultsPostWithFormdataBody(ctx context.Context, body SearchResultsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchStartPost request with any body
	SearchStartPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchStartPostWithFormdataBody(ctx context.Context, body SearchStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchStatusPost request with any body
	SearchStatusPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchStatusPostWithFormdataBody(ctx context.Context, body SearchStatusPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchStopPost request with any body
	SearchStopPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchStopPostWithFormdataBody(ctx context.Context, body SearchStopPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUninstallPluginPost request with any body
	SearchUninstallPluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUninstallPluginPostWithFormdataBody(ctx context.Context, body SearchUninstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUpdatePluginsPost request
	SearchUpdatePluginsPost(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncMaindataPost request with any body
	SyncMaindataPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncMaindataPostWithFormdataBody(ctx context.Context, body SyncMaindataPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncTorrentPeersPost request with any body
	SyncTorrentPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncTorrentPeersPostWithFormdataBody(ctx context.Context, body SyncTorrentPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsAddPost request with any body
	TorrentsAddPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsAddPeersPost request with any body
	TorrentsAddPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsAddPeersPostWithFormdataBody(ctx context.Context, body TorrentsAddPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsAddTagsPost request with any body
	TorrentsAddTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsAddTagsPostWithFormdataBody(ctx context.Context, body TorrentsAddTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsAddTrackersPost request with any body
	TorrentsAddTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsAddTrackersPostWithFormdataBody(ctx context.Context, body TorrentsAddTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsBottomPrioPost request with any body
	TorrentsBottomPrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsBottomPrioPostWithFormdataBody(ctx context.Context, body TorrentsBottomPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsCategoriesGet request
	TorrentsCategoriesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsCreateCategoryPost request with any body
	TorrentsCreateCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsCreateCategoryPostWithFormdataBody(ctx context.Context, body TorrentsCreateCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsCreateTagsPost request with any body
	TorrentsCreateTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsCreateTagsPostWithFormdataBody(ctx context.Context, body TorrentsCreateTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsDecreasePrioPost request with any body
	TorrentsDecreasePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsDecreasePrioPostWithFormdataBody(ctx context.Context, body TorrentsDecreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsDeletePost request with any body
	TorrentsDeletePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsDeletePostWithFormdataBody(ctx context.Context, body TorrentsDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsDeleteTagsPost request with any body
	TorrentsDeleteTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsDeleteTagsPostWithFormdataBody(ctx context.Context, body TorrentsDeleteTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsDownloadLimitPost request with any body
	TorrentsDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsDownloadLimitPostWithFormdataBody(ctx context.Context, body TorrentsDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsEditCategoryPost request with any body
	TorrentsEditCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsEditCategoryPostWithFormdataBody(ctx context.Context, body TorrentsEditCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsEditTrackerPost request with any body
	TorrentsEditTrackerPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsEditTrackerPostWithFormdataBody(ctx context.Context, body TorrentsEditTrackerPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsFilePrioPost request with any body
	TorrentsFilePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsFilePrioPostWithFormdataBody(ctx context.Context, body TorrentsFilePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsFilesPost request with any body
	TorrentsFilesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsFilesPostWithFormdataBody(ctx context.Context, body TorrentsFilesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsIncreasePrioPost request with any body
	TorrentsIncreasePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsIncreasePrioPostWithFormdataBody(ctx context.Context, body TorrentsIncreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsInfoPost request with any body
	TorrentsInfoPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsInfoPostWithFormdataBody(ctx context.Context, body TorrentsInfoPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsPausePost request with any body
	TorrentsPausePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsPausePostWithFormdataBody(ctx context.Context, body TorrentsPausePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsPieceHashesPost request with any body
	TorrentsPieceHashesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsPieceHashesPostWithFormdataBody(ctx context.Context, body TorrentsPieceHashesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsPieceStatesPost request with any body
	TorrentsPieceStatesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsPieceStatesPostWithFormdataBody(ctx context.Context, body TorrentsPieceStatesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsPropertiesPost request with any body
	TorrentsPropertiesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsPropertiesPostWithFormdataBody(ctx context.Context, body TorrentsPropertiesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsReannouncePost request with any body
	TorrentsReannouncePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsReannouncePostWithFormdataBody(ctx context.Context, body TorrentsReannouncePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRecheckPost request with any body
	TorrentsRecheckPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRecheckPostWithFormdataBody(ctx context.Context, body TorrentsRecheckPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRemoveCategoriesPost request with any body
	TorrentsRemoveCategoriesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRemoveCategoriesPostWithFormdataBody(ctx context.Context, body TorrentsRemoveCategoriesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRemoveTagsPost request with any body
	TorrentsRemoveTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRemoveTagsPostWithFormdataBody(ctx context.Context, body TorrentsRemoveTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRemoveTrackersPost request with any body
	TorrentsRemoveTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRemoveTrackersPostWithFormdataBody(ctx context.Context, body TorrentsRemoveTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRenamePost request with any body
	TorrentsRenamePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRenamePostWithFormdataBody(ctx context.Context, body TorrentsRenamePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRenameFilePost request with any body
	TorrentsRenameFilePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRenameFilePostWithFormdataBody(ctx context.Context, body TorrentsRenameFilePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRenameFolderPost request with any body
	TorrentsRenameFolderPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRenameFolderPostWithFormdataBody(ctx context.Context, body TorrentsRenameFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsResumePost request with any body
	TorrentsResumePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsResumePostWithFormdataBody(ctx context.Context, body TorrentsResumePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetAutoManagementPost request with any body
	TorrentsSetAutoManagementPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetAutoManagementPostWithFormdataBody(ctx context.Context, body TorrentsSetAutoManagementPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetCategoryPost request with any body
	TorrentsSetCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetCategoryPostWithFormdataBody(ctx context.Context, body TorrentsSetCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetDownloadLimitPost request with any body
	TorrentsSetDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetDownloadLimitPostWithFormdataBody(ctx context.Context, body TorrentsSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetForceStartPost request with any body
	TorrentsSetForceStartPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetForceStartPostWithFormdataBody(ctx context.Context, body TorrentsSetForceStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetLocationPost request with any body
	TorrentsSetLocationPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetLocationPostWithFormdataBody(ctx context.Context, body TorrentsSetLocationPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetShareLimitsPost request with any body
	TorrentsSetShareLimitsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetShareLimitsPostWithFormdataBody(ctx context.Context, body TorrentsSetShareLimitsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetSuperSeedingPost request with any body
	TorrentsSetSuperSeedingPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetSuperSeedingPostWithFormdataBody(ctx context.Context, body TorrentsSetSuperSeedingPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetUploadLimitPost request with any body
	TorrentsSetUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetUploadLimitPostWithFormdataBody(ctx context.Context, body TorrentsSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsTagsGet request
	TorrentsTagsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsToggleFirstLastPiecePrioPost request with any body
	TorrentsToggleFirstLastPiecePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsToggleFirstLastPiecePrioPostWithFormdataBody(ctx context.Context, body TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsToggleSequentialDownloadPost request with any body
	TorrentsToggleSequentialDownloadPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsToggleSequentialDownloadPostWithFormdataBody(ctx context.Context, body TorrentsToggleSequentialDownloadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsTopPrioPost request with any body
	TorrentsTopPrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsTopPrioPostWithFormdataBody(ctx context.Context, body TorrentsTopPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsTrackersPost request with any body
	TorrentsTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsTrackersPostWithFormdataBody(ctx context.Context, body TorrentsTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsUploadLimitPost request with any body
	TorrentsUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsUploadLimitPostWithFormdataBody(ctx context.Context, body TorrentsUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentWebseedsPost request with any body
	TorrentWebseedsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentWebseedsPostWithFormdataBody(ctx context.Context, body TorrentWebseedsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferBanPeersPost request with any body
	TransferBanPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferBanPeersPostWithFormdataBody(ctx context.Context, body TransferBanPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferDownloadLimitGet request
	TransferDownloadLimitGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferInfoGet request
	TransferInfoGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferSetDownloadLimitPost request with any body
	TransferSetDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferSetDownloadLimitPostWithFormdataBody(ctx context.Context, body TransferSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferSetUploadLimitPost request with any body
	TransferSetUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferSetUploadLimitPostWithFormdataBody(ctx context.Context, body TransferSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferSpeedLimitsModeGet request
	TransferSpeedLimitsModeGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferToggleSpeedLimitsModeGet request
	TransferToggleSpeedLimitsModeGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferUploadLimitGet request
	TransferUploadLimitGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AppBuildInfoGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppBuildInfoGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppDefaultSavePathGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppDefaultSavePathGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreferencesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppPreferencesGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppSetPreferencesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppSetPreferencesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppSetPreferencesPostWithFormdataBody(ctx context.Context, body AppSetPreferencesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppSetPreferencesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppShutdownGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppShutdownGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppVersionGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppVersionGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppWebapiVersionGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppWebapiVersionGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLoginPostWithBody(ctx context.Context, params *AuthLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLoginPostWithFormdataBody(ctx context.Context, params *AuthLoginPostParams, body AuthLoginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginPostRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogoutPost(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLogoutPostRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogMainPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogMainPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogMainPostWithFormdataBody(ctx context.Context, body LogMainPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogMainPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogPeersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogPeersPostWithFormdataBody(ctx context.Context, body LogPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogPeersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssAddFeedPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssAddFeedPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssAddFeedPostWithFormdataBody(ctx context.Context, body RssAddFeedPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssAddFeedPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssAddFolderPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssAddFolderPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssAddFolderPostWithFormdataBody(ctx context.Context, body RssAddFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssAddFolderPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssItemsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssItemsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssItemsPostWithFormdataBody(ctx context.Context, body RssItemsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssItemsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMarkAsReadPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMarkAsReadPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMarkAsReadPostWithFormdataBody(ctx context.Context, body RssMarkAsReadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMarkAsReadPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMatchingArticlesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMatchingArticlesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMatchingArticlesPostWithFormdataBody(ctx context.Context, body RssMatchingArticlesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMatchingArticlesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMoveItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMoveItemPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMoveItemPostWithFormdataBody(ctx context.Context, body RssMoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMoveItemPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRefreshItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRefreshItemPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRefreshItemPostWithFormdataBody(ctx context.Context, body RssRefreshItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRefreshItemPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRemoveItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRemoveItemPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRemoveItemPostWithFormdataBody(ctx context.Context, body RssRemoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRemoveItemPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRemoveRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRemoveRulePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRemoveRulePostWithFormdataBody(ctx context.Context, body RssRemoveRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRemoveRulePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRenameRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRenameRulePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRenameRulePostWithFormdataBody(ctx context.Context, body RssRenameRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRenameRulePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRulesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRulesGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssSetRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssSetRulePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssSetRulePostWithFormdataBody(ctx context.Context, body RssSetRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssSetRulePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDeletePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDeletePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDeletePostWithFormdataBody(ctx context.Context, body SearchDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDeletePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchEnablePluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchEnablePluginPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchEnablePluginPostWithFormdataBody(ctx context.Context, body SearchEnablePluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchEnablePluginPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchInstallPluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchInstallPluginPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchInstallPluginPostWithFormdataBody(ctx context.Context, body SearchInstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchInstallPluginPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPluginsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPluginsGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchResultsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchResultsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchResultsPostWithFormdataBody(ctx context.Context, body SearchResultsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchResultsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStartPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStartPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStartPostWithFormdataBody(ctx context.Context, body SearchStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStartPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStatusPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStatusPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStatusPostWithFormdataBody(ctx context.Context, body SearchStatusPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStatusPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStopPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStopPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStopPostWithFormdataBody(ctx context.Context, body SearchStopPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStopPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUninstallPluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUninstallPluginPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUninstallPluginPostWithFormdataBody(ctx context.Context, body SearchUninstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUninstallPluginPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUpdatePluginsPost(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUpdatePluginsPostRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncMaindataPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncMaindataPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncMaindataPostWithFormdataBody(ctx context.Context, body SyncMaindataPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncMaindataPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncTorrentPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncTorrentPeersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncTorrentPeersPostWithFormdataBody(ctx context.Context, body SyncTorrentPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncTorrentPeersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddPeersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddPeersPostWithFormdataBody(ctx context.Context, body TorrentsAddPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddPeersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddTagsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddTagsPostWithFormdataBody(ctx context.Context, body TorrentsAddTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddTagsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddTrackersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddTrackersPostWithFormdataBody(ctx context.Context, body TorrentsAddTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddTrackersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsBottomPrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsBottomPrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsBottomPrioPostWithFormdataBody(ctx context.Context, body TorrentsBottomPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsBottomPrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsCategoriesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsCategoriesGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsCreateCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsCreateCategoryPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsCreateCategoryPostWithFormdataBody(ctx context.Context, body TorrentsCreateCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsCreateCategoryPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsCreateTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsCreateTagsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsCreateTagsPostWithFormdataBody(ctx context.Context, body TorrentsCreateTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsCreateTagsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDecreasePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDecreasePrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDecreasePrioPostWithFormdataBody(ctx context.Context, body TorrentsDecreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDecreasePrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDeletePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDeletePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDeletePostWithFormdataBody(ctx context.Context, body TorrentsDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDeletePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDeleteTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDeleteTagsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDeleteTagsPostWithFormdataBody(ctx context.Context, body TorrentsDeleteTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDeleteTagsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDownloadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDownloadLimitPostWithFormdataBody(ctx context.Context, body TorrentsDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDownloadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsEditCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsEditCategoryPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsEditCategoryPostWithFormdataBody(ctx context.Context, body TorrentsEditCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsEditCategoryPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsEditTrackerPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsEditTrackerPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsEditTrackerPostWithFormdataBody(ctx context.Context, body TorrentsEditTrackerPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsEditTrackerPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsFilePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsFilePrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsFilePrioPostWithFormdataBody(ctx context.Context, body TorrentsFilePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsFilePrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsFilesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsFilesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsFilesPostWithFormdataBody(ctx context.Context, body TorrentsFilesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsFilesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsIncreasePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsIncreasePrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsIncreasePrioPostWithFormdataBody(ctx context.Context, body TorrentsIncreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsIncreasePrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsInfoPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsInfoPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsInfoPostWithFormdataBody(ctx context.Context, body TorrentsInfoPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsInfoPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPausePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPausePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPausePostWithFormdataBody(ctx context.Context, body TorrentsPausePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPausePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPieceHashesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPieceHashesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPieceHashesPostWithFormdataBody(ctx context.Context, body TorrentsPieceHashesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPieceHashesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPieceStatesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPieceStatesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPieceStatesPostWithFormdataBody(ctx context.Context, body TorrentsPieceStatesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPieceStatesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPropertiesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPropertiesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPropertiesPostWithFormdataBody(ctx context.Context, body TorrentsPropertiesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPropertiesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsReannouncePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsReannouncePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsReannouncePostWithFormdataBody(ctx context.Context, body TorrentsReannouncePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsReannouncePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRecheckPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRecheckPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRecheckPostWithFormdataBody(ctx context.Context, body TorrentsRecheckPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRecheckPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveCategoriesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveCategoriesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveCategoriesPostWithFormdataBody(ctx context.Context, body TorrentsRemoveCategoriesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveCategoriesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveTagsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveTagsPostWithFormdataBody(ctx context.Context, body TorrentsRemoveTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveTagsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveTrackersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveTrackersPostWithFormdataBody(ctx context.Context, body TorrentsRemoveTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveTrackersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenamePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenamePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenamePostWithFormdataBody(ctx context.Context, body TorrentsRenamePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenamePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenameFilePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenameFilePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenameFilePostWithFormdataBody(ctx context.Context, body TorrentsRenameFilePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenameFilePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenameFolderPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenameFolderPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenameFolderPostWithFormdataBody(ctx context.Context, body TorrentsRenameFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenameFolderPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsResumePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsResumePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsResumePostWithFormdataBody(ctx context.Context, body TorrentsResumePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsResumePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetAutoManagementPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetAutoManagementPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetAutoManagementPostWithFormdataBody(ctx context.Context, body TorrentsSetAutoManagementPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetAutoManagementPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetCategoryPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetCategoryPostWithFormdataBody(ctx context.Context, body TorrentsSetCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetCategoryPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetDownloadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetDownloadLimitPostWithFormdataBody(ctx context.Context, body TorrentsSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetDownloadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetForceStartPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetForceStartPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetForceStartPostWithFormdataBody(ctx context.Context, body TorrentsSetForceStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetForceStartPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetLocationPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetLocationPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetLocationPostWithFormdataBody(ctx context.Context, body TorrentsSetLocationPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetLocationPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetShareLimitsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetShareLimitsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetShareLimitsPostWithFormdataBody(ctx context.Context, body TorrentsSetShareLimitsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetShareLimitsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetSuperSeedingPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetSuperSeedingPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetSuperSeedingPostWithFormdataBody(ctx context.Context, body TorrentsSetSuperSeedingPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetSuperSeedingPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetUploadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetUploadLimitPostWithFormdataBody(ctx context.Context, body TorrentsSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetUploadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsTagsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsTagsGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsToggleFirstLastPiecePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsToggleFirstLastPiecePrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsToggleFirstLastPiecePrioPostWithFormdataBody(ctx context.Context, body TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsToggleFirstLastPiecePrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsToggleSequentialDownloadPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsToggleSequentialDownloadPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsToggleSequentialDownloadPostWithFormdataBody(ctx context.Context, body TorrentsToggleSequentialDownloadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsToggleSequentialDownloadPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsTopPrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsTopPrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsTopPrioPostWithFormdataBody(ctx context.Context, body TorrentsTopPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsTopPrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsTrackersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsTrackersPostWithFormdataBody(ctx context.Context, body TorrentsTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsTrackersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsUploadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsUploadLimitPostWithFormdataBody(ctx context.Context, body TorrentsUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsUploadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentWebseedsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentWebseedsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentWebseedsPostWithFormdataBody(ctx context.Context, body TorrentWebseedsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentWebseedsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferBanPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferBanPeersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferBanPeersPostWithFormdataBody(ctx context.Context, body TransferBanPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferBanPeersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferDownloadLimitGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferDownloadLimitGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferInfoGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferInfoGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferSetDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferSetDownloadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferSetDownloadLimitPostWithFormdataBody(ctx context.Context, body TransferSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferSetDownloadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferSetUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferSetUploadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferSetUploadLimitPostWithFormdataBody(ctx context.Context, body TransferSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferSetUploadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferSpeedLimitsModeGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferSpeedLimitsModeGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferToggleSpeedLimitsModeGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferToggleSpeedLimitsModeGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferUploadLimitGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferUploadLimitGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAppBuildInfoGetRequest generates requests for AppBuildInfoGet
func NewAppBuildInfoGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/buildInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppDefaultSavePathGetRequest generates requests for AppDefaultSavePathGet
func NewAppDefaultSavePathGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/defaultSavePath")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreferencesGetRequest generates requests for AppPreferencesGet
func NewAppPreferencesGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/preferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppSetPreferencesPostRequestWithFormdataBody calls the generic AppSetPreferencesPost builder with application/x-www-form-urlencoded body
func NewAppSetPreferencesPostRequestWithFormdataBody(server string, body AppSetPreferencesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewAppSetPreferencesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewAppSetPreferencesPostRequestWithBody generates requests for AppSetPreferencesPost with any type of body
func NewAppSetPreferencesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/setPreferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppShutdownGetRequest generates requests for AppShutdownGet
func NewAppShutdownGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/shutdown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppVersionGetRequest generates requests for AppVersionGet
func NewAppVersionGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppWebapiVersionGetRequest generates requests for AppWebapiVersionGet
func NewAppWebapiVersionGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/webapiVersion")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthLoginPostRequestWithFormdataBody calls the generic AuthLoginPost builder with application/x-www-form-urlencoded body
func NewAuthLoginPostRequestWithFormdataBody(server string, params *AuthLoginPostParams, body AuthLoginPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewAuthLoginPostRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewAuthLoginPostRequestWithBody generates requests for AuthLoginPost with any type of body
func NewAuthLoginPostRequestWithBody(server string, params *AuthLoginPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.Referer != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Referer", runtime.ParamLocationHeader, *params.Referer)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Referer", headerParam0)
	}

	if params.Origin != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Origin", runtime.ParamLocationHeader, *params.Origin)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Origin", headerParam1)
	}

	return req, nil
}

// NewAuthLogoutPostRequest generates requests for AuthLogoutPost
func NewAuthLogoutPostRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogMainPostRequestWithFormdataBody calls the generic LogMainPost builder with application/x-www-form-urlencoded body
func NewLogMainPostRequestWithFormdataBody(server string, body LogMainPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewLogMainPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewLogMainPostRequestWithBody generates requests for LogMainPost with any type of body
func NewLogMainPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/log/main")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogPeersPostRequestWithFormdataBody calls the generic LogPeersPost builder with application/x-www-form-urlencoded body
func NewLogPeersPostRequestWithFormdataBody(server string, body LogPeersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewLogPeersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewLogPeersPostRequestWithBody generates requests for LogPeersPost with any type of body
func NewLogPeersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/log/peers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssAddFeedPostRequestWithFormdataBody calls the generic RssAddFeedPost builder with application/x-www-form-urlencoded body
func NewRssAddFeedPostRequestWithFormdataBody(server string, body RssAddFeedPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssAddFeedPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssAddFeedPostRequestWithBody generates requests for RssAddFeedPost with any type of body
func NewRssAddFeedPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/addFeed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssAddFolderPostRequestWithFormdataBody calls the generic RssAddFolderPost builder with application/x-www-form-urlencoded body
func NewRssAddFolderPostRequestWithFormdataBody(server string, body RssAddFolderPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssAddFolderPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssAddFolderPostRequestWithBody generates requests for RssAddFolderPost with any type of body
func NewRssAddFolderPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/addFolder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssItemsPostRequestWithFormdataBody calls the generic RssItemsPost builder with application/x-www-form-urlencoded body
func NewRssItemsPostRequestWithFormdataBody(server string, body RssItemsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssItemsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssItemsPostRequestWithBody generates requests for RssItemsPost with any type of body
func NewRssItemsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssMarkAsReadPostRequestWithFormdataBody calls the generic RssMarkAsReadPost builder with application/x-www-form-urlencoded body
func NewRssMarkAsReadPostRequestWithFormdataBody(server string, body RssMarkAsReadPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssMarkAsReadPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssMarkAsReadPostRequestWithBody generates requests for RssMarkAsReadPost with any type of body
func NewRssMarkAsReadPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/markAsRead")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssMatchingArticlesPostRequestWithFormdataBody calls the generic RssMatchingArticlesPost builder with application/x-www-form-urlencoded body
func NewRssMatchingArticlesPostRequestWithFormdataBody(server string, body RssMatchingArticlesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssMatchingArticlesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssMatchingArticlesPostRequestWithBody generates requests for RssMatchingArticlesPost with any type of body
func NewRssMatchingArticlesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/matchingArticles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssMoveItemPostRequestWithFormdataBody calls the generic RssMoveItemPost builder with application/x-www-form-urlencoded body
func NewRssMoveItemPostRequestWithFormdataBody(server string, body RssMoveItemPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssMoveItemPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssMoveItemPostRequestWithBody generates requests for RssMoveItemPost with any type of body
func NewRssMoveItemPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/moveItem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssRefreshItemPostRequestWithFormdataBody calls the generic RssRefreshItemPost builder with application/x-www-form-urlencoded body
func NewRssRefreshItemPostRequestWithFormdataBody(server string, body RssRefreshItemPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssRefreshItemPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssRefreshItemPostRequestWithBody generates requests for RssRefreshItemPost with any type of body
func NewRssRefreshItemPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/refreshItem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssRemoveItemPostRequestWithFormdataBody calls the generic RssRemoveItemPost builder with application/x-www-form-urlencoded body
func NewRssRemoveItemPostRequestWithFormdataBody(server string, body RssRemoveItemPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssRemoveItemPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssRemoveItemPostRequestWithBody generates requests for RssRemoveItemPost with any type of body
func NewRssRemoveItemPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/removeItem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssRemoveRulePostRequestWithFormdataBody calls the generic RssRemoveRulePost builder with application/x-www-form-urlencoded body
func NewRssRemoveRulePostRequestWithFormdataBody(server string, body RssRemoveRulePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssRemoveRulePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssRemoveRulePostRequestWithBody generates requests for RssRemoveRulePost with any type of body
func NewRssRemoveRulePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/removeRule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssRenameRulePostRequestWithFormdataBody calls the generic RssRenameRulePost builder with application/x-www-form-urlencoded body
func NewRssRenameRulePostRequestWithFormdataBody(server string, body RssRenameRulePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssRenameRulePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssRenameRulePostRequestWithBody generates requests for RssRenameRulePost with any type of body
func NewRssRenameRulePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/renameRule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssRulesGetRequest generates requests for RssRulesGet
func NewRssRulesGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRssSetRulePostRequestWithFormdataBody calls the generic RssSetRulePost builder with application/x-www-form-urlencoded body
func NewRssSetRulePostRequestWithFormdataBody(server string, body RssSetRulePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssSetRulePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssSetRulePostRequestWithBody generates requests for RssSetRulePost with any type of body
func NewRssSetRulePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/setRule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchDeletePostRequestWithFormdataBody calls the generic SearchDeletePost builder with application/x-www-form-urlencoded body
func NewSearchDeletePostRequestWithFormdataBody(server string, body SearchDeletePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchDeletePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchDeletePostRequestWithBody generates requests for SearchDeletePost with any type of body
func NewSearchDeletePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchEnablePluginPostRequestWithFormdataBody calls the generic SearchEnablePluginPost builder with application/x-www-form-urlencoded body
func NewSearchEnablePluginPostRequestWithFormdataBody(server string, body SearchEnablePluginPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchEnablePluginPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchEnablePluginPostRequestWithBody generates requests for SearchEnablePluginPost with any type of body
func NewSearchEnablePluginPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/enablePlugin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchInstallPluginPostRequestWithFormdataBody calls the generic SearchInstallPluginPost builder with application/x-www-form-urlencoded body
func NewSearchInstallPluginPostRequestWithFormdataBody(server string, body SearchInstallPluginPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchInstallPluginPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchInstallPluginPostRequestWithBody generates requests for SearchInstallPluginPost with any type of body
func NewSearchInstallPluginPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/installPlugin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchPluginsGetRequest generates requests for SearchPluginsGet
func NewSearchPluginsGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchResultsPostRequestWithFormdataBody calls the generic SearchResultsPost builder with application/x-www-form-urlencoded body
func NewSearchResultsPostRequestWithFormdataBody(server string, body SearchResultsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchResultsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchResultsPostRequestWithBody generates requests for SearchResultsPost with any type of body
func NewSearchResultsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/results")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchStartPostRequestWithFormdataBody calls the generic SearchStartPost builder with application/x-www-form-urlencoded body
func NewSearchStartPostRequestWithFormdataBody(server string, body SearchStartPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchStartPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchStartPostRequestWithBody generates requests for SearchStartPost with any type of body
func NewSearchStartPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchStatusPostRequestWithFormdataBody calls the generic SearchStatusPost builder with application/x-www-form-urlencoded body
func NewSearchStatusPostRequestWithFormdataBody(server string, body SearchStatusPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchStatusPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchStatusPostRequestWithBody generates requests for SearchStatusPost with any type of body
func NewSearchStatusPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchStopPostRequestWithFormdataBody calls the generic SearchStopPost builder with application/x-www-form-urlencoded body
func NewSearchStopPostRequestWithFormdataBody(server string, body SearchStopPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchStopPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchStopPostRequestWithBody generates requests for SearchStopPost with any type of body
func NewSearchStopPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/stop")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchUninstallPluginPostRequestWithFormdataBody calls the generic SearchUninstallPluginPost builder with application/x-www-form-urlencoded body
func NewSearchUninstallPluginPostRequestWithFormdataBody(server string, body SearchUninstallPluginPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchUninstallPluginPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchUninstallPluginPostRequestWithBody generates requests for SearchUninstallPluginPost with any type of body
func NewSearchUninstallPluginPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/uninstallPlugin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchUpdatePluginsPostRequest generates requests for SearchUpdatePluginsPost
func NewSearchUpdatePluginsPostRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/updatePlugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncMaindataPostRequestWithFormdataBody calls the generic SyncMaindataPost builder with application/x-www-form-urlencoded body
func NewSyncMaindataPostRequestWithFormdataBody(server string, body SyncMaindataPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSyncMaindataPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSyncMaindataPostRequestWithBody generates requests for SyncMaindataPost with any type of body
func NewSyncMaindataPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync/maindata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncTorrentPeersPostRequestWithFormdataBody calls the generic SyncTorrentPeersPost builder with application/x-www-form-urlencoded body
func NewSyncTorrentPeersPostRequestWithFormdataBody(server string, body SyncTorrentPeersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSyncTorrentPeersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSyncTorrentPeersPostRequestWithBody generates requests for SyncTorrentPeersPost with any type of body
func NewSyncTorrentPeersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync/torrentPeers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsAddPostRequestWithBody generates requests for TorrentsAddPost with any type of body
func NewTorrentsAddPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsAddPeersPostRequestWithFormdataBody calls the generic TorrentsAddPeersPost builder with application/x-www-form-urlencoded body
func NewTorrentsAddPeersPostRequestWithFormdataBody(server string, body TorrentsAddPeersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsAddPeersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsAddPeersPostRequestWithBody generates requests for TorrentsAddPeersPost with any type of body
func NewTorrentsAddPeersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/addPeers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsAddTagsPostRequestWithFormdataBody calls the generic TorrentsAddTagsPost builder with application/x-www-form-urlencoded body
func NewTorrentsAddTagsPostRequestWithFormdataBody(server string, body TorrentsAddTagsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsAddTagsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsAddTagsPostRequestWithBody generates requests for TorrentsAddTagsPost with any type of body
func NewTorrentsAddTagsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/addTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsAddTrackersPostRequestWithFormdataBody calls the generic TorrentsAddTrackersPost builder with application/x-www-form-urlencoded body
func NewTorrentsAddTrackersPostRequestWithFormdataBody(server string, body TorrentsAddTrackersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsAddTrackersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsAddTrackersPostRequestWithBody generates requests for TorrentsAddTrackersPost with any type of body
func NewTorrentsAddTrackersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/addTrackers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsBottomPrioPostRequestWithFormdataBody calls the generic TorrentsBottomPrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsBottomPrioPostRequestWithFormdataBody(server string, body TorrentsBottomPrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsBottomPrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsBottomPrioPostRequestWithBody generates requests for TorrentsBottomPrioPost with any type of body
func NewTorrentsBottomPrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/bottomPrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsCategoriesGetRequest generates requests for TorrentsCategoriesGet
func NewTorrentsCategoriesGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTorrentsCreateCategoryPostRequestWithFormdataBody calls the generic TorrentsCreateCategoryPost builder with application/x-www-form-urlencoded body
func NewTorrentsCreateCategoryPostRequestWithFormdataBody(server string, body TorrentsCreateCategoryPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsCreateCategoryPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsCreateCategoryPostRequestWithBody generates requests for TorrentsCreateCategoryPost with any type of body
func NewTorrentsCreateCategoryPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/createCategory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsCreateTagsPostRequestWithFormdataBody calls the generic TorrentsCreateTagsPost builder with application/x-www-form-urlencoded body
func NewTorrentsCreateTagsPostRequestWithFormdataBody(server string, body TorrentsCreateTagsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsCreateTagsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsCreateTagsPostRequestWithBody generates requests for TorrentsCreateTagsPost with any type of body
func NewTorrentsCreateTagsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/createTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsDecreasePrioPostRequestWithFormdataBody calls the generic TorrentsDecreasePrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsDecreasePrioPostRequestWithFormdataBody(server string, body TorrentsDecreasePrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsDecreasePrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsDecreasePrioPostRequestWithBody generates requests for TorrentsDecreasePrioPost with any type of body
func NewTorrentsDecreasePrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/decreasePrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsDeletePostRequestWithFormdataBody calls the generic TorrentsDeletePost builder with application/x-www-form-urlencoded body
func NewTorrentsDeletePostRequestWithFormdataBody(server string, body TorrentsDeletePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsDeletePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsDeletePostRequestWithBody generates requests for TorrentsDeletePost with any type of body
func NewTorrentsDeletePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsDeleteTagsPostRequestWithFormdataBody calls the generic TorrentsDeleteTagsPost builder with application/x-www-form-urlencoded body
func NewTorrentsDeleteTagsPostRequestWithFormdataBody(server string, body TorrentsDeleteTagsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsDeleteTagsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsDeleteTagsPostRequestWithBody generates requests for TorrentsDeleteTagsPost with any type of body
func NewTorrentsDeleteTagsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/deleteTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsDownloadLimitPostRequestWithFormdataBody calls the generic TorrentsDownloadLimitPost builder with application/x-www-form-urlencoded body
func NewTorrentsDownloadLimitPostRequestWithFormdataBody(server string, body TorrentsDownloadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsDownloadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsDownloadLimitPostRequestWithBody generates requests for TorrentsDownloadLimitPost with any type of body
func NewTorrentsDownloadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/downloadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsEditCategoryPostRequestWithFormdataBody calls the generic TorrentsEditCategoryPost builder with application/x-www-form-urlencoded body
func NewTorrentsEditCategoryPostRequestWithFormdataBody(server string, body TorrentsEditCategoryPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsEditCategoryPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsEditCategoryPostRequestWithBody generates requests for TorrentsEditCategoryPost with any type of body
func NewTorrentsEditCategoryPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/editCategory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsEditTrackerPostRequestWithFormdataBody calls the generic TorrentsEditTrackerPost builder with application/x-www-form-urlencoded body
func NewTorrentsEditTrackerPostRequestWithFormdataBody(server string, body TorrentsEditTrackerPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsEditTrackerPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsEditTrackerPostRequestWithBody generates requests for TorrentsEditTrackerPost with any type of body
func NewTorrentsEditTrackerPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/editTracker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsFilePrioPostRequestWithFormdataBody calls the generic TorrentsFilePrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsFilePrioPostRequestWithFormdataBody(server string, body TorrentsFilePrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsFilePrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsFilePrioPostRequestWithBody generates requests for TorrentsFilePrioPost with any type of body
func NewTorrentsFilePrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/filePrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsFilesPostRequestWithFormdataBody calls the generic TorrentsFilesPost builder with application/x-www-form-urlencoded body
func NewTorrentsFilesPostRequestWithFormdataBody(server string, body TorrentsFilesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsFilesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsFilesPostRequestWithBody generates requests for TorrentsFilesPost with any type of body
func NewTorrentsFilesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsIncreasePrioPostRequestWithFormdataBody calls the generic TorrentsIncreasePrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsIncreasePrioPostRequestWithFormdataBody(server string, body TorrentsIncreasePrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsIncreasePrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsIncreasePrioPostRequestWithBody generates requests for TorrentsIncreasePrioPost with any type of body
func NewTorrentsIncreasePrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/increasePrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsInfoPostRequestWithFormdataBody calls the generic TorrentsInfoPost builder with application/x-www-form-urlencoded body
func NewTorrentsInfoPostRequestWithFormdataBody(server string, body TorrentsInfoPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsInfoPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsInfoPostRequestWithBody generates requests for TorrentsInfoPost with any type of body
func NewTorrentsInfoPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsPausePostRequestWithFormdataBody calls the generic TorrentsPausePost builder with application/x-www-form-urlencoded body
func NewTorrentsPausePostRequestWithFormdataBody(server string, body TorrentsPausePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsPausePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsPausePostRequestWithBody generates requests for TorrentsPausePost with any type of body
func NewTorrentsPausePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/pause")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsPieceHashesPostRequestWithFormdataBody calls the generic TorrentsPieceHashesPost builder with application/x-www-form-urlencoded body
func NewTorrentsPieceHashesPostRequestWithFormdataBody(server string, body TorrentsPieceHashesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsPieceHashesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsPieceHashesPostRequestWithBody generates requests for TorrentsPieceHashesPost with any type of body
func NewTorrentsPieceHashesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/pieceHashes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsPieceStatesPostRequestWithFormdataBody calls the generic TorrentsPieceStatesPost builder with application/x-www-form-urlencoded body
func NewTorrentsPieceStatesPostRequestWithFormdataBody(server string, body TorrentsPieceStatesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsPieceStatesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsPieceStatesPostRequestWithBody generates requests for TorrentsPieceStatesPost with any type of body
func NewTorrentsPieceStatesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/pieceStates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsPropertiesPostRequestWithFormdataBody calls the generic TorrentsPropertiesPost builder with application/x-www-form-urlencoded body
func NewTorrentsPropertiesPostRequestWithFormdataBody(server string, body TorrentsPropertiesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsPropertiesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsPropertiesPostRequestWithBody generates requests for TorrentsPropertiesPost with any type of body
func NewTorrentsPropertiesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/properties")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsReannouncePostRequestWithFormdataBody calls the generic TorrentsReannouncePost builder with application/x-www-form-urlencoded body
func NewTorrentsReannouncePostRequestWithFormdataBody(server string, body TorrentsReannouncePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsReannouncePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsReannouncePostRequestWithBody generates requests for TorrentsReannouncePost with any type of body
func NewTorrentsReannouncePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/reannounce")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRecheckPostRequestWithFormdataBody calls the generic TorrentsRecheckPost builder with application/x-www-form-urlencoded body
func NewTorrentsRecheckPostRequestWithFormdataBody(server string, body TorrentsRecheckPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRecheckPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRecheckPostRequestWithBody generates requests for TorrentsRecheckPost with any type of body
func NewTorrentsRecheckPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/recheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRemoveCategoriesPostRequestWithFormdataBody calls the generic TorrentsRemoveCategoriesPost builder with application/x-www-form-urlencoded body
func NewTorrentsRemoveCategoriesPostRequestWithFormdataBody(server string, body TorrentsRemoveCategoriesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRemoveCategoriesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRemoveCategoriesPostRequestWithBody generates requests for TorrentsRemoveCategoriesPost with any type of body
func NewTorrentsRemoveCategoriesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/removeCategories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRemoveTagsPostRequestWithFormdataBody calls the generic TorrentsRemoveTagsPost builder with application/x-www-form-urlencoded body
func NewTorrentsRemoveTagsPostRequestWithFormdataBody(server string, body TorrentsRemoveTagsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRemoveTagsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRemoveTagsPostRequestWithBody generates requests for TorrentsRemoveTagsPost with any type of body
func NewTorrentsRemoveTagsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/removeTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRemoveTrackersPostRequestWithFormdataBody calls the generic TorrentsRemoveTrackersPost builder with application/x-www-form-urlencoded body
func NewTorrentsRemoveTrackersPostRequestWithFormdataBody(server string, body TorrentsRemoveTrackersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRemoveTrackersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRemoveTrackersPostRequestWithBody generates requests for TorrentsRemoveTrackersPost with any type of body
func NewTorrentsRemoveTrackersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/removeTrackers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRenamePostRequestWithFormdataBody calls the generic TorrentsRenamePost builder with application/x-www-form-urlencoded body
func NewTorrentsRenamePostRequestWithFormdataBody(server string, body TorrentsRenamePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRenamePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRenamePostRequestWithBody generates requests for TorrentsRenamePost with any type of body
func NewTorrentsRenamePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/rename")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRenameFilePostRequestWithFormdataBody calls the generic TorrentsRenameFilePost builder with application/x-www-form-urlencoded body
func NewTorrentsRenameFilePostRequestWithFormdataBody(server string, body TorrentsRenameFilePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRenameFilePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRenameFilePostRequestWithBody generates requests for TorrentsRenameFilePost with any type of body
func NewTorrentsRenameFilePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/renameFile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRenameFolderPostRequestWithFormdataBody calls the generic TorrentsRenameFolderPost builder with application/x-www-form-urlencoded body
func NewTorrentsRenameFolderPostRequestWithFormdataBody(server string, body TorrentsRenameFolderPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRenameFolderPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRenameFolderPostRequestWithBody generates requests for TorrentsRenameFolderPost with any type of body
func NewTorrentsRenameFolderPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/renameFolder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsResumePostRequestWithFormdataBody calls the generic TorrentsResumePost builder with application/x-www-form-urlencoded body
func NewTorrentsResumePostRequestWithFormdataBody(server string, body TorrentsResumePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsResumePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsResumePostRequestWithBody generates requests for TorrentsResumePost with any type of body
func NewTorrentsResumePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/resume")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetAutoManagementPostRequestWithFormdataBody calls the generic TorrentsSetAutoManagementPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetAutoManagementPostRequestWithFormdataBody(server string, body TorrentsSetAutoManagementPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetAutoManagementPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetAutoManagementPostRequestWithBody generates requests for TorrentsSetAutoManagementPost with any type of body
func NewTorrentsSetAutoManagementPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setAutoManagement")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetCategoryPostRequestWithFormdataBody calls the generic TorrentsSetCategoryPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetCategoryPostRequestWithFormdataBody(server string, body TorrentsSetCategoryPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetCategoryPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetCategoryPostRequestWithBody generates requests for TorrentsSetCategoryPost with any type of body
func NewTorrentsSetCategoryPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setCategory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetDownloadLimitPostRequestWithFormdataBody calls the generic TorrentsSetDownloadLimitPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetDownloadLimitPostRequestWithFormdataBody(server string, body TorrentsSetDownloadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetDownloadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetDownloadLimitPostRequestWithBody generates requests for TorrentsSetDownloadLimitPost with any type of body
func NewTorrentsSetDownloadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setDownloadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetForceStartPostRequestWithFormdataBody calls the generic TorrentsSetForceStartPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetForceStartPostRequestWithFormdataBody(server string, body TorrentsSetForceStartPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetForceStartPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetForceStartPostRequestWithBody generates requests for TorrentsSetForceStartPost with any type of body
func NewTorrentsSetForceStartPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setForceStart")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetLocationPostRequestWithFormdataBody calls the generic TorrentsSetLocationPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetLocationPostRequestWithFormdataBody(server string, body TorrentsSetLocationPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetLocationPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetLocationPostRequestWithBody generates requests for TorrentsSetLocationPost with any type of body
func NewTorrentsSetLocationPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setLocation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetShareLimitsPostRequestWithFormdataBody calls the generic TorrentsSetShareLimitsPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetShareLimitsPostRequestWithFormdataBody(server string, body TorrentsSetShareLimitsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetShareLimitsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetShareLimitsPostRequestWithBody generates requests for TorrentsSetShareLimitsPost with any type of body
func NewTorrentsSetShareLimitsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setShareLimits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetSuperSeedingPostRequestWithFormdataBody calls the generic TorrentsSetSuperSeedingPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetSuperSeedingPostRequestWithFormdataBody(server string, body TorrentsSetSuperSeedingPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetSuperSeedingPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetSuperSeedingPostRequestWithBody generates requests for TorrentsSetSuperSeedingPost with any type of body
func NewTorrentsSetSuperSeedingPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setSuperSeeding")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetUploadLimitPostRequestWithFormdataBody calls the generic TorrentsSetUploadLimitPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetUploadLimitPostRequestWithFormdataBody(server string, body TorrentsSetUploadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetUploadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetUploadLimitPostRequestWithBody generates requests for TorrentsSetUploadLimitPost with any type of body
func NewTorrentsSetUploadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setUploadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsTagsGetRequest generates requests for TorrentsTagsGet
func NewTorrentsTagsGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTorrentsToggleFirstLastPiecePrioPostRequestWithFormdataBody calls the generic TorrentsToggleFirstLastPiecePrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsToggleFirstLastPiecePrioPostRequestWithFormdataBody(server string, body TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsToggleFirstLastPiecePrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsToggleFirstLastPiecePrioPostRequestWithBody generates requests for TorrentsToggleFirstLastPiecePrioPost with any type of body
func NewTorrentsToggleFirstLastPiecePrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/toggleFirstLastPiecePrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsToggleSequentialDownloadPostRequestWithFormdataBody calls the generic TorrentsToggleSequentialDownloadPost builder with application/x-www-form-urlencoded body
func NewTorrentsToggleSequentialDownloadPostRequestWithFormdataBody(server string, body TorrentsToggleSequentialDownloadPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsToggleSequentialDownloadPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsToggleSequentialDownloadPostRequestWithBody generates requests for TorrentsToggleSequentialDownloadPost with any type of body
func NewTorrentsToggleSequentialDownloadPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/toggleSequentialDownload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsTopPrioPostRequestWithFormdataBody calls the generic TorrentsTopPrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsTopPrioPostRequestWithFormdataBody(server string, body TorrentsTopPrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsTopPrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsTopPrioPostRequestWithBody generates requests for TorrentsTopPrioPost with any type of body
func NewTorrentsTopPrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/topPrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsTrackersPostRequestWithFormdataBody calls the generic TorrentsTrackersPost builder with application/x-www-form-urlencoded body
func NewTorrentsTrackersPostRequestWithFormdataBody(server string, body TorrentsTrackersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsTrackersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsTrackersPostRequestWithBody generates requests for TorrentsTrackersPost with any type of body
func NewTorrentsTrackersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/trackers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsUploadLimitPostRequestWithFormdataBody calls the generic TorrentsUploadLimitPost builder with application/x-www-form-urlencoded body
func NewTorrentsUploadLimitPostRequestWithFormdataBody(server string, body TorrentsUploadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsUploadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsUploadLimitPostRequestWithBody generates requests for TorrentsUploadLimitPost with any type of body
func NewTorrentsUploadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/uploadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentWebseedsPostRequestWithFormdataBody calls the generic TorrentWebseedsPost builder with application/x-www-form-urlencoded body
func NewTorrentWebseedsPostRequestWithFormdataBody(server string, body TorrentWebseedsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentWebseedsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentWebseedsPostRequestWithBody generates requests for TorrentWebseedsPost with any type of body
func NewTorrentWebseedsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/webseeds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferBanPeersPostRequestWithFormdataBody calls the generic TransferBanPeersPost builder with application/x-www-form-urlencoded body
func NewTransferBanPeersPostRequestWithFormdataBody(server string, body TransferBanPeersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTransferBanPeersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTransferBanPeersPostRequestWithBody generates requests for TransferBanPeersPost with any type of body
func NewTransferBanPeersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/banPeers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferDownloadLimitGetRequest generates requests for TransferDownloadLimitGet
func NewTransferDownloadLimitGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/downloadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferInfoGetRequest generates requests for TransferInfoGet
func NewTransferInfoGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferSetDownloadLimitPostRequestWithFormdataBody calls the generic TransferSetDownloadLimitPost builder with application/x-www-form-urlencoded body
func NewTransferSetDownloadLimitPostRequestWithFormdataBody(server string, body TransferSetDownloadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTransferSetDownloadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTransferSetDownloadLimitPostRequestWithBody generates requests for TransferSetDownloadLimitPost with any type of body
func NewTransferSetDownloadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/setDownloadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferSetUploadLimitPostRequestWithFormdataBody calls the generic TransferSetUploadLimitPost builder with application/x-www-form-urlencoded body
func NewTransferSetUploadLimitPostRequestWithFormdataBody(server string, body TransferSetUploadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTransferSetUploadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTransferSetUploadLimitPostRequestWithBody generates requests for TransferSetUploadLimitPost with any type of body
func NewTransferSetUploadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/setUploadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferSpeedLimitsModeGetRequest generates requests for TransferSpeedLimitsModeGet
func NewTransferSpeedLimitsModeGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/speedLimitsMode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferToggleSpeedLimitsModeGetRequest generates requests for TransferToggleSpeedLimitsModeGet
func NewTransferToggleSpeedLimitsModeGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/toggleSpeedLimitsMode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferUploadLimitGetRequest generates requests for TransferUploadLimitGet
func NewTransferUploadLimitGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/uploadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AppBuildInfoGet request
	AppBuildInfoGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppBuildInfoGetResponse, error)

	// AppDefaultSavePathGet request
	AppDefaultSavePathGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppDefaultSavePathGetResponse, error)

	// AppPreferencesGet request
	AppPreferencesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppPreferencesGetResponse, error)

	// AppSetPreferencesPost request with any body
	AppSetPreferencesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppSetPreferencesPostResponse, error)

	AppSetPreferencesPostWithFormdataBodyWithResponse(ctx context.Context, body AppSetPreferencesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*AppSetPreferencesPostResponse, error)

	// AppShutdownGet request
	AppShutdownGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppShutdownGetResponse, error)

	// AppVersionGet request
	AppVersionGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppVersionGetResponse, error)

	// AppWebapiVersionGet request
	AppWebapiVersionGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppWebapiVersionGetResponse, error)

	// AuthLoginPost request with any body
	AuthLoginPostWithBodyWithResponse(ctx context.Context, params *AuthLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginPostResponse, error)

	AuthLoginPostWithFormdataBodyWithResponse(ctx context.Context, params *AuthLoginPostParams, body AuthLoginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginPostResponse, error)

	// AuthLogoutPost request
	AuthLogoutPostWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthLogoutPostResponse, error)

	// LogMainPost request with any body
	LogMainPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogMainPostResponse, error)

	LogMainPostWithFormdataBodyWithResponse(ctx context.Context, body LogMainPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*LogMainPostResponse, error)

	// LogPeersPost request with any body
	LogPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogPeersPostResponse, error)

	LogPeersPostWithFormdataBodyWithResponse(ctx context.Context, body LogPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*LogPeersPostResponse, error)

	// RssAddFeedPost request with any body
	RssAddFeedPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssAddFeedPostResponse, error)

	RssAddFeedPostWithFormdataBodyWithResponse(ctx context.Context, body RssAddFeedPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssAddFeedPostResponse, error)

	// RssAddFolderPost request with any body
	RssAddFolderPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssAddFolderPostResponse, error)

	RssAddFolderPostWithFormdataBodyWithResponse(ctx context.Context, body RssAddFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssAddFolderPostResponse, error)

	// RssItemsPost request with any body
	RssItemsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssItemsPostResponse, error)

	RssItemsPostWithFormdataBodyWithResponse(ctx context.Context, body RssItemsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssItemsPostResponse, error)

	// RssMarkAsReadPost request with any body
	RssMarkAsReadPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMarkAsReadPostResponse, error)

	RssMarkAsReadPostWithFormdataBodyWithResponse(ctx context.Context, body RssMarkAsReadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMarkAsReadPostResponse, error)

	// RssMatchingArticlesPost request with any body
	RssMatchingArticlesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMatchingArticlesPostResponse, error)

	RssMatchingArticlesPostWithFormdataBodyWithResponse(ctx context.Context, body RssMatchingArticlesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMatchingArticlesPostResponse, error)

	// RssMoveItemPost request with any body
	RssMoveItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMoveItemPostResponse, error)

	RssMoveItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssMoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMoveItemPostResponse, error)

	// RssRefreshItemPost request with any body
	RssRefreshItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRefreshItemPostResponse, error)

	RssRefreshItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssRefreshItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRefreshItemPostResponse, error)

	// RssRemoveItemPost request with any body
	RssRemoveItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRemoveItemPostResponse, error)

	RssRemoveItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssRemoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRemoveItemPostResponse, error)

	// RssRemoveRulePost request with any body
	RssRemoveRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRemoveRulePostResponse, error)

	RssRemoveRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssRemoveRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRemoveRulePostResponse, error)

	// RssRenameRulePost request with any body
	RssRenameRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRenameRulePostResponse, error)

	RssRenameRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssRenameRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRenameRulePostResponse, error)

	// RssRulesGet request
	RssRulesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RssRulesGetResponse, error)

	// RssSetRulePost request with any body
	RssSetRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssSetRulePostResponse, error)

	RssSetRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssSetRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssSetRulePostResponse, error)

	// SearchDeletePost request with any body
	SearchDeletePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDeletePostResponse, error)

	SearchDeletePostWithFormdataBodyWithResponse(ctx context.Context, body SearchDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchDeletePostResponse, error)

	// SearchEnablePluginPost request with any body
	SearchEnablePluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchEnablePluginPostResponse, error)

	SearchEnablePluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchEnablePluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchEnablePluginPostResponse, error)

	// SearchInstallPluginPost request with any body
	SearchInstallPluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchInstallPluginPostResponse, error)

	SearchInstallPluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchInstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchInstallPluginPostResponse, error)

	// SearchPluginsGet request
	SearchPluginsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchPluginsGetResponse, error)

	// SearchResultsPost request with any body
	SearchResultsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchResultsPostResponse, error)

	SearchResultsPostWithFormdataBodyWithResponse(ctx context.Context, body SearchResultsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchResultsPostResponse, error)

	// SearchStartPost request with any body
	SearchStartPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStartPostResponse, error)

	SearchStartPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStartPostResponse, error)

	// SearchStatusPost request with any body
	SearchStatusPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStatusPostResponse, error)

	SearchStatusPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStatusPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStatusPostResponse, error)

	// SearchStopPost request with any body
	SearchStopPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStopPostResponse, error)

	SearchStopPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStopPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStopPostResponse, error)

	// SearchUninstallPluginPost request with any body
	SearchUninstallPluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUninstallPluginPostResponse, error)

	SearchUninstallPluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchUninstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchUninstallPluginPostResponse, error)

	// SearchUpdatePluginsPost request
	SearchUpdatePluginsPostWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchUpdatePluginsPostResponse, error)

	// SyncMaindataPost request with any body
	SyncMaindataPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncMaindataPostResponse, error)

	SyncMaindataPostWithFormdataBodyWithResponse(ctx context.Context, body SyncMaindataPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SyncMaindataPostResponse, error)

	// SyncTorrentPeersPost request with any body
	SyncTorrentPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncTorrentPeersPostResponse, error)

	SyncTorrentPeersPostWithFormdataBodyWithResponse(ctx context.Context, body SyncTorrentPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SyncTorrentPeersPostResponse, error)

	// TorrentsAddPost request with any body
	TorrentsAddPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddPostResponse, error)

	// TorrentsAddPeersPost request with any body
	TorrentsAddPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddPeersPostResponse, error)

	TorrentsAddPeersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddPeersPostResponse, error)

	// TorrentsAddTagsPost request with any body
	TorrentsAddTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddTagsPostResponse, error)

	TorrentsAddTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddTagsPostResponse, error)

	// TorrentsAddTrackersPost request with any body
	TorrentsAddTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddTrackersPostResponse, error)

	TorrentsAddTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddTrackersPostResponse, error)

	// TorrentsBottomPrioPost request with any body
	TorrentsBottomPrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsBottomPrioPostResponse, error)

	TorrentsBottomPrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsBottomPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsBottomPrioPostResponse, error)

	// TorrentsCategoriesGet request
	TorrentsCategoriesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TorrentsCategoriesGetResponse, error)

	// TorrentsCreateCategoryPost request with any body
	TorrentsCreateCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsCreateCategoryPostResponse, error)

	TorrentsCreateCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsCreateCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsCreateCategoryPostResponse, error)

	// TorrentsCreateTagsPost request with any body
	TorrentsCreateTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsCreateTagsPostResponse, error)

	TorrentsCreateTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsCreateTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsCreateTagsPostResponse, error)

	// TorrentsDecreasePrioPost request with any body
	TorrentsDecreasePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDecreasePrioPostResponse, error)

	TorrentsDecreasePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDecreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDecreasePrioPostResponse, error)

	// TorrentsDeletePost request with any body
	TorrentsDeletePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDeletePostResponse, error)

	TorrentsDeletePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDeletePostResponse, error)

	// TorrentsDeleteTagsPost request with any body
	TorrentsDeleteTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDeleteTagsPostResponse, error)

	TorrentsDeleteTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDeleteTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDeleteTagsPostResponse, error)

	// TorrentsDownloadLimitPost request with any body
	TorrentsDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDownloadLimitPostResponse, error)

	TorrentsDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDownloadLimitPostResponse, error)

	// TorrentsEditCategoryPost request with any body
	TorrentsEditCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsEditCategoryPostResponse, error)

	TorrentsEditCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsEditCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsEditCategoryPostResponse, error)

	// TorrentsEditTrackerPost request with any body
	TorrentsEditTrackerPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsEditTrackerPostResponse, error)

	TorrentsEditTrackerPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsEditTrackerPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsEditTrackerPostResponse, error)

	// TorrentsFilePrioPost request with any body
	TorrentsFilePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsFilePrioPostResponse, error)

	TorrentsFilePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsFilePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsFilePrioPostResponse, error)

	// TorrentsFilesPost request with any body
	TorrentsFilesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsFilesPostResponse, error)

	TorrentsFilesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsFilesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsFilesPostResponse, error)

	// TorrentsIncreasePrioPost request with any body
	TorrentsIncreasePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsIncreasePrioPostResponse, error)

	TorrentsIncreasePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsIncreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsIncreasePrioPostResponse, error)

	// TorrentsInfoPost request with any body
	TorrentsInfoPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsInfoPostResponse, error)

	TorrentsInfoPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsInfoPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsInfoPostResponse, error)

	// TorrentsPausePost request with any body
	TorrentsPausePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPausePostResponse, error)

	TorrentsPausePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPausePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPausePostResponse, error)

	// TorrentsPieceHashesPost request with any body
	TorrentsPieceHashesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPieceHashesPostResponse, error)

	TorrentsPieceHashesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPieceHashesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPieceHashesPostResponse, error)

	// TorrentsPieceStatesPost request with any body
	TorrentsPieceStatesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPieceStatesPostResponse, error)

	TorrentsPieceStatesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPieceStatesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPieceStatesPostResponse, error)

	// TorrentsPropertiesPost request with any body
	TorrentsPropertiesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPropertiesPostResponse, error)

	TorrentsPropertiesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPropertiesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPropertiesPostResponse, error)

	// TorrentsReannouncePost request with any body
	TorrentsReannouncePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsReannouncePostResponse, error)

	TorrentsReannouncePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsReannouncePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsReannouncePostResponse, error)

	// TorrentsRecheckPost request with any body
	TorrentsRecheckPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRecheckPostResponse, error)

	TorrentsRecheckPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRecheckPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRecheckPostResponse, error)

	// TorrentsRemoveCategoriesPost request with any body
	TorrentsRemoveCategoriesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveCategoriesPostResponse, error)

	TorrentsRemoveCategoriesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveCategoriesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveCategoriesPostResponse, error)

	// TorrentsRemoveTagsPost request with any body
	TorrentsRemoveTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveTagsPostResponse, error)

	TorrentsRemoveTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveTagsPostResponse, error)

	// TorrentsRemoveTrackersPost request with any body
	TorrentsRemoveTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveTrackersPostResponse, error)

	TorrentsRemoveTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveTrackersPostResponse, error)

	// TorrentsRenamePost request with any body
	TorrentsRenamePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenamePostResponse, error)

	TorrentsRenamePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenamePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenamePostResponse, error)

	// TorrentsRenameFilePost request with any body
	TorrentsRenameFilePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenameFilePostResponse, error)

	TorrentsRenameFilePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenameFilePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenameFilePostResponse, error)

	// TorrentsRenameFolderPost request with any body
	TorrentsRenameFolderPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenameFolderPostResponse, error)

	TorrentsRenameFolderPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenameFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenameFolderPostResponse, error)

	// TorrentsResumePost request with any body
	TorrentsResumePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsResumePostResponse, error)

	TorrentsResumePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsResumePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsResumePostResponse, error)

	// TorrentsSetAutoManagementPost request with any body
	TorrentsSetAutoManagementPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetAutoManagementPostResponse, error)

	TorrentsSetAutoManagementPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetAutoManagementPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetAutoManagementPostResponse, error)

	// TorrentsSetCategoryPost request with any body
	TorrentsSetCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetCategoryPostResponse, error)

	TorrentsSetCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetCategoryPostResponse, error)

	// TorrentsSetDownloadLimitPost request with any body
	TorrentsSetDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetDownloadLimitPostResponse, error)

	TorrentsSetDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetDownloadLimitPostResponse, error)

	// TorrentsSetForceStartPost request with any body
	TorrentsSetForceStartPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetForceStartPostResponse, error)

	TorrentsSetForceStartPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetForceStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetForceStartPostResponse, error)

	// TorrentsSetLocationPost request with any body
	TorrentsSetLocationPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetLocationPostResponse, error)

	TorrentsSetLocationPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetLocationPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetLocationPostResponse, error)

	// TorrentsSetShareLimitsPost request with any body
	TorrentsSetShareLimitsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetShareLimitsPostResponse, error)

	TorrentsSetShareLimitsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetShareLimitsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetShareLimitsPostResponse, error)

	// TorrentsSetSuperSeedingPost request with any body
	TorrentsSetSuperSeedingPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetSuperSeedingPostResponse, error)

	TorrentsSetSuperSeedingPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetSuperSeedingPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetSuperSeedingPostResponse, error)

	// TorrentsSetUploadLimitPost request with any body
	TorrentsSetUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetUploadLimitPostResponse, error)

	TorrentsSetUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetUploadLimitPostResponse, error)

	// TorrentsTagsGet request
	TorrentsTagsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TorrentsTagsGetResponse, error)

	// TorrentsToggleFirstLastPiecePrioPost request with any body
	TorrentsToggleFirstLastPiecePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsToggleFirstLastPiecePrioPostResponse, error)

	TorrentsToggleFirstLastPiecePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsToggleFirstLastPiecePrioPostResponse, error)

	// TorrentsToggleSequentialDownloadPost request with any body
	TorrentsToggleSequentialDownloadPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsToggleSequentialDownloadPostResponse, error)

	TorrentsToggleSequentialDownloadPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsToggleSequentialDownloadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsToggleSequentialDownloadPostResponse, error)

	// TorrentsTopPrioPost request with any body
	TorrentsTopPrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsTopPrioPostResponse, error)

	TorrentsTopPrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsTopPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsTopPrioPostResponse, error)

	// TorrentsTrackersPost request with any body
	TorrentsTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsTrackersPostResponse, error)

	TorrentsTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsTrackersPostResponse, error)

	// TorrentsUploadLimitPost request with any body
	TorrentsUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsUploadLimitPostResponse, error)

	TorrentsUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsUploadLimitPostResponse, error)

	// TorrentWebseedsPost request with any body
	TorrentWebseedsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentWebseedsPostResponse, error)

	TorrentWebseedsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentWebseedsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentWebseedsPostResponse, error)

	// TransferBanPeersPost request with any body
	TransferBanPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferBanPeersPostResponse, error)

	TransferBanPeersPostWithFormdataBodyWithResponse(ctx context.Context, body TransferBanPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferBanPeersPostResponse, error)

	// TransferDownloadLimitGet request
	TransferDownloadLimitGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferDownloadLimitGetResponse, error)

	// TransferInfoGet request
	TransferInfoGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferInfoGetResponse, error)

	// TransferSetDownloadLimitPost request with any body
	TransferSetDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferSetDownloadLimitPostResponse, error)

	TransferSetDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TransferSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferSetDownloadLimitPostResponse, error)

	// TransferSetUploadLimitPost request with any body
	TransferSetUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferSetUploadLimitPostResponse, error)

	TransferSetUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TransferSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferSetUploadLimitPostResponse, error)

	// TransferSpeedLimitsModeGet request
	TransferSpeedLimitsModeGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferSpeedLimitsModeGetResponse, error)

	// TransferToggleSpeedLimitsModeGet request
	TransferToggleSpeedLimitsModeGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferToggleSpeedLimitsModeGetResponse, error)

	// TransferUploadLimitGet request
	TransferUploadLimitGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferUploadLimitGetResponse, error)
}

type AppBuildInfoGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildInfo
}

// Status returns HTTPResponse.Status
func (r AppBuildInfoGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppBuildInfoGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppDefaultSavePathGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppDefaultSavePathGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppDefaultSavePathGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreferencesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preferences
}

// Status returns HTTPResponse.Status
func (r AppPreferencesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreferencesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppSetPreferencesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppSetPreferencesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppSetPreferencesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppShutdownGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppShutdownGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppShutdownGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppVersionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppVersionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppVersionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppWebapiVersionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppWebapiVersionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppWebapiVersionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLoginPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AuthLoginPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLoginPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLogoutPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AuthLogoutPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLogoutPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogMainPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MainLog
}

// Status returns HTTPResponse.Status
func (r LogMainPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogMainPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogPeersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PeersLog
}

// Status returns HTTPResponse.Status
func (r LogPeersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogPeersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssAddFeedPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssAddFeedPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssAddFeedPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssAddFolderPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssAddFolderPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssAddFolderPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssItemsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r RssItemsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssItemsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssMarkAsReadPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssMarkAsReadPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssMarkAsReadPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssMatchingArticlesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string][]string
}

// Status returns HTTPResponse.Status
func (r RssMatchingArticlesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssMatchingArticlesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssMoveItemPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssMoveItemPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssMoveItemPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssRefreshItemPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssRefreshItemPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssRefreshItemPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssRemoveItemPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssRemoveItemPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssRemoveItemPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssRemoveRulePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssRemoveRulePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssRemoveRulePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssRenameRulePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssRenameRulePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssRenameRulePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssRulesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]RssRuleDef
}

// Status returns HTTPResponse.Status
func (r RssRulesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssRulesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssSetRulePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssSetRulePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssSetRulePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDeletePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchDeletePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDeletePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchEnablePluginPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchEnablePluginPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchEnablePluginPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchInstallPluginPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchInstallPluginPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchInstallPluginPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPluginsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SearchPlugin
}

// Status returns HTTPResponse.Status
func (r SearchPluginsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPluginsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResultsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchResults
}

// Status returns HTTPResponse.Status
func (r SearchResultsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResultsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchStartPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchJob
}

// Status returns HTTPResponse.Status
func (r SearchStartPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchStartPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchStatusPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SearchJobStatus
}

// Status returns HTTPResponse.Status
func (r SearchStatusPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchStatusPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchStopPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchStopPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchStopPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUninstallPluginPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchUninstallPluginPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUninstallPluginPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUpdatePluginsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchUpdatePluginsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUpdatePluginsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncMaindataPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MainData
}

// Status returns HTTPResponse.Status
func (r SyncMaindataPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncMaindataPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncTorrentPeersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TorrentPeers
}

// Status returns HTTPResponse.Status
func (r SyncTorrentPeersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncTorrentPeersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsAddPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsAddPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsAddPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsAddPeersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsAddPeersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsAddPeersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsAddTagsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsAddTagsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsAddTagsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsAddTrackersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsAddTrackersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsAddTrackersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsBottomPrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsBottomPrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsBottomPrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsCategoriesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]TorrentsCategory
}

// Status returns HTTPResponse.Status
func (r TorrentsCategoriesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsCategoriesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsCreateCategoryPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsCreateCategoryPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsCreateCategoryPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsCreateTagsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsCreateTagsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsCreateTagsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsDecreasePrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsDecreasePrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsDecreasePrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsDeletePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsDeletePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsDeletePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsDeleteTagsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsDeleteTagsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsDeleteTagsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsDownloadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TorrentsLimit
}

// Status returns HTTPResponse.Status
func (r TorrentsDownloadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsDownloadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsEditCategoryPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsEditCategoryPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsEditCategoryPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsEditTrackerPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsEditTrackerPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsEditTrackerPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsFilePrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsFilePrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsFilePrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsFilesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TorrentsFiles
}

// Status returns HTTPResponse.Status
func (r TorrentsFilesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsFilesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsIncreasePrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsIncreasePrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsIncreasePrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsInfoPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TorrentInfo
}

// Status returns HTTPResponse.Status
func (r TorrentsInfoPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsInfoPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsPausePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsPausePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsPausePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsPieceHashesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r TorrentsPieceHashesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsPieceHashesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsPieceStatesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]int32
}

// Status returns HTTPResponse.Status
func (r TorrentsPieceStatesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsPieceStatesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsPropertiesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TorrentsProperties
}

// Status returns HTTPResponse.Status
func (r TorrentsPropertiesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsPropertiesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsReannouncePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsReannouncePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsReannouncePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRecheckPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRecheckPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRecheckPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRemoveCategoriesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRemoveCategoriesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRemoveCategoriesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRemoveTagsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRemoveTagsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRemoveTagsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRemoveTrackersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRemoveTrackersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRemoveTrackersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRenamePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRenamePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRenamePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRenameFilePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRenameFilePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRenameFilePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRenameFolderPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRenameFolderPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRenameFolderPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsResumePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsResumePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsResumePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetAutoManagementPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetAutoManagementPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetAutoManagementPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetCategoryPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetCategoryPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetCategoryPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetDownloadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetDownloadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetDownloadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetForceStartPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetForceStartPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetForceStartPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetLocationPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetLocationPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetLocationPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetShareLimitsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetShareLimitsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetShareLimitsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetSuperSeedingPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetSuperSeedingPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetSuperSeedingPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetUploadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetUploadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetUploadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsTagsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r TorrentsTagsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsTagsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsToggleFirstLastPiecePrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsToggleFirstLastPiecePrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsToggleFirstLastPiecePrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsToggleSequentialDownloadPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsToggleSequentialDownloadPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsToggleSequentialDownloadPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsTopPrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsTopPrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsTopPrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsTrackersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TorrentsTrackers
}

// Status returns HTTPResponse.Status
func (r TorrentsTrackersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsTrackersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsUploadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TorrentsLimit
}

// Status returns HTTPResponse.Status
func (r TorrentsUploadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsUploadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentWebseedsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TorrentsWebseeds
}

// Status returns HTTPResponse.Status
func (r TorrentWebseedsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentWebseedsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferBanPeersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferBanPeersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferBanPeersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferDownloadLimitGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferDownloadLimitGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferDownloadLimitGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferInfoGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferInfo
}

// Status returns HTTPResponse.Status
func (r TransferInfoGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferInfoGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferSetDownloadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferSetDownloadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferSetDownloadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferSetUploadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferSetUploadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferSetUploadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferSpeedLimitsModeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferSpeedLimitsModeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferSpeedLimitsModeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferToggleSpeedLimitsModeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferToggleSpeedLimitsModeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferToggleSpeedLimitsModeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferUploadLimitGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferUploadLimitGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferUploadLimitGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AppBuildInfoGetWithResponse request returning *AppBuildInfoGetResponse
func (c *ClientWithResponses) AppBuildInfoGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppBuildInfoGetResponse, error) {
	rsp, err := c.AppBuildInfoGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppBuildInfoGetResponse(rsp)
}

// AppDefaultSavePathGetWithResponse request returning *AppDefaultSavePathGetResponse
func (c *ClientWithResponses) AppDefaultSavePathGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppDefaultSavePathGetResponse, error) {
	rsp, err := c.AppDefaultSavePathGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppDefaultSavePathGetResponse(rsp)
}

// AppPreferencesGetWithResponse request returning *AppPreferencesGetResponse
func (c *ClientWithResponses) AppPreferencesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppPreferencesGetResponse, error) {
	rsp, err := c.AppPreferencesGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppPreferencesGetResponse(rsp)
}

// AppSetPreferencesPostWithBodyWithResponse request with arbitrary body returning *AppSetPreferencesPostResponse
func (c *ClientWithResponses) AppSetPreferencesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppSetPreferencesPostResponse, error) {
	rsp, err := c.AppSetPreferencesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppSetPreferencesPostResponse(rsp)
}

func (c *ClientWithResponses) AppSetPreferencesPostWithFormdataBodyWithResponse(ctx context.Context, body AppSetPreferencesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*AppSetPreferencesPostResponse, error) {
	rsp, err := c.AppSetPreferencesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppSetPreferencesPostResponse(rsp)
}

// AppShutdownGetWithResponse request returning *AppShutdownGetResponse
func (c *ClientWithResponses) AppShutdownGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppShutdownGetResponse, error) {
	rsp, err := c.AppShutdownGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppShutdownGetResponse(rsp)
}

// AppVersionGetWithResponse request returning *AppVersionGetResponse
func (c *ClientWithResponses) AppVersionGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppVersionGetResponse, error) {
	rsp, err := c.AppVersionGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppVersionGetResponse(rsp)
}

// AppWebapiVersionGetWithResponse request returning *AppWebapiVersionGetResponse
func (c *ClientWithResponses) AppWebapiVersionGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppWebapiVersionGetResponse, error) {
	rsp, err := c.AppWebapiVersionGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppWebapiVersionGetResponse(rsp)
}

// AuthLoginPostWithBodyWithResponse request with arbitrary body returning *AuthLoginPostResponse
func (c *ClientWithResponses) AuthLoginPostWithBodyWithResponse(ctx context.Context, params *AuthLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginPostResponse, error) {
	rsp, err := c.AuthLoginPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginPostResponse(rsp)
}

func (c *ClientWithResponses) AuthLoginPostWithFormdataBodyWithResponse(ctx context.Context, params *AuthLoginPostParams, body AuthLoginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginPostResponse, error) {
	rsp, err := c.AuthLoginPostWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginPostResponse(rsp)
}

// AuthLogoutPostWithResponse request returning *AuthLogoutPostResponse
func (c *ClientWithResponses) AuthLogoutPostWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthLogoutPostResponse, error) {
	rsp, err := c.AuthLogoutPost(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLogoutPostResponse(rsp)
}

// LogMainPostWithBodyWithResponse request with arbitrary body returning *LogMainPostResponse
func (c *ClientWithResponses) LogMainPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogMainPostResponse, error) {
	rsp, err := c.LogMainPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogMainPostResponse(rsp)
}

func (c *ClientWithResponses) LogMainPostWithFormdataBodyWithResponse(ctx context.Context, body LogMainPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*LogMainPostResponse, error) {
	rsp, err := c.LogMainPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogMainPostResponse(rsp)
}

// LogPeersPostWithBodyWithResponse request with arbitrary body returning *LogPeersPostResponse
func (c *ClientWithResponses) LogPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogPeersPostResponse, error) {
	rsp, err := c.LogPeersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogPeersPostResponse(rsp)
}

func (c *ClientWithResponses) LogPeersPostWithFormdataBodyWithResponse(ctx context.Context, body LogPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*LogPeersPostResponse, error) {
	rsp, err := c.LogPeersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogPeersPostResponse(rsp)
}

// RssAddFeedPostWithBodyWithResponse request with arbitrary body returning *RssAddFeedPostResponse
func (c *ClientWithResponses) RssAddFeedPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssAddFeedPostResponse, error) {
	rsp, err := c.RssAddFeedPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssAddFeedPostResponse(rsp)
}

func (c *ClientWithResponses) RssAddFeedPostWithFormdataBodyWithResponse(ctx context.Context, body RssAddFeedPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssAddFeedPostResponse, error) {
	rsp, err := c.RssAddFeedPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssAddFeedPostResponse(rsp)
}

// RssAddFolderPostWithBodyWithResponse request with arbitrary body returning *RssAddFolderPostResponse
func (c *ClientWithResponses) RssAddFolderPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssAddFolderPostResponse, error) {
	rsp, err := c.RssAddFolderPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssAddFolderPostResponse(rsp)
}

func (c *ClientWithResponses) RssAddFolderPostWithFormdataBodyWithResponse(ctx context.Context, body RssAddFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssAddFolderPostResponse, error) {
	rsp, err := c.RssAddFolderPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssAddFolderPostResponse(rsp)
}

// RssItemsPostWithBodyWithResponse request with arbitrary body returning *RssItemsPostResponse
func (c *ClientWithResponses) RssItemsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssItemsPostResponse, error) {
	rsp, err := c.RssItemsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssItemsPostResponse(rsp)
}

func (c *ClientWithResponses) RssItemsPostWithFormdataBodyWithResponse(ctx context.Context, body RssItemsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssItemsPostResponse, error) {
	rsp, err := c.RssItemsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssItemsPostResponse(rsp)
}

// RssMarkAsReadPostWithBodyWithResponse request with arbitrary body returning *RssMarkAsReadPostResponse
func (c *ClientWithResponses) RssMarkAsReadPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMarkAsReadPostResponse, error) {
	rsp, err := c.RssMarkAsReadPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMarkAsReadPostResponse(rsp)
}

func (c *ClientWithResponses) RssMarkAsReadPostWithFormdataBodyWithResponse(ctx context.Context, body RssMarkAsReadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMarkAsReadPostResponse, error) {
	rsp, err := c.RssMarkAsReadPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMarkAsReadPostResponse(rsp)
}

// RssMatchingArticlesPostWithBodyWithResponse request with arbitrary body returning *RssMatchingArticlesPostResponse
func (c *ClientWithResponses) RssMatchingArticlesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMatchingArticlesPostResponse, error) {
	rsp, err := c.RssMatchingArticlesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMatchingArticlesPostResponse(rsp)
}

func (c *ClientWithResponses) RssMatchingArticlesPostWithFormdataBodyWithResponse(ctx context.Context, body RssMatchingArticlesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMatchingArticlesPostResponse, error) {
	rsp, err := c.RssMatchingArticlesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMatchingArticlesPostResponse(rsp)
}

// RssMoveItemPostWithBodyWithResponse request with arbitrary body returning *RssMoveItemPostResponse
func (c *ClientWithResponses) RssMoveItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMoveItemPostResponse, error) {
	rsp, err := c.RssMoveItemPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMoveItemPostResponse(rsp)
}

func (c *ClientWithResponses) RssMoveItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssMoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMoveItemPostResponse, error) {
	rsp, err := c.RssMoveItemPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMoveItemPostResponse(rsp)
}

// RssRefreshItemPostWithBodyWithResponse request with arbitrary body returning *RssRefreshItemPostResponse
func (c *ClientWithResponses) RssRefreshItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRefreshItemPostResponse, error) {
	rsp, err := c.RssRefreshItemPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRefreshItemPostResponse(rsp)
}

func (c *ClientWithResponses) RssRefreshItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssRefreshItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRefreshItemPostResponse, error) {
	rsp, err := c.RssRefreshItemPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRefreshItemPostResponse(rsp)
}

// RssRemoveItemPostWithBodyWithResponse request with arbitrary body returning *RssRemoveItemPostResponse
func (c *ClientWithResponses) RssRemoveItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRemoveItemPostResponse, error) {
	rsp, err := c.RssRemoveItemPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRemoveItemPostResponse(rsp)
}

func (c *ClientWithResponses) RssRemoveItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssRemoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRemoveItemPostResponse, error) {
	rsp, err := c.RssRemoveItemPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRemoveItemPostResponse(rsp)
}

// RssRemoveRulePostWithBodyWithResponse request with arbitrary body returning *RssRemoveRulePostResponse
func (c *ClientWithResponses) RssRemoveRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRemoveRulePostResponse, error) {
	rsp, err := c.RssRemoveRulePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRemoveRulePostResponse(rsp)
}

func (c *ClientWithResponses) RssRemoveRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssRemoveRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRemoveRulePostResponse, error) {
	rsp, err := c.RssRemoveRulePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRemoveRulePostResponse(rsp)
}

// RssRenameRulePostWithBodyWithResponse request with arbitrary body returning *RssRenameRulePostResponse
func (c *ClientWithResponses) RssRenameRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRenameRulePostResponse, error) {
	rsp, err := c.RssRenameRulePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRenameRulePostResponse(rsp)
}

func (c *ClientWithResponses) RssRenameRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssRenameRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRenameRulePostResponse, error) {
	rsp, err := c.RssRenameRulePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRenameRulePostResponse(rsp)
}

// RssRulesGetWithResponse request returning *RssRulesGetResponse
func (c *ClientWithResponses) RssRulesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RssRulesGetResponse, error) {
	rsp, err := c.RssRulesGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRulesGetResponse(rsp)
}

// RssSetRulePostWithBodyWithResponse request with arbitrary body returning *RssSetRulePostResponse
func (c *ClientWithResponses) RssSetRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssSetRulePostResponse, error) {
	rsp, err := c.RssSetRulePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssSetRulePostResponse(rsp)
}

func (c *ClientWithResponses) RssSetRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssSetRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssSetRulePostResponse, error) {
	rsp, err := c.RssSetRulePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssSetRulePostResponse(rsp)
}

// SearchDeletePostWithBodyWithResponse request with arbitrary body returning *SearchDeletePostResponse
func (c *ClientWithResponses) SearchDeletePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDeletePostResponse, error) {
	rsp, err := c.SearchDeletePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDeletePostResponse(rsp)
}

func (c *ClientWithResponses) SearchDeletePostWithFormdataBodyWithResponse(ctx context.Context, body SearchDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchDeletePostResponse, error) {
	rsp, err := c.SearchDeletePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDeletePostResponse(rsp)
}

// SearchEnablePluginPostWithBodyWithResponse request with arbitrary body returning *SearchEnablePluginPostResponse
func (c *ClientWithResponses) SearchEnablePluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchEnablePluginPostResponse, error) {
	rsp, err := c.SearchEnablePluginPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchEnablePluginPostResponse(rsp)
}

func (c *ClientWithResponses) SearchEnablePluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchEnablePluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchEnablePluginPostResponse, error) {
	rsp, err := c.SearchEnablePluginPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchEnablePluginPostResponse(rsp)
}

// SearchInstallPluginPostWithBodyWithResponse request with arbitrary body returning *SearchInstallPluginPostResponse
func (c *ClientWithResponses) SearchInstallPluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchInstallPluginPostResponse, error) {
	rsp, err := c.SearchInstallPluginPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchInstallPluginPostResponse(rsp)
}

func (c *ClientWithResponses) SearchInstallPluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchInstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchInstallPluginPostResponse, error) {
	rsp, err := c.SearchInstallPluginPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchInstallPluginPostResponse(rsp)
}

// SearchPluginsGetWithResponse request returning *SearchPluginsGetResponse
func (c *ClientWithResponses) SearchPluginsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchPluginsGetResponse, error) {
	rsp, err := c.SearchPluginsGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPluginsGetResponse(rsp)
}

// SearchResultsPostWithBodyWithResponse request with arbitrary body returning *SearchResultsPostResponse
func (c *ClientWithResponses) SearchResultsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchResultsPostResponse, error) {
	rsp, err := c.SearchResultsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResultsPostResponse(rsp)
}

func (c *ClientWithResponses) SearchResultsPostWithFormdataBodyWithResponse(ctx context.Context, body SearchResultsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchResultsPostResponse, error) {
	rsp, err := c.SearchResultsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResultsPostResponse(rsp)
}

// SearchStartPostWithBodyWithResponse request with arbitrary body returning *SearchStartPostResponse
func (c *ClientWithResponses) SearchStartPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStartPostResponse, error) {
	rsp, err := c.SearchStartPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStartPostResponse(rsp)
}

func (c *ClientWithResponses) SearchStartPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStartPostResponse, error) {
	rsp, err := c.SearchStartPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStartPostResponse(rsp)
}

// SearchStatusPostWithBodyWithResponse request with arbitrary body returning *SearchStatusPostResponse
func (c *ClientWithResponses) SearchStatusPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStatusPostResponse, error) {
	rsp, err := c.SearchStatusPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStatusPostResponse(rsp)
}

func (c *ClientWithResponses) SearchStatusPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStatusPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStatusPostResponse, error) {
	rsp, err := c.SearchStatusPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStatusPostResponse(rsp)
}

// SearchStopPostWithBodyWithResponse request with arbitrary body returning *SearchStopPostResponse
func (c *ClientWithResponses) SearchStopPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStopPostResponse, error) {
	rsp, err := c.SearchStopPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStopPostResponse(rsp)
}

func (c *ClientWithResponses) SearchStopPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStopPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStopPostResponse, error) {
	rsp, err := c.SearchStopPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStopPostResponse(rsp)
}

// SearchUninstallPluginPostWithBodyWithResponse request with arbitrary body returning *SearchUninstallPluginPostResponse
func (c *ClientWithResponses) SearchUninstallPluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUninstallPluginPostResponse, error) {
	rsp, err := c.SearchUninstallPluginPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUninstallPluginPostResponse(rsp)
}

func (c *ClientWithResponses) SearchUninstallPluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchUninstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchUninstallPluginPostResponse, error) {
	rsp, err := c.SearchUninstallPluginPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUninstallPluginPostResponse(rsp)
}

// SearchUpdatePluginsPostWithResponse request returning *SearchUpdatePluginsPostResponse
func (c *ClientWithResponses) SearchUpdatePluginsPostWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchUpdatePluginsPostResponse, error) {
	rsp, err := c.SearchUpdatePluginsPost(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUpdatePluginsPostResponse(rsp)
}

// SyncMaindataPostWithBodyWithResponse request with arbitrary body returning *SyncMaindataPostResponse
func (c *ClientWithResponses) SyncMaindataPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncMaindataPostResponse, error) {
	rsp, err := c.SyncMaindataPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncMaindataPostResponse(rsp)
}

func (c *ClientWithResponses) SyncMaindataPostWithFormdataBodyWithResponse(ctx context.Context, body SyncMaindataPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SyncMaindataPostResponse, error) {
	rsp, err := c.SyncMaindataPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncMaindataPostResponse(rsp)
}

// SyncTorrentPeersPostWithBodyWithResponse request with arbitrary body returning *SyncTorrentPeersPostResponse
func (c *ClientWithResponses) SyncTorrentPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncTorrentPeersPostResponse, error) {
	rsp, err := c.SyncTorrentPeersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncTorrentPeersPostResponse(rsp)
}

func (c *ClientWithResponses) SyncTorrentPeersPostWithFormdataBodyWithResponse(ctx context.Context, body SyncTorrentPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SyncTorrentPeersPostResponse, error) {
	rsp, err := c.SyncTorrentPeersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncTorrentPeersPostResponse(rsp)
}

// TorrentsAddPostWithBodyWithResponse request with arbitrary body returning *TorrentsAddPostResponse
func (c *ClientWithResponses) TorrentsAddPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddPostResponse, error) {
	rsp, err := c.TorrentsAddPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddPostResponse(rsp)
}

// TorrentsAddPeersPostWithBodyWithResponse request with arbitrary body returning *TorrentsAddPeersPostResponse
func (c *ClientWithResponses) TorrentsAddPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddPeersPostResponse, error) {
	rsp, err := c.TorrentsAddPeersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddPeersPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsAddPeersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddPeersPostResponse, error) {
	rsp, err := c.TorrentsAddPeersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddPeersPostResponse(rsp)
}

// TorrentsAddTagsPostWithBodyWithResponse request with arbitrary body returning *TorrentsAddTagsPostResponse
func (c *ClientWithResponses) TorrentsAddTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddTagsPostResponse, error) {
	rsp, err := c.TorrentsAddTagsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddTagsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsAddTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddTagsPostResponse, error) {
	rsp, err := c.TorrentsAddTagsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddTagsPostResponse(rsp)
}

// TorrentsAddTrackersPostWithBodyWithResponse request with arbitrary body returning *TorrentsAddTrackersPostResponse
func (c *ClientWithResponses) TorrentsAddTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddTrackersPostResponse, error) {
	rsp, err := c.TorrentsAddTrackersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddTrackersPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsAddTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddTrackersPostResponse, error) {
	rsp, err := c.TorrentsAddTrackersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddTrackersPostResponse(rsp)
}

// TorrentsBottomPrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsBottomPrioPostResponse
func (c *ClientWithResponses) TorrentsBottomPrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsBottomPrioPostResponse, error) {
	rsp, err := c.TorrentsBottomPrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsBottomPrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsBottomPrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsBottomPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsBottomPrioPostResponse, error) {
	rsp, err := c.TorrentsBottomPrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsBottomPrioPostResponse(rsp)
}

// TorrentsCategoriesGetWithResponse request returning *TorrentsCategoriesGetResponse
func (c *ClientWithResponses) TorrentsCategoriesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TorrentsCategoriesGetResponse, error) {
	rsp, err := c.TorrentsCategoriesGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsCategoriesGetResponse(rsp)
}

// TorrentsCreateCategoryPostWithBodyWithResponse request with arbitrary body returning *TorrentsCreateCategoryPostResponse
func (c *ClientWithResponses) TorrentsCreateCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsCreateCategoryPostResponse, error) {
	rsp, err := c.TorrentsCreateCategoryPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsCreateCategoryPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsCreateCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsCreateCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsCreateCategoryPostResponse, error) {
	rsp, err := c.TorrentsCreateCategoryPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsCreateCategoryPostResponse(rsp)
}

// TorrentsCreateTagsPostWithBodyWithResponse request with arbitrary body returning *TorrentsCreateTagsPostResponse
func (c *ClientWithResponses) TorrentsCreateTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsCreateTagsPostResponse, error) {
	rsp, err := c.TorrentsCreateTagsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsCreateTagsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsCreateTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsCreateTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsCreateTagsPostResponse, error) {
	rsp, err := c.TorrentsCreateTagsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsCreateTagsPostResponse(rsp)
}

// TorrentsDecreasePrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsDecreasePrioPostResponse
func (c *ClientWithResponses) TorrentsDecreasePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDecreasePrioPostResponse, error) {
	rsp, err := c.TorrentsDecreasePrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDecreasePrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsDecreasePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDecreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDecreasePrioPostResponse, error) {
	rsp, err := c.TorrentsDecreasePrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDecreasePrioPostResponse(rsp)
}

// TorrentsDeletePostWithBodyWithResponse request with arbitrary body returning *TorrentsDeletePostResponse
func (c *ClientWithResponses) TorrentsDeletePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDeletePostResponse, error) {
	rsp, err := c.TorrentsDeletePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDeletePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsDeletePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDeletePostResponse, error) {
	rsp, err := c.TorrentsDeletePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDeletePostResponse(rsp)
}

// TorrentsDeleteTagsPostWithBodyWithResponse request with arbitrary body returning *TorrentsDeleteTagsPostResponse
func (c *ClientWithResponses) TorrentsDeleteTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDeleteTagsPostResponse, error) {
	rsp, err := c.TorrentsDeleteTagsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDeleteTagsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsDeleteTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDeleteTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDeleteTagsPostResponse, error) {
	rsp, err := c.TorrentsDeleteTagsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDeleteTagsPostResponse(rsp)
}

// TorrentsDownloadLimitPostWithBodyWithResponse request with arbitrary body returning *TorrentsDownloadLimitPostResponse
func (c *ClientWithResponses) TorrentsDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDownloadLimitPostResponse, error) {
	rsp, err := c.TorrentsDownloadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDownloadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDownloadLimitPostResponse, error) {
	rsp, err := c.TorrentsDownloadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDownloadLimitPostResponse(rsp)
}

// TorrentsEditCategoryPostWithBodyWithResponse request with arbitrary body returning *TorrentsEditCategoryPostResponse
func (c *ClientWithResponses) TorrentsEditCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsEditCategoryPostResponse, error) {
	rsp, err := c.TorrentsEditCategoryPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsEditCategoryPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsEditCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsEditCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsEditCategoryPostResponse, error) {
	rsp, err := c.TorrentsEditCategoryPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsEditCategoryPostResponse(rsp)
}

// TorrentsEditTrackerPostWithBodyWithResponse request with arbitrary body returning *TorrentsEditTrackerPostResponse
func (c *ClientWithResponses) TorrentsEditTrackerPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsEditTrackerPostResponse, error) {
	rsp, err := c.TorrentsEditTrackerPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsEditTrackerPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsEditTrackerPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsEditTrackerPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsEditTrackerPostResponse, error) {
	rsp, err := c.TorrentsEditTrackerPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsEditTrackerPostResponse(rsp)
}

// TorrentsFilePrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsFilePrioPostResponse
func (c *ClientWithResponses) TorrentsFilePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsFilePrioPostResponse, error) {
	rsp, err := c.TorrentsFilePrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsFilePrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsFilePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsFilePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsFilePrioPostResponse, error) {
	rsp, err := c.TorrentsFilePrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsFilePrioPostResponse(rsp)
}

// TorrentsFilesPostWithBodyWithResponse request with arbitrary body returning *TorrentsFilesPostResponse
func (c *ClientWithResponses) TorrentsFilesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsFilesPostResponse, error) {
	rsp, err := c.TorrentsFilesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsFilesPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsFilesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsFilesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsFilesPostResponse, error) {
	rsp, err := c.TorrentsFilesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsFilesPostResponse(rsp)
}

// TorrentsIncreasePrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsIncreasePrioPostResponse
func (c *ClientWithResponses) TorrentsIncreasePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsIncreasePrioPostResponse, error) {
	rsp, err := c.TorrentsIncreasePrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsIncreasePrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsIncreasePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsIncreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsIncreasePrioPostResponse, error) {
	rsp, err := c.TorrentsIncreasePrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsIncreasePrioPostResponse(rsp)
}

// TorrentsInfoPostWithBodyWithResponse request with arbitrary body returning *TorrentsInfoPostResponse
func (c *ClientWithResponses) TorrentsInfoPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsInfoPostResponse, error) {
	rsp, err := c.TorrentsInfoPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsInfoPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsInfoPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsInfoPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsInfoPostResponse, error) {
	rsp, err := c.TorrentsInfoPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsInfoPostResponse(rsp)
}

// TorrentsPausePostWithBodyWithResponse request with arbitrary body returning *TorrentsPausePostResponse
func (c *ClientWithResponses) TorrentsPausePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPausePostResponse, error) {
	rsp, err := c.TorrentsPausePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPausePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsPausePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPausePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPausePostResponse, error) {
	rsp, err := c.TorrentsPausePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPausePostResponse(rsp)
}

// TorrentsPieceHashesPostWithBodyWithResponse request with arbitrary body returning *TorrentsPieceHashesPostResponse
func (c *ClientWithResponses) TorrentsPieceHashesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPieceHashesPostResponse, error) {
	rsp, err := c.TorrentsPieceHashesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPieceHashesPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsPieceHashesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPieceHashesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPieceHashesPostResponse, error) {
	rsp, err := c.TorrentsPieceHashesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPieceHashesPostResponse(rsp)
}

// TorrentsPieceStatesPostWithBodyWithResponse request with arbitrary body returning *TorrentsPieceStatesPostResponse
func (c *ClientWithResponses) TorrentsPieceStatesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPieceStatesPostResponse, error) {
	rsp, err := c.TorrentsPieceStatesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPieceStatesPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsPieceStatesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPieceStatesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPieceStatesPostResponse, error) {
	rsp, err := c.TorrentsPieceStatesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPieceStatesPostResponse(rsp)
}

// TorrentsPropertiesPostWithBodyWithResponse request with arbitrary body returning *TorrentsPropertiesPostResponse
func (c *ClientWithResponses) TorrentsPropertiesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPropertiesPostResponse, error) {
	rsp, err := c.TorrentsPropertiesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPropertiesPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsPropertiesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPropertiesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPropertiesPostResponse, error) {
	rsp, err := c.TorrentsPropertiesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPropertiesPostResponse(rsp)
}

// TorrentsReannouncePostWithBodyWithResponse request with arbitrary body returning *TorrentsReannouncePostResponse
func (c *ClientWithResponses) TorrentsReannouncePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsReannouncePostResponse, error) {
	rsp, err := c.TorrentsReannouncePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsReannouncePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsReannouncePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsReannouncePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsReannouncePostResponse, error) {
	rsp, err := c.TorrentsReannouncePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsReannouncePostResponse(rsp)
}

// TorrentsRecheckPostWithBodyWithResponse request with arbitrary body returning *TorrentsRecheckPostResponse
func (c *ClientWithResponses) TorrentsRecheckPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRecheckPostResponse, error) {
	rsp, err := c.TorrentsRecheckPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRecheckPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRecheckPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRecheckPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRecheckPostResponse, error) {
	rsp, err := c.TorrentsRecheckPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRecheckPostResponse(rsp)
}

// TorrentsRemoveCategoriesPostWithBodyWithResponse request with arbitrary body returning *TorrentsRemoveCategoriesPostResponse
func (c *ClientWithResponses) TorrentsRemoveCategoriesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveCategoriesPostResponse, error) {
	rsp, err := c.TorrentsRemoveCategoriesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveCategoriesPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRemoveCategoriesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveCategoriesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveCategoriesPostResponse, error) {
	rsp, err := c.TorrentsRemoveCategoriesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveCategoriesPostResponse(rsp)
}

// TorrentsRemoveTagsPostWithBodyWithResponse request with arbitrary body returning *TorrentsRemoveTagsPostResponse
func (c *ClientWithResponses) TorrentsRemoveTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveTagsPostResponse, error) {
	rsp, err := c.TorrentsRemoveTagsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveTagsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRemoveTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveTagsPostResponse, error) {
	rsp, err := c.TorrentsRemoveTagsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveTagsPostResponse(rsp)
}

// TorrentsRemoveTrackersPostWithBodyWithResponse request with arbitrary body returning *TorrentsRemoveTrackersPostResponse
func (c *ClientWithResponses) TorrentsRemoveTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveTrackersPostResponse, error) {
	rsp, err := c.TorrentsRemoveTrackersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveTrackersPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRemoveTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveTrackersPostResponse, error) {
	rsp, err := c.TorrentsRemoveTrackersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveTrackersPostResponse(rsp)
}

// TorrentsRenamePostWithBodyWithResponse request with arbitrary body returning *TorrentsRenamePostResponse
func (c *ClientWithResponses) TorrentsRenamePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenamePostResponse, error) {
	rsp, err := c.TorrentsRenamePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenamePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRenamePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenamePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenamePostResponse, error) {
	rsp, err := c.TorrentsRenamePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenamePostResponse(rsp)
}

// TorrentsRenameFilePostWithBodyWithResponse request with arbitrary body returning *TorrentsRenameFilePostResponse
func (c *ClientWithResponses) TorrentsRenameFilePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenameFilePostResponse, error) {
	rsp, err := c.TorrentsRenameFilePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenameFilePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRenameFilePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenameFilePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenameFilePostResponse, error) {
	rsp, err := c.TorrentsRenameFilePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenameFilePostResponse(rsp)
}

// TorrentsRenameFolderPostWithBodyWithResponse request with arbitrary body returning *TorrentsRenameFolderPostResponse
func (c *ClientWithResponses) TorrentsRenameFolderPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenameFolderPostResponse, error) {
	rsp, err := c.TorrentsRenameFolderPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenameFolderPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRenameFolderPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenameFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenameFolderPostResponse, error) {
	rsp, err := c.TorrentsRenameFolderPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenameFolderPostResponse(rsp)
}

// TorrentsResumePostWithBodyWithResponse request with arbitrary body returning *TorrentsResumePostResponse
func (c *ClientWithResponses) TorrentsResumePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsResumePostResponse, error) {
	rsp, err := c.TorrentsResumePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsResumePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsResumePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsResumePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsResumePostResponse, error) {
	rsp, err := c.TorrentsResumePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsResumePostResponse(rsp)
}

// TorrentsSetAutoManagementPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetAutoManagementPostResponse
func (c *ClientWithResponses) TorrentsSetAutoManagementPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetAutoManagementPostResponse, error) {
	rsp, err := c.TorrentsSetAutoManagementPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetAutoManagementPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetAutoManagementPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetAutoManagementPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetAutoManagementPostResponse, error) {
	rsp, err := c.TorrentsSetAutoManagementPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetAutoManagementPostResponse(rsp)
}

// TorrentsSetCategoryPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetCategoryPostResponse
func (c *ClientWithResponses) TorrentsSetCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetCategoryPostResponse, error) {
	rsp, err := c.TorrentsSetCategoryPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetCategoryPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetCategoryPostResponse, error) {
	rsp, err := c.TorrentsSetCategoryPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetCategoryPostResponse(rsp)
}

// TorrentsSetDownloadLimitPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetDownloadLimitPostResponse
func (c *ClientWithResponses) TorrentsSetDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetDownloadLimitPostResponse, error) {
	rsp, err := c.TorrentsSetDownloadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetDownloadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetDownloadLimitPostResponse, error) {
	rsp, err := c.TorrentsSetDownloadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetDownloadLimitPostResponse(rsp)
}

// TorrentsSetForceStartPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetForceStartPostResponse
func (c *ClientWithResponses) TorrentsSetForceStartPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetForceStartPostResponse, error) {
	rsp, err := c.TorrentsSetForceStartPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetForceStartPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetForceStartPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetForceStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetForceStartPostResponse, error) {
	rsp, err := c.TorrentsSetForceStartPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetForceStartPostResponse(rsp)
}

// TorrentsSetLocationPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetLocationPostResponse
func (c *ClientWithResponses) TorrentsSetLocationPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetLocationPostResponse, error) {
	rsp, err := c.TorrentsSetLocationPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetLocationPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetLocationPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetLocationPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetLocationPostResponse, error) {
	rsp, err := c.TorrentsSetLocationPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetLocationPostResponse(rsp)
}

// TorrentsSetShareLimitsPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetShareLimitsPostResponse
func (c *ClientWithResponses) TorrentsSetShareLimitsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetShareLimitsPostResponse, error) {
	rsp, err := c.TorrentsSetShareLimitsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetShareLimitsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetShareLimitsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetShareLimitsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetShareLimitsPostResponse, error) {
	rsp, err := c.TorrentsSetShareLimitsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetShareLimitsPostResponse(rsp)
}

// TorrentsSetSuperSeedingPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetSuperSeedingPostResponse
func (c *ClientWithResponses) TorrentsSetSuperSeedingPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetSuperSeedingPostResponse, error) {
	rsp, err := c.TorrentsSetSuperSeedingPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetSuperSeedingPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetSuperSeedingPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetSuperSeedingPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetSuperSeedingPostResponse, error) {
	rsp, err := c.TorrentsSetSuperSeedingPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetSuperSeedingPostResponse(rsp)
}

// TorrentsSetUploadLimitPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetUploadLimitPostResponse
func (c *ClientWithResponses) TorrentsSetUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetUploadLimitPostResponse, error) {
	rsp, err := c.TorrentsSetUploadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetUploadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetUploadLimitPostResponse, error) {
	rsp, err := c.TorrentsSetUploadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetUploadLimitPostResponse(rsp)
}

// TorrentsTagsGetWithResponse request returning *TorrentsTagsGetResponse
func (c *ClientWithResponses) TorrentsTagsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TorrentsTagsGetResponse, error) {
	rsp, err := c.TorrentsTagsGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsTagsGetResponse(rsp)
}

// TorrentsToggleFirstLastPiecePrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsToggleFirstLastPiecePrioPostResponse
func (c *ClientWithResponses) TorrentsToggleFirstLastPiecePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsToggleFirstLastPiecePrioPostResponse, error) {
	rsp, err := c.TorrentsToggleFirstLastPiecePrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsToggleFirstLastPiecePrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsToggleFirstLastPiecePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsToggleFirstLastPiecePrioPostResponse, error) {
	rsp, err := c.TorrentsToggleFirstLastPiecePrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsToggleFirstLastPiecePrioPostResponse(rsp)
}

// TorrentsToggleSequentialDownloadPostWithBodyWithResponse request with arbitrary body returning *TorrentsToggleSequentialDownloadPostResponse
func (c *ClientWithResponses) TorrentsToggleSequentialDownloadPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsToggleSequentialDownloadPostResponse, error) {
	rsp, err := c.TorrentsToggleSequentialDownloadPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsToggleSequentialDownloadPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsToggleSequentialDownloadPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsToggleSequentialDownloadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsToggleSequentialDownloadPostResponse, error) {
	rsp, err := c.TorrentsToggleSequentialDownloadPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsToggleSequentialDownloadPostResponse(rsp)
}

// TorrentsTopPrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsTopPrioPostResponse
func (c *ClientWithResponses) TorrentsTopPrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsTopPrioPostResponse, error) {
	rsp, err := c.TorrentsTopPrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsTopPrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsTopPrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsTopPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsTopPrioPostResponse, error) {
	rsp, err := c.TorrentsTopPrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsTopPrioPostResponse(rsp)
}

// TorrentsTrackersPostWithBodyWithResponse request with arbitrary body returning *TorrentsTrackersPostResponse
func (c *ClientWithResponses) TorrentsTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsTrackersPostResponse, error) {
	rsp, err := c.TorrentsTrackersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsTrackersPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsTrackersPostResponse, error) {
	rsp, err := c.TorrentsTrackersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsTrackersPostResponse(rsp)
}

// TorrentsUploadLimitPostWithBodyWithResponse request with arbitrary body returning *TorrentsUploadLimitPostResponse
func (c *ClientWithResponses) TorrentsUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsUploadLimitPostResponse, error) {
	rsp, err := c.TorrentsUploadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsUploadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsUploadLimitPostResponse, error) {
	rsp, err := c.TorrentsUploadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsUploadLimitPostResponse(rsp)
}

// TorrentWebseedsPostWithBodyWithResponse request with arbitrary body returning *TorrentWebseedsPostResponse
func (c *ClientWithResponses) TorrentWebseedsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentWebseedsPostResponse, error) {
	rsp, err := c.TorrentWebseedsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentWebseedsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentWebseedsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentWebseedsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentWebseedsPostResponse, error) {
	rsp, err := c.TorrentWebseedsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentWebseedsPostResponse(rsp)
}

// TransferBanPeersPostWithBodyWithResponse request with arbitrary body returning *TransferBanPeersPostResponse
func (c *ClientWithResponses) TransferBanPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferBanPeersPostResponse, error) {
	rsp, err := c.TransferBanPeersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferBanPeersPostResponse(rsp)
}

func (c *ClientWithResponses) TransferBanPeersPostWithFormdataBodyWithResponse(ctx context.Context, body TransferBanPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferBanPeersPostResponse, error) {
	rsp, err := c.TransferBanPeersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferBanPeersPostResponse(rsp)
}

// TransferDownloadLimitGetWithResponse request returning *TransferDownloadLimitGetResponse
func (c *ClientWithResponses) TransferDownloadLimitGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferDownloadLimitGetResponse, error) {
	rsp, err := c.TransferDownloadLimitGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferDownloadLimitGetResponse(rsp)
}

// TransferInfoGetWithResponse request returning *TransferInfoGetResponse
func (c *ClientWithResponses) TransferInfoGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferInfoGetResponse, error) {
	rsp, err := c.TransferInfoGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferInfoGetResponse(rsp)
}

// TransferSetDownloadLimitPostWithBodyWithResponse request with arbitrary body returning *TransferSetDownloadLimitPostResponse
func (c *ClientWithResponses) TransferSetDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferSetDownloadLimitPostResponse, error) {
	rsp, err := c.TransferSetDownloadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferSetDownloadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TransferSetDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TransferSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferSetDownloadLimitPostResponse, error) {
	rsp, err := c.TransferSetDownloadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferSetDownloadLimitPostResponse(rsp)
}

// TransferSetUploadLimitPostWithBodyWithResponse request with arbitrary body returning *TransferSetUploadLimitPostResponse
func (c *ClientWithResponses) TransferSetUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferSetUploadLimitPostResponse, error) {
	rsp, err := c.TransferSetUploadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferSetUploadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TransferSetUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TransferSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferSetUploadLimitPostResponse, error) {
	rsp, err := c.TransferSetUploadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferSetUploadLimitPostResponse(rsp)
}

// TransferSpeedLimitsModeGetWithResponse request returning *TransferSpeedLimitsModeGetResponse
func (c *ClientWithResponses) TransferSpeedLimitsModeGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferSpeedLimitsModeGetResponse, error) {
	rsp, err := c.TransferSpeedLimitsModeGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferSpeedLimitsModeGetResponse(rsp)
}

// TransferToggleSpeedLimitsModeGetWithResponse request returning *TransferToggleSpeedLimitsModeGetResponse
func (c *ClientWithResponses) TransferToggleSpeedLimitsModeGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferToggleSpeedLimitsModeGetResponse, error) {
	rsp, err := c.TransferToggleSpeedLimitsModeGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferToggleSpeedLimitsModeGetResponse(rsp)
}

// TransferUploadLimitGetWithResponse request returning *TransferUploadLimitGetResponse
func (c *ClientWithResponses) TransferUploadLimitGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferUploadLimitGetResponse, error) {
	rsp, err := c.TransferUploadLimitGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferUploadLimitGetResponse(rsp)
}

// ParseAppBuildInfoGetResponse parses an HTTP response from a AppBuildInfoGetWithResponse call
func ParseAppBuildInfoGetResponse(rsp *http.Response) (*AppBuildInfoGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppBuildInfoGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppDefaultSavePathGetResponse parses an HTTP response from a AppDefaultSavePathGetWithResponse call
func ParseAppDefaultSavePathGetResponse(rsp *http.Response) (*AppDefaultSavePathGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppDefaultSavePathGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppPreferencesGetResponse parses an HTTP response from a AppPreferencesGetWithResponse call
func ParseAppPreferencesGetResponse(rsp *http.Response) (*AppPreferencesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppPreferencesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preferences
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppSetPreferencesPostResponse parses an HTTP response from a AppSetPreferencesPostWithResponse call
func ParseAppSetPreferencesPostResponse(rsp *http.Response) (*AppSetPreferencesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppSetPreferencesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppShutdownGetResponse parses an HTTP response from a AppShutdownGetWithResponse call
func ParseAppShutdownGetResponse(rsp *http.Response) (*AppShutdownGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppShutdownGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppVersionGetResponse parses an HTTP response from a AppVersionGetWithResponse call
func ParseAppVersionGetResponse(rsp *http.Response) (*AppVersionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppVersionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppWebapiVersionGetResponse parses an HTTP response from a AppWebapiVersionGetWithResponse call
func ParseAppWebapiVersionGetResponse(rsp *http.Response) (*AppWebapiVersionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppWebapiVersionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAuthLoginPostResponse parses an HTTP response from a AuthLoginPostWithResponse call
func ParseAuthLoginPostResponse(rsp *http.Response) (*AuthLoginPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLoginPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAuthLogoutPostResponse parses an HTTP response from a AuthLogoutPostWithResponse call
func ParseAuthLogoutPostResponse(rsp *http.Response) (*AuthLogoutPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLogoutPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLogMainPostResponse parses an HTTP response from a LogMainPostWithResponse call
func ParseLogMainPostResponse(rsp *http.Response) (*LogMainPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogMainPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MainLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLogPeersPostResponse parses an HTTP response from a LogPeersPostWithResponse call
func ParseLogPeersPostResponse(rsp *http.Response) (*LogPeersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogPeersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PeersLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRssAddFeedPostResponse parses an HTTP response from a RssAddFeedPostWithResponse call
func ParseRssAddFeedPostResponse(rsp *http.Response) (*RssAddFeedPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssAddFeedPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssAddFolderPostResponse parses an HTTP response from a RssAddFolderPostWithResponse call
func ParseRssAddFolderPostResponse(rsp *http.Response) (*RssAddFolderPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssAddFolderPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssItemsPostResponse parses an HTTP response from a RssItemsPostWithResponse call
func ParseRssItemsPostResponse(rsp *http.Response) (*RssItemsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssItemsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRssMarkAsReadPostResponse parses an HTTP response from a RssMarkAsReadPostWithResponse call
func ParseRssMarkAsReadPostResponse(rsp *http.Response) (*RssMarkAsReadPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssMarkAsReadPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssMatchingArticlesPostResponse parses an HTTP response from a RssMatchingArticlesPostWithResponse call
func ParseRssMatchingArticlesPostResponse(rsp *http.Response) (*RssMatchingArticlesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssMatchingArticlesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string][]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRssMoveItemPostResponse parses an HTTP response from a RssMoveItemPostWithResponse call
func ParseRssMoveItemPostResponse(rsp *http.Response) (*RssMoveItemPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssMoveItemPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssRefreshItemPostResponse parses an HTTP response from a RssRefreshItemPostWithResponse call
func ParseRssRefreshItemPostResponse(rsp *http.Response) (*RssRefreshItemPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssRefreshItemPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssRemoveItemPostResponse parses an HTTP response from a RssRemoveItemPostWithResponse call
func ParseRssRemoveItemPostResponse(rsp *http.Response) (*RssRemoveItemPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssRemoveItemPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssRemoveRulePostResponse parses an HTTP response from a RssRemoveRulePostWithResponse call
func ParseRssRemoveRulePostResponse(rsp *http.Response) (*RssRemoveRulePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssRemoveRulePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssRenameRulePostResponse parses an HTTP response from a RssRenameRulePostWithResponse call
func ParseRssRenameRulePostResponse(rsp *http.Response) (*RssRenameRulePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssRenameRulePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssRulesGetResponse parses an HTTP response from a RssRulesGetWithResponse call
func ParseRssRulesGetResponse(rsp *http.Response) (*RssRulesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssRulesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]RssRuleDef
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRssSetRulePostResponse parses an HTTP response from a RssSetRulePostWithResponse call
func ParseRssSetRulePostResponse(rsp *http.Response) (*RssSetRulePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssSetRulePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchDeletePostResponse parses an HTTP response from a SearchDeletePostWithResponse call
func ParseSearchDeletePostResponse(rsp *http.Response) (*SearchDeletePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDeletePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchEnablePluginPostResponse parses an HTTP response from a SearchEnablePluginPostWithResponse call
func ParseSearchEnablePluginPostResponse(rsp *http.Response) (*SearchEnablePluginPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchEnablePluginPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchInstallPluginPostResponse parses an HTTP response from a SearchInstallPluginPostWithResponse call
func ParseSearchInstallPluginPostResponse(rsp *http.Response) (*SearchInstallPluginPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchInstallPluginPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchPluginsGetResponse parses an HTTP response from a SearchPluginsGetWithResponse call
func ParseSearchPluginsGetResponse(rsp *http.Response) (*SearchPluginsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPluginsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SearchPlugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchResultsPostResponse parses an HTTP response from a SearchResultsPostWithResponse call
func ParseSearchResultsPostResponse(rsp *http.Response) (*SearchResultsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResultsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchStartPostResponse parses an HTTP response from a SearchStartPostWithResponse call
func ParseSearchStartPostResponse(rsp *http.Response) (*SearchStartPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchStartPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchStatusPostResponse parses an HTTP response from a SearchStatusPostWithResponse call
func ParseSearchStatusPostResponse(rsp *http.Response) (*SearchStatusPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchStatusPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SearchJobStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchStopPostResponse parses an HTTP response from a SearchStopPostWithResponse call
func ParseSearchStopPostResponse(rsp *http.Response) (*SearchStopPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchStopPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchUninstallPluginPostResponse parses an HTTP response from a SearchUninstallPluginPostWithResponse call
func ParseSearchUninstallPluginPostResponse(rsp *http.Response) (*SearchUninstallPluginPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUninstallPluginPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchUpdatePluginsPostResponse parses an HTTP response from a SearchUpdatePluginsPostWithResponse call
func ParseSearchUpdatePluginsPostResponse(rsp *http.Response) (*SearchUpdatePluginsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUpdatePluginsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncMaindataPostResponse parses an HTTP response from a SyncMaindataPostWithResponse call
func ParseSyncMaindataPostResponse(rsp *http.Response) (*SyncMaindataPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncMaindataPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MainData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSyncTorrentPeersPostResponse parses an HTTP response from a SyncTorrentPeersPostWithResponse call
func ParseSyncTorrentPeersPostResponse(rsp *http.Response) (*SyncTorrentPeersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncTorrentPeersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TorrentPeers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsAddPostResponse parses an HTTP response from a TorrentsAddPostWithResponse call
func ParseTorrentsAddPostResponse(rsp *http.Response) (*TorrentsAddPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsAddPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsAddPeersPostResponse parses an HTTP response from a TorrentsAddPeersPostWithResponse call
func ParseTorrentsAddPeersPostResponse(rsp *http.Response) (*TorrentsAddPeersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsAddPeersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsAddTagsPostResponse parses an HTTP response from a TorrentsAddTagsPostWithResponse call
func ParseTorrentsAddTagsPostResponse(rsp *http.Response) (*TorrentsAddTagsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsAddTagsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsAddTrackersPostResponse parses an HTTP response from a TorrentsAddTrackersPostWithResponse call
func ParseTorrentsAddTrackersPostResponse(rsp *http.Response) (*TorrentsAddTrackersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsAddTrackersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsBottomPrioPostResponse parses an HTTP response from a TorrentsBottomPrioPostWithResponse call
func ParseTorrentsBottomPrioPostResponse(rsp *http.Response) (*TorrentsBottomPrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsBottomPrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsCategoriesGetResponse parses an HTTP response from a TorrentsCategoriesGetWithResponse call
func ParseTorrentsCategoriesGetResponse(rsp *http.Response) (*TorrentsCategoriesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsCategoriesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]TorrentsCategory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsCreateCategoryPostResponse parses an HTTP response from a TorrentsCreateCategoryPostWithResponse call
func ParseTorrentsCreateCategoryPostResponse(rsp *http.Response) (*TorrentsCreateCategoryPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsCreateCategoryPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsCreateTagsPostResponse parses an HTTP response from a TorrentsCreateTagsPostWithResponse call
func ParseTorrentsCreateTagsPostResponse(rsp *http.Response) (*TorrentsCreateTagsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsCreateTagsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsDecreasePrioPostResponse parses an HTTP response from a TorrentsDecreasePrioPostWithResponse call
func ParseTorrentsDecreasePrioPostResponse(rsp *http.Response) (*TorrentsDecreasePrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsDecreasePrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsDeletePostResponse parses an HTTP response from a TorrentsDeletePostWithResponse call
func ParseTorrentsDeletePostResponse(rsp *http.Response) (*TorrentsDeletePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsDeletePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsDeleteTagsPostResponse parses an HTTP response from a TorrentsDeleteTagsPostWithResponse call
func ParseTorrentsDeleteTagsPostResponse(rsp *http.Response) (*TorrentsDeleteTagsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsDeleteTagsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsDownloadLimitPostResponse parses an HTTP response from a TorrentsDownloadLimitPostWithResponse call
func ParseTorrentsDownloadLimitPostResponse(rsp *http.Response) (*TorrentsDownloadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsDownloadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TorrentsLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsEditCategoryPostResponse parses an HTTP response from a TorrentsEditCategoryPostWithResponse call
func ParseTorrentsEditCategoryPostResponse(rsp *http.Response) (*TorrentsEditCategoryPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsEditCategoryPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsEditTrackerPostResponse parses an HTTP response from a TorrentsEditTrackerPostWithResponse call
func ParseTorrentsEditTrackerPostResponse(rsp *http.Response) (*TorrentsEditTrackerPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsEditTrackerPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsFilePrioPostResponse parses an HTTP response from a TorrentsFilePrioPostWithResponse call
func ParseTorrentsFilePrioPostResponse(rsp *http.Response) (*TorrentsFilePrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsFilePrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsFilesPostResponse parses an HTTP response from a TorrentsFilesPostWithResponse call
func ParseTorrentsFilesPostResponse(rsp *http.Response) (*TorrentsFilesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsFilesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TorrentsFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsIncreasePrioPostResponse parses an HTTP response from a TorrentsIncreasePrioPostWithResponse call
func ParseTorrentsIncreasePrioPostResponse(rsp *http.Response) (*TorrentsIncreasePrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsIncreasePrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsInfoPostResponse parses an HTTP response from a TorrentsInfoPostWithResponse call
func ParseTorrentsInfoPostResponse(rsp *http.Response) (*TorrentsInfoPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsInfoPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TorrentInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsPausePostResponse parses an HTTP response from a TorrentsPausePostWithResponse call
func ParseTorrentsPausePostResponse(rsp *http.Response) (*TorrentsPausePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsPausePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsPieceHashesPostResponse parses an HTTP response from a TorrentsPieceHashesPostWithResponse call
func ParseTorrentsPieceHashesPostResponse(rsp *http.Response) (*TorrentsPieceHashesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsPieceHashesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsPieceStatesPostResponse parses an HTTP response from a TorrentsPieceStatesPostWithResponse call
func ParseTorrentsPieceStatesPostResponse(rsp *http.Response) (*TorrentsPieceStatesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsPieceStatesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsPropertiesPostResponse parses an HTTP response from a TorrentsPropertiesPostWithResponse call
func ParseTorrentsPropertiesPostResponse(rsp *http.Response) (*TorrentsPropertiesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsPropertiesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TorrentsProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsReannouncePostResponse parses an HTTP response from a TorrentsReannouncePostWithResponse call
func ParseTorrentsReannouncePostResponse(rsp *http.Response) (*TorrentsReannouncePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsReannouncePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRecheckPostResponse parses an HTTP response from a TorrentsRecheckPostWithResponse call
func ParseTorrentsRecheckPostResponse(rsp *http.Response) (*TorrentsRecheckPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRecheckPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRemoveCategoriesPostResponse parses an HTTP response from a TorrentsRemoveCategoriesPostWithResponse call
func ParseTorrentsRemoveCategoriesPostResponse(rsp *http.Response) (*TorrentsRemoveCategoriesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRemoveCategoriesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRemoveTagsPostResponse parses an HTTP response from a TorrentsRemoveTagsPostWithResponse call
func ParseTorrentsRemoveTagsPostResponse(rsp *http.Response) (*TorrentsRemoveTagsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRemoveTagsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRemoveTrackersPostResponse parses an HTTP response from a TorrentsRemoveTrackersPostWithResponse call
func ParseTorrentsRemoveTrackersPostResponse(rsp *http.Response) (*TorrentsRemoveTrackersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRemoveTrackersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRenamePostResponse parses an HTTP response from a TorrentsRenamePostWithResponse call
func ParseTorrentsRenamePostResponse(rsp *http.Response) (*TorrentsRenamePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRenamePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRenameFilePostResponse parses an HTTP response from a TorrentsRenameFilePostWithResponse call
func ParseTorrentsRenameFilePostResponse(rsp *http.Response) (*TorrentsRenameFilePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRenameFilePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRenameFolderPostResponse parses an HTTP response from a TorrentsRenameFolderPostWithResponse call
func ParseTorrentsRenameFolderPostResponse(rsp *http.Response) (*TorrentsRenameFolderPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRenameFolderPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsResumePostResponse parses an HTTP response from a TorrentsResumePostWithResponse call
func ParseTorrentsResumePostResponse(rsp *http.Response) (*TorrentsResumePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsResumePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetAutoManagementPostResponse parses an HTTP response from a TorrentsSetAutoManagementPostWithResponse call
func ParseTorrentsSetAutoManagementPostResponse(rsp *http.Response) (*TorrentsSetAutoManagementPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetAutoManagementPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetCategoryPostResponse parses an HTTP response from a TorrentsSetCategoryPostWithResponse call
func ParseTorrentsSetCategoryPostResponse(rsp *http.Response) (*TorrentsSetCategoryPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetCategoryPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetDownloadLimitPostResponse parses an HTTP response from a TorrentsSetDownloadLimitPostWithResponse call
func ParseTorrentsSetDownloadLimitPostResponse(rsp *http.Response) (*TorrentsSetDownloadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetDownloadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetForceStartPostResponse parses an HTTP response from a TorrentsSetForceStartPostWithResponse call
func ParseTorrentsSetForceStartPostResponse(rsp *http.Response) (*TorrentsSetForceStartPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetForceStartPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetLocationPostResponse parses an HTTP response from a TorrentsSetLocationPostWithResponse call
func ParseTorrentsSetLocationPostResponse(rsp *http.Response) (*TorrentsSetLocationPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetLocationPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetShareLimitsPostResponse parses an HTTP response from a TorrentsSetShareLimitsPostWithResponse call
func ParseTorrentsSetShareLimitsPostResponse(rsp *http.Response) (*TorrentsSetShareLimitsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetShareLimitsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetSuperSeedingPostResponse parses an HTTP response from a TorrentsSetSuperSeedingPostWithResponse call
func ParseTorrentsSetSuperSeedingPostResponse(rsp *http.Response) (*TorrentsSetSuperSeedingPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetSuperSeedingPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetUploadLimitPostResponse parses an HTTP response from a TorrentsSetUploadLimitPostWithResponse call
func ParseTorrentsSetUploadLimitPostResponse(rsp *http.Response) (*TorrentsSetUploadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetUploadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsTagsGetResponse parses an HTTP response from a TorrentsTagsGetWithResponse call
func ParseTorrentsTagsGetResponse(rsp *http.Response) (*TorrentsTagsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsTagsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsToggleFirstLastPiecePrioPostResponse parses an HTTP response from a TorrentsToggleFirstLastPiecePrioPostWithResponse call
func ParseTorrentsToggleFirstLastPiecePrioPostResponse(rsp *http.Response) (*TorrentsToggleFirstLastPiecePrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsToggleFirstLastPiecePrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsToggleSequentialDownloadPostResponse parses an HTTP response from a TorrentsToggleSequentialDownloadPostWithResponse call
func ParseTorrentsToggleSequentialDownloadPostResponse(rsp *http.Response) (*TorrentsToggleSequentialDownloadPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsToggleSequentialDownloadPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsTopPrioPostResponse parses an HTTP response from a TorrentsTopPrioPostWithResponse call
func ParseTorrentsTopPrioPostResponse(rsp *http.Response) (*TorrentsTopPrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsTopPrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsTrackersPostResponse parses an HTTP response from a TorrentsTrackersPostWithResponse call
func ParseTorrentsTrackersPostResponse(rsp *http.Response) (*TorrentsTrackersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsTrackersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TorrentsTrackers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsUploadLimitPostResponse parses an HTTP response from a TorrentsUploadLimitPostWithResponse call
func ParseTorrentsUploadLimitPostResponse(rsp *http.Response) (*TorrentsUploadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsUploadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TorrentsLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentWebseedsPostResponse parses an HTTP response from a TorrentWebseedsPostWithResponse call
func ParseTorrentWebseedsPostResponse(rsp *http.Response) (*TorrentWebseedsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentWebseedsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TorrentsWebseeds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTransferBanPeersPostResponse parses an HTTP response from a TransferBanPeersPostWithResponse call
func ParseTransferBanPeersPostResponse(rsp *http.Response) (*TransferBanPeersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferBanPeersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferDownloadLimitGetResponse parses an HTTP response from a TransferDownloadLimitGetWithResponse call
func ParseTransferDownloadLimitGetResponse(rsp *http.Response) (*TransferDownloadLimitGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferDownloadLimitGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferInfoGetResponse parses an HTTP response from a TransferInfoGetWithResponse call
func ParseTransferInfoGetResponse(rsp *http.Response) (*TransferInfoGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferInfoGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTransferSetDownloadLimitPostResponse parses an HTTP response from a TransferSetDownloadLimitPostWithResponse call
func ParseTransferSetDownloadLimitPostResponse(rsp *http.Response) (*TransferSetDownloadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferSetDownloadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferSetUploadLimitPostResponse parses an HTTP response from a TransferSetUploadLimitPostWithResponse call
func ParseTransferSetUploadLimitPostResponse(rsp *http.Response) (*TransferSetUploadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferSetUploadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferSpeedLimitsModeGetResponse parses an HTTP response from a TransferSpeedLimitsModeGetWithResponse call
func ParseTransferSpeedLimitsModeGetResponse(rsp *http.Response) (*TransferSpeedLimitsModeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferSpeedLimitsModeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferToggleSpeedLimitsModeGetResponse parses an HTTP response from a TransferToggleSpeedLimitsModeGetWithResponse call
func ParseTransferToggleSpeedLimitsModeGetResponse(rsp *http.Response) (*TransferToggleSpeedLimitsModeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferToggleSpeedLimitsModeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferUploadLimitGetResponse parses an HTTP response from a TransferUploadLimitGetWithResponse call
func ParseTransferUploadLimitGetResponse(rsp *http.Response) (*TransferUploadLimitGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferUploadLimitGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
