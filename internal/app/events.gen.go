// Code generated by github.com/dashotv/golem. DO NOT EDIT.
package app

import (
	"context"
	"fmt"
	"time"

	"github.com/nats-io/nats.go"
	"go.uber.org/zap"

	"github.com/dashotv/fae"
	"github.com/dashotv/flame/nzbget"
	"github.com/dashotv/flame/qbt"
	"github.com/dashotv/mercury"
)

func init() {
	initializers = append(initializers, setupEvents)
	healthchecks["events"] = checkEvents
	starters = append(starters, startEvents)
}

type EventsChannel string
type EventsTopic string

func setupEvents(app *Application) error {
	events, err := NewEvents(app)
	if err != nil {
		return err
	}

	app.Events = events
	return nil
}

func startEvents(ctx context.Context, app *Application) error {
	go app.Events.Start(ctx)
	return nil
}

func checkEvents(app *Application) error {
	switch app.Events.Merc.Status() {
	case nats.CONNECTED:
		return nil
	default:
		return fae.Errorf("nats status: %s", app.Events.Merc.Status())
	}
}

type Events struct {
	App          *Application
	Merc         *mercury.Mercury
	Log          *zap.SugaredLogger
	Combined     chan *Combined
	Metrics      chan *Metrics
	Nzbs         chan *nzbget.GroupResponse
	Qbittorrents chan *qbt.Response
}

func NewEvents(app *Application) (*Events, error) {
	m, err := mercury.New("flame", app.Config.NatsURL)
	if err != nil {
		return nil, err
	}

	e := &Events{
		App:          app,
		Merc:         m,
		Log:          app.Log.Named("events"),
		Combined:     make(chan *Combined),
		Metrics:      make(chan *Metrics),
		Nzbs:         make(chan *nzbget.GroupResponse),
		Qbittorrents: make(chan *qbt.Response),
	}

	if err := e.Merc.Sender("flame.combined", e.Combined); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("flame.metrics", e.Metrics); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("flame.nzbs", e.Nzbs); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("flame.qbittorrents", e.Qbittorrents); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *Events) Start(ctx context.Context) error {
	e.Log.Debugf("starting events...")
	// no receivers
	return nil
}

func (e *Events) Send(topic EventsTopic, data any) error {
	f := func() interface{} { return e.doSend(topic, data) }

	err, ok := WithTimeout(f, time.Second*5)
	if !ok {
		e.Log.Errorf("timeout sending: %s", topic)
		return fmt.Errorf("timeout sending: %s", topic)
	}
	if err != nil {
		e.Log.Errorf("sending: %s", err)
		return fae.Wrap(err.(error), "events.send")
	}
	return nil
}

func (e *Events) doSend(topic EventsTopic, data any) error {
	switch topic {
	case "flame.combined":
		m, ok := data.(*Combined)
		if !ok {
			return fae.Errorf("events.send: wrong data type: %t", data)
		}
		e.Combined <- m

	case "flame.metrics":
		m, ok := data.(*Metrics)
		if !ok {
			return fae.Errorf("events.send: wrong data type: %t", data)
		}
		e.Metrics <- m

	case "flame.nzbs":
		m, ok := data.(*nzbget.GroupResponse)
		if !ok {
			return fae.Errorf("events.send: wrong data type: %t", data)
		}
		e.Nzbs <- m

	case "flame.qbittorrents":
		m, ok := data.(*qbt.Response)
		if !ok {
			return fae.Errorf("events.send: wrong data type: %t", data)
		}
		e.Qbittorrents <- m
	default:
		e.Log.Warnf("events.send: unknown topic: %s", topic)
	}
	return nil
}
